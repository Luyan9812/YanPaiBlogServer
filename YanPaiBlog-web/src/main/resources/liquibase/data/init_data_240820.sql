-- 初始化类目
INSERT INTO `category` (`id`, `category_name`)
VALUES ('1', '后端'),
       ('2', '前端'),
       ('3', '大数据'),
       ('4', 'Android'),
       ('5', 'IOS'),
       ('6', '人工智能'),
       ('7', '开发工具'),
       ('8', '代码人生'),
       ('9', '阅读');


-- 初始化标签
INSERT INTO `tag` (`id`, `tag_name`, `category_id`)
VALUES ('1', 'Java', '1') ,
       ('2', 'Go', '1') ,
       ('3', '算法', '1') ,
       ('4', 'Python', '1') ,
       ('5', 'Spring Boot', '1') ,
       ('6', '面试', '1') ,
       ('7', 'MySQL', '1') ,
       ('8', '数据库', '1') ,
       ('137', 'MyBatis', '1') ,
       ('138', 'MyBatis-Plus', '1') ,
       ('139', 'SSM', '1') ,
       ('140', 'SpringMVC', '1') ,
       ('142', '爬虫', '1') ,
       ('9', 'Spring', '1') ,
       ('10', '架构', '1') ,
       ('11', 'LeetCode', '1') ,
       ('12', 'Redis', '1') ,
       ('13', '前端', '1') ,
       ('14', 'Linux', '1') ,
       ('15', 'JavaScript', '2') ,
       ('16', 'Vue.js', '2') ,
       ('17', 'React.js', '2') ,
       ('18', 'CSS', '2') ,
       ('19', '面试', '2') ,
       ('20', 'TypeScript', '2') ,
       ('21', '后端', '2') ,
       ('22', 'Node.js', '2') ,
       ('23', '前端框架', '2') ,
       ('24', '算法', '2') ,
       ('25', 'Webpack', '2') ,
       ('26', '架构', '2') ,
       ('27', '微信小程序', '2') ,
       ('28', 'GitHub', '2') ,
       ('29', 'Kotlin', '4') ,
       ('30', 'Flutter', '4') ,
       ('31', '前端', '4') ,
       ('32', 'Java', '4') ,
       ('33', 'Android Jetpack', '4') ,
       ('34', 'APP', '4') ,
       ('35', 'Android Studio', '4') ,
       ('36', '源码', '4') ,
       ('37', '性能优化', '4') ,
       ('38', '面试', '4') ,
       ('39', '架构', '4') ,
       ('40', 'gradle', '4') ,
       ('41', '程序员', '4') ,
       ('42', 'Swift', '5') ,
       ('43', 'SwiftUI', '5') ,
       ('44', 'Flutter', '5') ,
       ('45', '算法', '5') ,
       ('46', '前端', '5') ,
       ('47', 'LeetCode', '5') ,
       ('48', 'Xcode', '5') ,
       ('49', 'Objective-C', '5') ,
       ('50', 'Mac', '5') ,
       ('51', 'WWDC', '5') ,
       ('52', '计算机视觉', '5') ,
       ('53', 'Apple', '5') ,
       ('54', '音视频开发', '5') ,
       ('55', '深度学习', '6') ,
       ('56', '算法', '6') ,
       ('57', '机器学习', '6') ,
       ('58', 'Python', '6') ,
       ('59', '后端', '6') ,
       ('60', '计算机视觉', '6') ,
       ('61', 'PyTorch', '6') ,
       ('62', 'NLP', '6') ,
       ('63', '数据分析', '6') ,
       ('64', '神经网络', '6') ,
       ('65', 'TensorFlow', '6') ,
       ('66', '数据可视化', '6') ,
       ('67', '程序员', '6') ,
       ('68', '数据挖掘', '6') ,
       ('69', '后端', '7') ,
       ('70', '前端', '7') ,
       ('71', '开源', '7') ,
       ('72', 'Git', '7') ,
       ('73', 'GitHub', '7') ,
       ('74', 'Linux', '7') ,
       ('75', '测试', '7') ,
       ('76', 'Python', '7') ,
       ('77', '数据库', '7') ,
       ('78', '设计', '7') ,
       ('79', '程序员', '7') ,
       ('80', 'JavaScript', '7') ,
       ('81', 'Unity3D', '7') ,
       ('82', 'Rust', '7') ,
       ('83', '大数据', '7') ,
       ('141', 'Maven', '7') ,
       ('143', 'Docker', '7') ,
       ('144', '正则表达式', '7') ,
       ('84', '程序员', '8') ,
       ('85', '前端', '8') ,
       ('86', '后端', '8') ,
       ('87', '算法', '8') ,
       ('88', 'JavaScript', '8') ,
       ('89', 'Java', '8') ,
       ('90', 'Python', '8') ,
       ('91', '架构', '8') ,
       ('92', '开源', '8') ,
       ('93', '面试', '8') ,
       ('94', '年终总结', '8') ,
       ('95', '大数据', '8') ,
       ('96', 'Linux', '8') ,
       ('97', '数据结构', '8') ,
       ('98', 'GitHub', '8') ,
       ('99', '云原生', '9') ,
       ('100', '笔记', '9') ,
       ('101', '程序员', '9') ,
       ('102', '前端', '9') ,
       ('103', '后端', '9') ,
       ('104', 'Serverless', '9') ,
       ('105', '开源', '9') ,
       ('106', '容器', '9') ,
       ('107', '微服务', '9') ,
       ('108', 'Java', '9') ,
       ('109', '产品', '9') ,
       ('110', '产品经理', '9') ,
       ('111', '算法', '9') ,
       ('112', 'RocketMQ', '9') ,
       ('113', '深度学习', '9') ,
       ('114', 'sqlite', '3') ,
       ('115', 'sql', '3') ,
       ('116', 'spark', '3') ,
       ('117', 'hive', '3') ,
       ('118', 'hbase', '3') ,
       ('119', 'hdfs', '3') ,
       ('120', 'redis', '3') ,
       ('121', 'hadoop', '3') ,
       ('122', 'rabbitmq', '3') ,
       ('123', 'postgresql', '3') ,
       ('124', '数据库', '3') ,
       ('125', '数据仓库', '3') ,
       ('126', '大数据', '3') ,
       ('127', 'oracle', '3') ,
       ('128', 'flink', '3') ,
       ('129', 'nosql', '3') ,
       ('130', 'mysql', '3') ,
       ('131', 'eureka', '3') ,
       ('132', 'mongodb', '3') ,
       ('133', 'zookeeper', '3') ,
       ('134', 'elasticsearch', '3') ,
       ('135', 'kafka', '3') ,
       ('136', 'json', '3');


-- 初始化文章表
INSERT INTO `article` (`id`, `user_id`, `title`, `picture`, `summary`, `category_id`, `status`, `hot_score`)
VALUES (1, 1, '《Java编程的逻辑》书籍推荐', '', '好书推荐', 9, 2, 0),
       (2, 1, '《算法竞赛入门经典》书籍推荐', '', '书籍推荐', 9, 2, 0),
       (3, 1, 'Git学习笔记', '/upload/covers/5d320eba75ce46dfbdb5c75e48616be7.png', 'Git是一个开源的分布式版本控制系统，由Linus Torvalds（Linux内核的创始人）在2005年创建，用于有效、高速地处理从小到大的项目版本管理。Git是目前世界上最流行的版本控制系统，广泛应用于软件开发中。', 7, 1, 0),
       (4, 1, '正则表达式学习笔记', '/upload/covers/48cdcdc8d485490b99bb62f52f9f6ac6.jpg', '正则表达式（Regular Expression，简称 regex 或 regexp）是一种文本模式描述的工具，它使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。正则表达式由普通字符（例如，字母 a 到 z）和特殊字符（称为\"元字符\"）组成。', 7, 1, 0),
       (5, 1, 'Docker学习笔记', '/upload/covers/cc1f1d19589c46408ffb36f959afbd5b.png', 'Docker 是一个开源的应用容器引擎，它允许开发者打包他们的应用以及应用的依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。', 7, 1, 96),
       (6, 1, 'Python 自动化办公之 Excel', '/upload/covers/1bb71a858c7d4f5abb9dfcc9f02ce823.jpg', 'openpyxl 是一个 Python 库，专门用于读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件。它提供了一系列的功能，可以创建、修改和读取 Excel 文件，而不需要依赖外部软件如 Microsoft Excel。', 1, 1, 0),
       (7, 1, 'Python3 网络爬虫（上）', '/upload/covers/f7865bcf1aa94ef39338352d7b7c9358.jpeg', '大纲\n一. 数据请求\n1. urllib 库\n1.1 get 请求\n1.2 post 请求\n1.3 urlopen 的 timeout 参数\n1.4 构建 Request 对象指定 headers\n1.5 使用 Handler 通过基本身份验证\n1.6 使用 Handler 设置代理\n1.7 使用 Handler 操作 Cookie\n1.8 使用 Handler 保存或加载 Cookie\n1.9 关于异常\n1.10 parse 模块的一些常用函数\n2. requests 库（需安装）\n2.1 GET 请求\n', 1, 1, 0),
       (8, 1, 'Pyhton3 网络爬虫（中）', '/upload/covers/e39524d5e64543548a8f88858d8a7457.jpeg', '大纲\n1. 协程\n1.1 简单使用\n1.2 将协程对象封装成 Task 对象\n1.3 绑定回调\n1.4 多任务协程\n1.5 异步请求\n1.5.1 背景\n1.5.2 吐槽 requests\n1.5.3 赞美 aiohttp\n2. aiohttp 使用（需安装）\n2.1 基本使用\n2.2 携带参数\n2.3 POST 请求\n2.4 响应\n2.5 超时\n2.6 并发限制\n2.7 代理\n2.8 实战\n3. Selenium 使用\n3.1 安装\n3.1.1 安装 ChromeDriver\n3.1.2 安装 seleni', 1, 1, 0),
       (9, 1, 'Python3 网络爬虫（下）', '/upload/covers/aa73a0b9e71949d0adf2481132ac7120.jpeg', '大纲\n1. Scrapy 框架使用\n1.1 安装\n1.1.1 安装命令\n1.1.2 配置环境变量\n1.2 小项目入门\n1.2.1 创建项目\n1.2.2 定义数据结构\n1.2.3 创建一个 Spider\n1.2.4 重写 parse 方法处理 response\n1.2.5 启动项目\n1.2.6 保存文件到数据库', 1, 1, 0),
       (10, 1, 'Maven 学习笔记', '/upload/covers/256d8e923a024d8f822ae2d20b0aed0a.jpg', '大纲\n1. 安装 & 配置\n1.1. 安装\n1.2. 配置\n1.2.1. 本地仓库\n1.2.2. 阿里云仓库镜像\n1.2.3. jdk 版本配置\n1.2.4. 环境变量\n2. IDEA 集成 Maven\n2.1. 配置 Maven 环境\n2.1.1. 项目配置 Maven 环境\n2.1.2. 全局配置 Maven 环境\n2.2. 创建 Maven 项目\n2.2.1. 创建普通 Java 工程\n2.2.2. 创建 Java web 模块\n2.2.2.1. 手动创建\n2.2.2.2. 插件快速创建\n2.3. 导', 1, 1, 94),
       (11, 1, 'Spring 学习笔记', '/upload/covers/c294bdea5bac4a97ad7b393c020ebb05.png', '大纲\n1. 简介\n2. 容器\n3. Ioc & DI\n3.1. IoC\n3.2. DI\n4. xml 配置\n4.1. 创建 xml 文件\n4.2. 配置普通对象\n4.3. 工厂模式\n4.3.1. 静态工厂\n4.3.2. 非静态工厂\n4.4. 依赖注入\n4.4.1. 数据定义\n4.4.2. 构造注入\n4.4.3. Setter 注入\n4.5. 获取对象\n4.6. 周期 & 作用域\n4.6.1. 生命周期\n4.6.2. 作用域\n4.7. 标准工厂\n4.8. 占位符\n5. 注解配置\n5.1. Spring bea', 1, 1, 0),
       (12, 1, 'MyBatis 学习笔记', '/upload/covers/f4e405503fee4dedb8bc581649f6b596.png', '大纲\n1. 快速入门\n1.1. 导包\n1.2. 使用\n1.2.1. 定义操作接口\n1.2.2. 编写 mapper 文件\n1.2.3. 核心配置文件\n1.2.4. 编码\n2. 参数传递\n2.1. 取值\n2.2. 单简单类型传参\n2.3. 多简单类型传参\n2.4. 单对象传参\n2.5. Map 传参\n3. 返回值\n3.1. 返回值别名\n3.1.1. 全限定符\n3.1.2. MyBatis 默认别名\n3.1.3. 自定义别名\n3.1.3.1. 单个定义\n3.1.3.2. 批量定义\n3.2. 属性映射\n3.2.1', 1, 1, 0),
       (13, 1, 'SpringMVC 学习笔记', '/upload/covers/bbe5b3fa33744af58aed5e2a655b9e92.png', '大纲\n1. 简介\n2. 流程\n2.1. 导言\n2.2. 细节\n3. 快速入门\n3.1. 导包\n3.2. 创建 Handler\n3.3. 创建配置类\n3.4. 初始化 & 运行\n4. 路径设置\n4.1. 精准路径\n4.2. 模糊路径\n4.3. 类注解\n4.4. 指定请求方式\n4.5. 其它注解\n5. 数据获取\n5.1. param 参数获取\n5.1.1. 直接接收\n5.1.2. 注解指定\n5.1.3. 多对一接收\n5.1.4. 实体类接收\n5.1.5. 动态路径\n5.2. json 参数获取\n5.3. Coo', 1, 1, 0),
       (14, 1, 'SSM 整合', '/upload/covers/fd72822954f9424a93b6c97dba3485cc.png', '大纲\n1. 概念\n2. 整合 4 问\n2.1. SSM 整合需要几个容器\n2.2. 各容器装哪些组件\n2.3. Spring 配置类需要多少个\n2.4. 如何指定各配置类\n3. 整合 SpringMVC\n3.1. 导包\n3.1.1. 必须包\n3.1.2. 选配包\n3.2. 配置类\n3.3. 测试\n3.3.1. 初始化类\n3.3.2. Handler\n4. 整合 aop 与 tx\n4.1. 导包\n4.1.1. 必选包\n4.1.2. 选配包\n4.2. 配置类\n5. 整合 MyBatis\n5.1. 导包\n5.2.', 1, 1, 0),
       (15, 1, 'SpringBoot 学习笔记', '/upload/covers/7a624abd84494bc78c6ac34da3317b66.png', '大纲\n1. 快速入门\n1.1. 配置\n1.2. 写 Handler\n1.3. 配置启动类\n2. 统一配置管理\n2.1. 概念\n2.2. properties 格式\n2.3. yml 格式\n2.4. 多配置文件\n2.5. 常用内置配置项\n2.6. 拦截器配置\n3. 整合 Druid 连接池\n3.1. 导包\n3.2. 配置\n3.3. 使用\n4. 整合 MyBatis\n4.1. 导包\n4.2. 配置\n4.3. 使用\n5. 整合 tx 与 aop\n5.1. tx\n5.2. aop\n6. 打包运行\n6.1. 打包\n6', 1, 1, 97),
       (16, 1, 'MyBatis-Plus 学习笔记', '/upload/covers/d3998be3869d4377a46b2e71d3428311.jpeg', '大纲\n1. 快速入门\n1.1. 导包\n1.2. 配置\n1.3. 定义接口\n1.4. 启动类\n1.5. 测试\n2. Mapper CRUD\n2.1. 增\n2.2. 删\n2.3. 改\n2.4. 查\n3. Service CRUD\n3.1. 创建 Service\n3.2. 增\n3.3. 删\n3.4. 改\n3.5. 查\n3.5.1. 查一条数据\n3.5.2. 查多条数据\n3.5.3. 统计查询\n3.6. 增改\n4. 分页查询\n4.1. 添加插件\n4.2. Mapper 分页\n4.2.1. 方法\n4.2.2. 使用\n', 1, 1, 95),
       (17, 1, 'Vue3 学习笔记（上）', '/upload/covers/6b41a48ae996415ea71bb1de9b713d53.png', '大纲\n1. 开始\n1.1. 安装 Node.js\n1.2. 基于 Vite 创建项目\n1.3. 目录结构\n1.4. 基本文件的解读\n1.4.1. index.html\n1.4.2. src/main.ts\n2. 核心语法\n2.1. 新旧 Vue\n2.1.1. Vue2 Demo\n2.1.2. Vue3 Demo\n2.1.3. Vue2 与 Vue3 混合\n2.2. setup 语法糖\n2.3. 响应式数据\n2.3.1. 基本数据类型\n2.3.2. 对象类型\n2.3.2.1. reactive\n2.3.2.2', 2, 1, 0),
       (18, 1, 'Vue3 学习笔记（中）', '/upload/covers/463c552ad8854835a103f1e9dc492b94.png', '\n3. 路由\n3.1. 安装\n3.2. 创建路由器\n3.3. 应用路由器\n3.4. 使用\n3.5. 注意点\n3.6. 路由器的工作模式\n3.7. 路由的几种方式\n3.8. 路由嵌套\n3.9. 路由参数\n3.9.1. query 参数\n3.9.2. params 参数\n3.10. props 配置\n3.10.1. 配置 props 属性\n3.10.2. 自定义 props\n3.10.3. 固定 props\n3.11. replace 属性\n3.12. 编程式路由导航\n3.13. 重定向\n4. pinia 集成', 2, 1, 0),
       (19, 1, 'Vue3 学习笔记（下）', '/upload/covers/d5740321885a4496bbe52b2df35121b9.png', '\n6. 其它 API\n6.1. shallow\n6.1.1. shallowRef\n6.1.2. shallowReactive\n6.2. only\n6.2.1. readonly\n6.2.2. shallowReadonly\n6.3. raw\n6.3.1. toRaw\n6.3.2. markRaw\n6.4. customRef\n6.5. Teleport\n6.6. 全局\n6.6.1. 全局组件\n6.6.2. 全局指令\n7. 常用功能\n7.1. 随机字符串\n7.1.1. nanoid\n7.1.2. uuid', 2, 1, 98),
       (20, 1, 'LeetCode: 1-50', '/upload/covers/adefdf7bafff4b8db77fcf1961a6aca8.png', '大纲\n1. 两数之和\n2. 两数相加\n3. 无重复字符的最长子串\n4. 寻找两个正序数组的中位数\n5. 最长回文子串\n6. N 字形变换\n7. 整数反转\n8. 字符串转换整数（atoi）\n9. 回文数\n10. 正则表达式匹配\n11. 盛最多水的容器\n12. 整数转罗马数字\n13. 罗马数字转整数\n14. 最长公共前缀\n15. 三数之和\n16. 最接近的三数之和\n17. 电话号码的字母组合\n18. 四数之和\n19. 删除链表的倒数第 N 个节点\n20. 有效的括号\n21. 合并两个有序链表\n22. 括号生成\n', 1, 1, 0),
       (21, 1, 'LeetCode: 51-100', '/upload/covers/af27a9ebe0bc46f0876cfa8a64428cd2.png', '大纲\n51. N 皇后\n52. N 皇后Ⅱ\n53. 最大子数组和\n54. 螺旋矩阵\n55. 跳跃游戏\n56. 合并区间\n57. 插入区间\n58. 最后一个单词的长度\n59. 螺旋矩阵Ⅱ\n60. 排列序列\n61. 旋转链表\n62. 不同路径\n63. 不同路径Ⅱ\n64. 最小路径和\n65. 有效数字\n66. 加一\n67. 二进制求和\n68. 文本左右对齐\n69. x 的平方根\n70. 爬楼梯\n71. 简化路径\n72. 编辑距离\n73. 矩阵置零\n74. 搜索二维矩阵\n75. 颜色分类\n76. 最小覆盖子串\n77', 1, 1, 0),
       (22, 1, 'LeetCode: 101-150', '/upload/covers/bbd4e98732484925b1a181349da38934.png', '大纲\n101. 对称二叉树\n102. 二叉树的层序遍历\n103. 二叉树的锯齿形层序遍历\n104. 二叉树的最大深度\n105. 从前序与中序遍历序列构造二叉树\n106. 从中序与后序遍历序列构造二叉树\n107. 二叉树的层序遍历Ⅱ\n108. 将有序数组转换为二叉搜索树\n109. 有序链表转换二叉搜索树\n110. 平衡二叉树\n111. 二叉树的最小深度\n112. 路径总和\n113. 路径总和Ⅱ\n114. 二叉树展开为链表\n115. 不同的子序列\n116. 填充每一个节点的下一个右侧节点指针\n117. 填充每一', 1, 1, 99),
       (23, 1, 'Redis 学习笔记', '/upload/covers/3a4f6bc4b3f54b4db758330eb61f99f5.png', '大纲\n1. 环境搭建\n1.1. 安装\n1.2. 配置\n1.3. 启动\n1.4. 连接\n1.4.1. 控制台连接\n1.4.2. 图形化界面\n2. 使用\n2.1. 数据结构\n2.2. 命令\n2.3. 通用命令\n2.3.1. KEYS\n2.3.2. DEL\n2.3.3. EXISTS\n2.3.4. EXPIRE\n2.3.5. TTL\n2.3.6. COPY\n2.4. String 命令\n2.4.1. SET\n2.4.2. GET\n2.4.3. MSET\n2.4.4. MGET\n2.4.5. 自增\n2.4.6. 自', 1, 1, 100);


-- 初始化文章细节表
INSERT INTO `article_detail` (`id`, `article_id`, `content`)
VALUES (1, 1, '### 1. 作者简介\n&emsp;&emsp;马俊昌，邻家科技CTO和联合创始人，北京理工大学博士。曾就职于IBM，从事中间件、云计算架构和开发工作，在万普世纪负责移动广告平台大数据分析和算法优化工作。\n&emsp;&emsp;2014年联合创立邻家科技，主要产品“到位APP”是一个到家生活服务平台。十多年来，一直从事Java编程，积累了比较丰富的经验。平时喜欢读书，研究技术与创新，乐于分享编程心得，欢迎关注我的微信公众号“老马说编程”，和你一起探索编程本质。\n### 2. 内容简介\n<center>\n  <img src=\"/configImages/JavaLogic.png\" width=\"400\" >\n</center>\n\n&emsp;&emsp;Java专家撰写，力求透彻讲解每个知识点，逐步建立编程知识图谱。本书以Java语言为例，由基础概念入手，到背后实现原理与逻辑，再到应用实践，融会贯通。\n全书共六大部分，其要点如下：\n- 第一部分（第1～2章）讲解计算机程序的基本执行流程与元素，以及数据背后的二进制表示，帮读者掌握编程的基本概念。\n- 第二部分（第3～7章）讲解面向对象的编程原理与逻辑，涉及类、继承与多态、接口与抽象类、异常与常用基础类，让读者透彻了解Java的重要基础——面向对象。\n- 第三部分（第8～12章）介绍泛型与容器及其数据结构和算法，涵盖泛型、列表和队列、各种Map和Set、堆与优先级队列等。\n- 第四部分（第13～14章）介绍文件处理。涵盖文件的基本概念、二进制文件和字节流、文本文件和字符流、文件和目录操作，以及文件处理的一些高级技术，包括常见文件类型的处理、随机读写文件、内存映射文件、标准序列化机制，以及Jackson序列化。\n- 第五部分（第15～20章）介绍并发，包括线程的传统基础知识和Java并发包。传统基础知识包括线程的基本概念与基本的同步、协作和中断机制；Java并发包涵盖原子变量、显式锁、显式条件、并发容器、异步任务执行服务、同步和协作工具类。\n- 第六部分（第21～26章）介绍动态和声明式编程编程思路、API与技巧，涵盖反射、注解、动态代理、类加载机制、正则表达式、Java 8引入的函数式编程等。\n### 3. 本书特色\n&emsp;&emsp;简单来说，其他书大多教你怎么用，而这本书帮助你透彻理解，从基本概念到高层框架，剖析实现原理与JDK源代码，融合专业理论与应用实践，使你透彻理解Java编程的实现原理和思维逻辑，融会贯通。具体来说：\n1. 对于每个编程概念，不仅介绍了语法和用法，还分析了为什么要有这个概念，实现原理是什么，背后的思维逻辑是什么；\n2. 对于Java的主要API（如Java基础类、各种容器类、文件、并发包等），不仅介绍了用法、示例和应用，还剖析了大量JDK源代码，解释了其内部实现机制；\n3. 对于实践中常用的系统程序和框架，如键值数据库、消息队列、序列化框架、DI(依赖注入)容器、AOP(面向切面编程)框架、热部署、模板引擎等，本书利用基本API演示了其基本实现原理；\n4. 本书不仅注重实现原理，同样重视实用性，介绍了很多实践中常用的技术，包含了不少实际开发中积累的经验和教训，使读者可以少走一些弯路；\n5. 本书虽然是Java语言描述，但以更为通用的编程逻辑为主，融入了很多通用的编程相关知识，如二进制、编码、数据结构和算法、设计模式、操作系统、编程思维等；\n6. 本书高度注重表述，尽力站在读者的角度，循序渐进、简洁透彻、通俗易懂。\n### 4. 下载\n[PDF版本下载](https://pan.baidu.com/s/1spP2kUqJfmoBVATQ6HqwDg?pwd=igx8)'),
       (2, 2, '### 1. 作者简介\n&emsp;&emsp;刘汝佳，1982年12月生，高中毕业于重庆市外国语学校。2000年3月获得NOI2000全国青少年信息学奥林匹克竞赛一等奖第四名，进入国家集训队，并因此保送到清华大学计算机科学与技术系。大一时获2001年ACM/ICPC国际大学生程序设计竞赛亚洲-上海赛区冠军和2002年世界总决赛银牌（世界第四），2005年获学士学位，2008年获硕士学位。\n&emsp;&emsp;学生时代曾为中国计算机学会NOI科学委员会学生委员，担任IOI2002-2008中国国家队教练，并为NOI系列比赛命题十余道。现为NOI竞赛委员会委员，并在NOI 25周年时获得中国计算机学会颁发的“特别贡献奖”。\n&emsp;&emsp;2004年至今共为ACM/ICPC亚洲赛区命题二十余道，担任6次裁判和2次命题总监，并应邀参加IOI和ACM/ICPC相关国际研讨会，发表论文两篇。\n&emsp;&emsp;2004年初作为第一作者出版专著《算法艺术与信息学竞赛》，2009年出版译著《编程挑战》，2009年出版《算法竞赛入门经典》，2012年出版《算法竞赛入门经典——训练指南》。\n&emsp;&emsp;多年来在全国二十余个城市进行中学生竞赛培训工作，为北京、上海、吉隆坡等地的著名高校授课与宣讲，并多次与TopCoder、百度和网易有道等知名企业合作举办比赛，让更多的IT人才获得展示自我的平台。\n\n### 2. 内容简介\n<center>\n  <img src=\"/configImages/algorithm.jpg\" width=\"300\" height=\"410\"><img src=\"/configImages/algorithm2.jpg\" width=\"300\" height=\"410\">\n</center>\n\n&emsp;&emsp;《算法竞赛入门经典（第2版）》是一本算法竞赛的入门与提高教材，把C/C++语言、算法和解题有机地结合在一起，淡化理论，注重学习方法和实践技巧。全书内容分为12 章，包括程序设计入门、循环结构程序设计、数组和字符串、函数和递归、C++与STL入门、数据结构基础、暴力求解法、高效算法设计、动态规划初步、数学概念与方法、图论模型与算法、高级专题等内容，覆盖了算法竞赛入门和提高所需的主要知识点，并含有大量例题和习题。书中的代码规范、简洁、易懂，不仅能帮助读者理解算法原理，还能教会读者很多实用的编程技巧；书中包含的各种开发、测试和调试技巧也是传统的语言、算法类书籍中难以见到的。\n&emsp;&emsp;《算法竞赛入门经典（第2版）》可作为全国青少年信息学奥林匹克联赛（NOIP）复赛教材、全国青少年信息学奥林匹克竞赛（NOI）和ACM国际大学生程序设计竞赛（ACM/ICPC）的训练资料，也可作为IT工程师与科研人员的参考用书。\n\n### 3. 本书优势\n1. **系统性**：这些书籍通常会从基础概念开始，逐步引导读者深入到更复杂的算法和数据结构。\n2. **实用性**：它们通常包含大量的实际编程问题和解决方案，帮助读者理解算法在实际应用中的作用。\n3. **可读性**：好的入门书籍会用清晰、简洁的语言来解释复杂的概念，使得初学者也能够理解。\n4. **示例丰富**：通过大量的代码示例和练习题，读者可以更好地理解和掌握算法。\n5. **逐步引导**：书籍会按照难度递增的顺序组织内容，帮助读者逐步建立信心和技能。\n6. **理论联系实际**：除了理论讲解，这些书籍还会强调算法在实际编程竞赛中的应用，帮助读者将理论知识转化为实战能力。\n7. **社区支持**：一些经典书籍通常有活跃的读者社区，读者可以在社区中讨论问题、分享经验，获得额外的学习资源。\n8. **更新及时**：随着算法竞赛的发展，一些书籍会定期更新，以包含最新的算法和编程技巧。\n9. **作者权威**：这些书籍通常由在算法竞赛领域有丰富经验的专家编写，保证了内容的权威性和准确性。\n10. **适合自学**：即使是没有老师指导的情况下，读者也可以通过这些书籍自学，逐步提高自己的算法设计和编程能力。\n### 4. 下载\n[PDF版本下载](https://pan.baidu.com/s/1eN2tkY12PtsmfkuclDZ1dQ?pwd=fpw2)'),
       (3, 3, '### 1. Git在各平台的安装\n##### 1.1 安装 Git\n1. Windows 到官网下载 exe 文件，一路 next 安装。\n2. MAC 目前是系统预设的。\n\n\n\n##### 1.2 初始化 Git 环境\n1. 任意一个目录下打开 Git Bash\n2. 配置用户名和邮箱\n   - `git config --global user.name \"CharlesLu\"` \n   - `git config --global user.email \"2814795346@qq.com\"` \n3. 生成 ssh 公钥\n   - 查看 `C:\\Users\\用户名\\.ssh`这个目录是否存在，如果存在说明已经配置好了，否则往后看\n   - 输入`ssh-keygen -t rsa -C \"2814795346@qq.com\"` 生成公钥，后面是一直回车。\n   - MAC 先打开 `~` 目录下，然后使用上面的命令创建公钥文件。依旧，输入后一直回车。文件默认存储在 `~/.ssh/id_rsa.pub`；使用 `pbcopy < ~/.ssh/id_rsa.pub` 可以直接复制公钥。\n\n\n\n### 2. 创建版本库\n##### 2.1 前提知识\n初始 Git 会默认创建一个 master 分支，并将 HEAD 指向该分支。\n\nGit 中的文件分为三种状态：本地修改（修改或创建文件）、暂存区修改（使用 add 指令添加）、提交到分支（使用 commit 指令）。\n\n\n\n##### 2.2 初始化 `git init` \n用来初始化一个 Git 空间，即以当前目录创建一个 Git 仓库。注意：如果当前目录中已经有文件存在了，使用 `init` 指令并不会默认将里面的文件添加到仓库或暂存区，仍然需要手动 `add` 。\n\n\n\n##### 2.3 添加文件到版本控制 `git add filename.txt` \n将修改的内容添加到暂存区，后面可以指定多个文件名，使用空格分隔。注意点：\n\n+ add 目录时，目录里面的所有文件或子目录都会同时被纳入进去。\n+ 不论是新建的文件还是修改后的文件，都需要先 `add` 到暂存区里。之后才可以进行 `commit` 。\n\n场景：\n1. 修改了某个文件（修改1）\n2. 使用add添加到暂存区\n3. 再次修改这个文件（修改2）\n4. 使用 commit 提交修改。\n   \n此时使用 `git status` 查看结果发现：修改1成功提交，修改2没有提交并且没有添加到暂存区。\n\n结论：Git 的提交面向每一次修改，而不是面向某个文件。所以每次 add 后的修改都要重新 add 一次进入暂存区。\n\n\n\n##### 2.4 提交当前修改 `git commit -m \"提交的描述\"` \n将暂存区的内容提交到仓库中。记得在使用 `commit` 指令之前先使用 `add` 指令将修改的内容添加到暂存区。\n\n\n\n##### 2.5 查看当前修改内容 `git status` \n使用 `status` 指令能够看到当前仓库的状态：哪些修改未纳入暂存区，哪些修改已经在暂存区里了。\n\n\n\n### 3. 版本控制\n##### 3.1 对比修改 `git diff [filePath]` \n使用 `diff` 指令对比<font style=\"color:#F5222D;\">工作区</font>文件修改前后的变化。注意：\n\n+ 若 `diff` 后面没有参数，则会对比所有修改过的工作区文件，暂存区的文件不会参与对比。\n+ 可以在 `diff` 后面添加要对比的文件路径（仓库内部的相对路径）用来指定要对比的文件（工作区）。\n+ 想要对比暂存区的文件修改，使用 `git diff branchName` 来对比。相当于将内容与仓库里面的内容对比，所以暂存区的文件也会参与对比。\n\n\n\n##### 3.2 查看提交记录 `git log [--pretty=oneline][--graph]` \nGit 会记住你的每一次提交，使用 `log` 指令就可以看到，主要输出包括 commit id、提交人、提交日期、提交描述。额外的，在 `log` 后添加参数 `--pretty=oneline` 就可以设置每次提交记录在一行显示完成，主要输出包括 commit id、提交描述。参数 `--graph` 可以展示当前的合并路径。\n\n\n\n##### 3.3 版本回退 `git reset --hard HEAD^` \n将当前版本回退到某一个版本。使用 `HEAD` 表示当前版本，使用 `HEAD^` 表示当前版本的前一版，以此类推 `HEAD^^` 等含义。若是往前回退100个版本，都用 `^` 显然不现实，此时可以简写成 `HEAD~100` 。注意点：\n\n+ 回退以版本为单位。例如我在当前版本做了修改但未提交，此时使用 `git reset --hard HEAD^` 指令表示回退到当前版本的前一个版本。所以回退是不管你当前有没有做出修改的，它只关注你当前的版本和要去的版本。\n\n\n\n如果我想回退到某一个具体的版本怎么做？此时可以使用 `git reset --hard e5f30dbef` 指令，里面的 e5f30dbef 是某一个提交的 `commit id` ，有趣的是：这个 commit id 不需要写全，只需要取前几位系统就会自己找到对应的提交记录。所以，如果之前回退过一次，现在我又想再次退回去，这就不是往前退了，使用 HEAD 就不合适，此时就可以使用 commit id 来操作。注意点：\n\n+ 假设当前我有a，b，c这3个提交，且我当前的 HEAD 就是指向 c 的。此时往回退一次到 b，再使用 `log` 就会发现没有 c 这条记录了。如果在同一个console里面还能找到 c 的 commit id，那可以直接指定版本回退。\n\n\n\n已经在本地做了部分修改，此时使用回退功能。则：\n\n+ 新建的且已经 add 过了，则会被删除掉。\n+ 新建但是没有 add 过，则不受影响。因为这个文件根本不受 Git 管控。\n+ 修改的文件，不管有没有add，都会被回退。\n\n回退后，我又想再退回原来的版本。则：\n\n+ 所有内容与之前提交到仓库的一致。也就是说自己没有 commit 的修改仍然是消失掉了。\n+ 不受管控的文件（新建但是没有add的文件）不受影响。\n\n\n\n**总结：做版本回退操作时，不论是前进还是回退都以要去的那个版本提交为主。也就是说没 commit 的修改会被直接 rollback 掉，找不回来了。唯独新建且未 add 的文件不受影响，因为这部分文件不受 Git 管控。**\n\n\n\n##### 3.4 历史命令展示 `git reflog` \n展示Git仓库的历史事件。场景：本来提交 A->B->C，使用reset之后变为 A->B。若此时我想回到 C，但是又不知道 C 的 commit id，那么使用 `reflog` 来查看历史寻找 commit id。如果这里面也找不到那就算了。\n\n\n\n##### 3.5 撤销修改\n+ 场景1（回退工作区的修改）：你基于当前分支做出了修改，但是没有 add 到暂存区。此时发现你做的不好，想要将当前文件的修改撤销，怎么做？\n    - 方式1：手动删除所有的修改点。\n        * 缺点：若修改点较多则有可能出现删除不全等现象。\n        * 优点：能够选择性的撤销而不是一股脑的都回退掉。\n    - 方式2：使用指令 `git checkout -- filename.txt` 来回退，后面的文件名可以写多个，用空格分隔。\n        * 缺点：一旦回退就是完全回退，不会保留任何修改。只针对工作区，暂存区不会受到影响。\n        * 优点：能够将修改完全还原成最近提交的状态。不会有遗漏的情况。\n    - 对于方式2，有两种情况：\n        * 1. 当前文件修改但是没有 `add` ，此时使用 `checkout` 回退是回退到分支上的版本。\n        * 2. 当前文件修改且也 `add` 了，此时使用 `checkout` 回退是回退到 `add` 时的版本。\n        * 总结：使用 `checkout` 回退当前文件会回退到最近一次 `add` 或 `commit` 的版本。\n+ 场景2（回退暂存区的修改）：你基于当前分支做出了修改，也添加到暂存区了。此时想要撤销所有的修改，怎么做？\n    - **步骤 1**. 使用 `git reset HEAD [filename.txt]` 指令将这个修改从暂存区取回工作区；此处如果省略文件名，则会将暂存区所有内容返回到工作区。\n    - **步骤 2**. 使用 `git checkout -- filename.txt` 指令将工作区的修改回退掉。\n    - 以上两步可以直接使用 `git reset --hard HEAD`来回退，这样回退会将暂存区和工作区所有修改回退\n\n\n\n##### 3.6 文件删除\n现在你在文件管理器删除了一个文件，但是这个文件没有加入 Git 管控（新建的文件但是没有add），那么这个文件就找不回来了。若是这个文件已经加入 Git 管控，那么面临着两种选择：\n\n+ 这个文件确实需要从仓库删除\n    - 第一步，使用 `git rm filename.txt` 来将删除这个操作放到暂存区。\n    - 第二步，使用 `git commit -m \"提交描述\"` 将暂存区的内容刷新到分支上。\n+ 这个文件删错了，需要搞回来\n    - 如果删除这个操作只是在工作区做的，可以使用 `git checkout -- filename.txt` 来回退\n        * 这个指令我们之前用来回退当前的修改，这边还可以用来还原工作区删除的文件\n    - 如果本地删除完后，又执行了 `git rm filename.txt` 指令。相当于将删除这个操作存到了暂存区，此时直接使用 `checkout` 是无法找回文件的。此时需要：\n        * **步骤 1. **`git reset HEAD [filename.txt]` 将删除这个操作从暂存区转到工作区\n        * **步骤 2.** `git checkout -- filename.txt` 将删除这个操作撤销\n\n##### 3.7 放弃追踪\n对已经纳入版本管控的文件放弃追踪，应该怎么做？\n\n```bash\n# 放弃追踪某文件\ngit update-index --assume-unchanged filename.txt\n\n# 恢复追踪某文件\ngit update-index --no-assume-unchanged filename.txt\n\n# 查看所有放弃追踪的文件\ngit ls-files -v | grep -e \"^[hsmrck]\"\n```\n\n对于没有接受 Git 管控的文件，想要放弃最终直接写进`.gitignore`里面。\n\n### 4. 远程仓库 GitHub\n##### 4.1 将本机的 SSH Key 添加到 GitHub 上\n传送门：[https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416](https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416)\n\n给本地 git 设置全局代理：`git config --global http.proxy http://127.0.0.1:7890`\n\n取消设置的全局代理：`git config --global --unset http.proxy`\n\n\n\n给 github 设置代理： `git config --global http.https://github.com.proxy http://127.0.0.1:7890`\n\n去除 github 设置的代理：`git config --global --unset http.[https://github.com.proxy](https://github.com.proxy)`\n\n\n\n##### 4.2 添加远程仓库\n1. 在 GitHub 上点击 “Create repository” 创建仓库\n2. 根据 GitHub 的提示，到我们本机的工作区执行命令 `git remote add origin https://github.com/bigExplor/gitTest.git` 用来关联本地仓库与远程的仓库。注意：这一步不会将文件上传到远程。\n   - 关联之后，远程仓库的名字默认叫 `origin` \n3. 设置本人token\n   - 按照下图到 Github 生成 token\n   - 到终端使用 `git remote set-url origin https://<token>@github.com/<username>/<仓库名>.git`命令设置 token\n   - ![](/upload/covers/0b18e52beb3841b0a7cf0f90f92de223.png)\n\n4. 将本地库所有内容推到远程。使用命令： `git push -u origin master` \n   - 命令表示将本地 master 分支的内容推到远程仓库 origin。\n   - 因为远程库是空的，所以第一次推送时添加了 `-u` 参数。这样 Git 不但会将本地内容推到远程，还会将本地的 master 分支与远程的 master 分支关联起来。\n   - 此时你会发现 GitHub 上的内容和你本地的内容已经一模一样了。后面在本地再做修改时，可以直接使用 `git push origin master` 来推送到远程。\n   - 过程中若出现报错：fatal: refusing to merge unrelated histories，可以使用下面的方式解决\n       - `git pull origin master --allow-unrelated-histories` \n   - **注意**：推送只会将本地仓库里面的内容推上去，暂存区或工作区的内容是不会推上去的。\n\n上面的第4步出现问题，可以尝试执行`git branch -M main`，目前我是可以成功的。\n\n\n\n##### 4.3 深入解析 push\n+ 远程没有dev分支，本地有并且使用 `git push origin dev` 往上推。则会在远程新创一个 dev 分支，并将本地的dev与之关联。后面push的时候只会推修改点上去。\n+ 远程已经有dev分支了，另一个本地git仓库下使用 `git push origin dev` 会报错。因为远程的dev别人已经推上去了，你不能再推。想要公用一个远程分支，需要先将远程的分支与你本地的分支连接起来。\n+ 连接本地一个分支与远程的分支： `git branch --set-upstream-to=origin/dev dev` ，即使连接了本地与远程的分支，也不能使用 push，需要先使用 pull\n+ `git pull` 会将远程的代码拉下来。此时可能有冲突，需要先解决冲突，然后commit。接下来就可以正常使用 push 了\n+ 如果在 push 时远程的文件已经被别人修改过，那么本次 push 必然是失败的。需要先 pull，解决冲突，提交修改，最后才能push成功。\n\n\n\n##### 4.4 与远程仓库断开连接\n1. 因为这个操作比较危险，建议断开之前先看一下远程仓库的信息： `git remote -v` \n2. 确认后再根据仓库名再进行断开操作： `git remote rm origin` \n3. **注意**：断开连接并不会删除远程仓库，想要删除只能自己登录 GitHub 网站找到删除按钮。\n4. 断开连接后，本地的仓库与远程的仓库就没有关系了。再往上推送就会失败了，想要再连接回来需要再次执行 4.2 的内容。\n\n\n\n##### 4.5 从远程库克隆 `git clone 远程项目地址[自定义目录名称]` \n使用 `clone` 命令拷贝项目的时候，会默认在本地创建一个与远程项目同名的文件夹。这就不需要自己去创建了。\n\n很多时候我们从 0 开始一个项目的时候，常规做法就是：先在 GitHub 上创建一个项目，并在初始化的时候让其创建默认分支。后面我们就可以直接使用 `clone` 命令来直接将项目拷贝到本地。操作如下图：\n<center>\n\n  ![](/upload/covers/cd5d30202a3c427f8fda71833657f6ff.png)\n</center>\n\n\n\n### 5. 分支管理\n传送门：[https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424](https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424)\n\n\n\n##### 5.1 分支的创建与合并（不同分支公用工作区和暂存区）\n1. 查看当前分支信息 `git branch` \n   - 使用这个命令后列出的所有分支中，前面带 * 号的分支表示当前分支。\n2. 创建新分支 `git branch branchName`\n   - 基于当前的分支创建新分支，内容与当前分支仓库里面的内容完全一致。\n3. 切换到某一分支 `git checkout branchName` \n   - 在新版本的 Git 中，可以使用 `git switch branchName` 来切换分支。\n4. 创建并切换分支 `git checkout -b branchName [基于的分支名，省略则基于当前分支]` ，相当于步骤2与步骤3的结合。\n   - 在新版本的 Git 中，可以使用 `git switch -c branchName [基于的分支名，省略则基于当前分支]` 来创建并切换分支。 \n5. 将指定分支合并到当前分支 `git merge branchName` \n   - 如果没有冲突，使用 `merge` 默认使用快速合并。因为快速合并是线性的，看不出这边有合并。\n   - 一般都会禁掉快速合并： `git merge --no-ff -m \"合并描述\" branchName`\n     - `--no-ff` 表示禁用快速合并\n     - 因为不使用快速合并，系统会默认做一次 commit。这边的 `-m \"描述\"` 就是用来做提交描述的。可以理解为合并描述。\n6. 删除指定的分支 `git branch -d branchName` 。如果该分支有未合并的提交，这样删除会失败，若要执意删除，可以将 -d 换成 -D。后面可以用空格隔开多个分支名用来删除多个分支。\n7. **注意点**：切换分支的操作包括： `checkout` `checkout -b` `switch` `switch -c` 。因为不同分支公用工作区和暂存区的原因，切换时凡是没有 `commit` 的修改都会被带到新分支去。这可能造成文件混乱，解决方案：\n    1. 在原分支将修改点回退掉\n    2. 在原分支将修改都 `commit` \n    3. 在原分支使用 `stash` \n8. 假设现在有两个分支：A，B。现在我在 A 分支上，我并不想合并两个分支，但是 B 分支上有一个提交是我所需要的。此时我们就可以使用 `git cherry-pick commitId` 来操作。这个命令可以将指定id的提交取到本分支。\n    1. 进行操作前得保证当前没有未提交的修改。否则会报错。\n    2. 这可能导致冲突，该解冲突就要解决冲突。\n    3. 使用这个命令系统会在当前分支自动进行一次提交。\n\n\n\n##### 5.2 状态保存 `git stash` \n1. 保存当前状态 `git stash [save \"保存描述\"]` \n    1. 若后面加上 `save \"描述\"` 则会在保存时添加一些描述。后面恢复时也能够快速定位对应的 stash。\n2. 展示当前的状态列表 `git stash list` \n3. 展示某一个状态的信息 `git stash show [-p] [stash@{n}]` \n    1. 加上 `-p` 表示展示的彻底一点，哪些文件、哪些地方有修改，都修改了什么，都会展示出来。展示的内容类似于 `git diff` \n    2. 加上 `stash@{n}` 表示要显示哪一个状态。具体n的范围，可以通过 `git stash list` 来查看。\n    3. 如果不加 `stash@{n}` 默认查看第0个状态。存储状态的数据结构是头插列表，来一个状态直接插入到头部。也就是说0必然对应着最新的修改。\n4. 恢复某一个状态，<font style=\"color:#F5222D;\">但不删除</font>列表里的stash。 `git stash apply [stash@{n}]` \n    1. 使用 `apply` 不会删除列表里的状态。想要删除只能自己手动删除。\n    2. 添加 `stash@{n}` 用于指定要恢复的状态。如果不写，默认恢复第0个。\n5. 恢复某一个状态，同时<font style=\"color:#F5222D;\">删除</font>对应的状态。 `git stash pop [stash@{n}]` \n6. 删除列表里的某一个状态。 `git stash drop [stash@{n}]` \n7. 清空列表里的所有状态。 `git stash clear` \n8. **<font style=\"color:#F5222D;\">注意点：</font>**\n   - 使用stash就是将所有没有 commit 的修改存起来，将当前分支恢复到与仓库一致的地步。\n   - 保存状态的列表是全分支可见的，也就是说可以在A分支保存状态（用来还原A分支），在B分支恢复这个状态（用来找回自己的修改）。\n   - stash 只会存储受 Git 管控的文件，对于新创建但没有进行过 add 操作的文件是不参与 stash 的。\n\n\n\n##### 5.3 冲突的合并\n场景：A分支修改了某个文件并提交了；B分支也修改了同一个文件并提交了；此时合并两个分支就会有冲突发生，使用 `git status` 可以看到哪些文件冲突。Git 使用 \"<<<<<<HEAD\" \">>>>>>branchName\"来表示冲突。解决完冲突，然后再 `git add` `git commit` 就算解决完冲突了。\n\n注意：如果A分支修改了某个文件并提交了；当前在B分支也在同一个文件做了修改，但是没有 commit，此时使用 merge 会报错，拒绝合并（不论修改在工作区还是暂存区）。\n\n\n\n##### 5.4 分支创建策略\n1. 一般 `master` 分支作为稳定分支，不会直接再上面做修改。 \n2. `dev` 作为开发分支，这是一个不稳定的分支。上面融合了每一个开发者的代码。\n3. 每个开发者都会基于 `dev` 再创建自己的分支，然后合并修改到 `dev` 分支上。\n4. 当 `dev` 分支趋于稳定时，再将 `dev` 分支合并到 `master` 分支。 \n\n\n\n\n\n> 小技巧：Android Studio配置terminal为Git\n>\n> + Settings -> Tools -> Terminal\n> + 将 Shell Path 替换为 \"C:\\Program Files\\Git\\bin\\sh.exe\" --login -i\n>\n\n\n\n### 6. git 的忽略文件\n对于有些文件不想让 `git` 管控，那么我们可以创建 `.gitignore`文件，并在文件里配置哪些文件不需要 `git` 管控。注意了，一个 `.gitignore`文件只能影响**<font style=\"color:#E8323C;\">当前及子目录</font>**的所有文件，那些在 `.gitignore`父层级的文件不会被影响到。所以想要全局管理，那就在项目的根目录下创建忽略文件。\n\n```python\n# 和 Python 很像，“#” 开头表示注释。\n\n# 这表示忽略当前及所有子目录下名字叫 a.txt 的文件。\na.txt\n\n# 这表示只忽略根目录下的 a.txt 文件，对于子目录下同名文件不受影响。\n/a.txt\n\n# * 匹配任意多字符，包括 0 个。下面表示忽略所有 txt 文件\n*.txt\n\n# 解除忽略使用 “!”。\n# 这往往配合范围忽略，上面已经忽略了所有 txt 文件。再加上下面的一句，表示 im.txt 不用忽略。\n!im.txt\n\n# 和正则很像啊，可以使用 “[]” 来指定多种情况。\n# 下面表示忽略所有 a.xml 和 b.xml\n[ab].xml\n\n# “[]” 里面可以用 “-” 表示范围。\n# 例如下面表示忽略所有 a.xml、b.xml、...、z.xml\n[a-z].xml\n\n# 文件名后面加 “/” 表示忽略的是目录。下面表示忽略所有 a 目录。包括子目录下 a 目录。\na/\n```\n\n\n\n### 7. github 高级搜索\n| **指令** | **解释** | **案例** |\n| --- | --- | --- |\n| in:name | 仓库名里包含某关键字的 | 爬虫 in:name |\n| in:readme | readme 文件包含某关键字的 | 爬虫 in:readme |\n| in:description | 详细描述里包含某关键字的 | 爬虫 in:description |\n| language:xxx | 限定开发语言 | language:python |\n| stars:>n | 星星数大于某个值的 | stars:>1000 |\n| stars:m..n | 星星数在 m 和 n 之间的，下面的 fork 和 pushed 都可以这么玩 | stars:1000..10000 |\n| forks:>n | fork 数大于某个值的 | forks:>1000 |\n| pushed:>YYYY-MM-DD | 更新日期晚于某个日期的 | pushed:>2022-01-01 |\n\n\n\n\n\n\n\n\n\n'),
       (4, 4, '### 1. 简单入门\n##### 1.1 完全匹配\n精确匹配，所有字符完全相同才算匹配。例如一个正则表达式 `at`，它表示的规则是：一个串以字母 `a` 开头，紧跟着的是字母 `t`。\n\n看下方匹配 `at` 的案例：\n\n> There is a c**at** s**at** on the m**at**.\n>\n\n##### 1.2 特殊字符匹配 `\\` \n在正则里面有许多的特殊字符，要想表示这些字符需要在前面加 `\\` 。例如：\n\n+ 控制字符： ` ` 表示空格， `\\t` 表示制表符， `\\n` 表示换行符......\n+ 正则里面的特殊字符： `\\{` `\\}` `\\[` `\\]` `\\/` `\\\\` `\\+` `\\*` `\\.` `\\$` `\\^` `\\|` `\\?`\n\n\n\n### 2. 元字符\n##### 2.1 元字符对照表\n正则表达式主要依赖于元字符。元字符并不表示它们字面的意思，它们都有特殊的含义。\n\n| **元字符** | **含义** |\n| :---: | --- |\n| . | 匹配除换行符外的任意字符 |\n| [] | 表示匹配范围。匹配方括号里面的任意字符 |\n| [^] | 方括号含义取反。匹配不包含在方括号里面的字符 |\n| * | 匹配 `>= 0` 次 * 号之前的单个字符或字符集 |\n| + | 匹配 `>= 1`次 + 号之前的单个字符或字符集 |\n| ? | 匹配 0 或 1 次 ? 号之前的单个字符或字符集 |\n| {m,n} | 匹配 x 次大括号之前的单个字符或字符集（m <= x <= n） |\n| (xyz) | 字符集。将 `xyz` 当成一个整体 |\n| | | 或运算符。匹配符号前或后的单个字符或字符集 |\n| \\ | 转义字符。使用转义字符来表示元字符原本的意思 |\n| ^ | 从开始行开始匹配 |\n| $ | 从末端开始匹配 |\n\n\n##### 2.2 点运算符 `.` \n`.` 匹配除换行外的所有字符。看如下匹配 `.ar` 案例：\n\n分析：第一个 `ar` 前面有一个空格满足匹配要求；第二个 `ar` 前面有一个字符 `c` 满足匹配要求；最后一个 `are` 前面是换行符，不满足匹配要求，所以不能进行匹配。\n\n> Here **ar**e many c**ar**s.\n>\n> are\n>\n\n##### 2.3 范围字符 `[]` \n`[]` 表示匹配范围。即匹配方括号里的所有字符，其中：\n\n+ `-` 表示范围，例如： `0-9` 表示所有数字\n+ `.` 就表示字面意思：点。即在 `[]` 中 `.` 与 `\\.` 完全相同\n\n看如下匹配 `[A-Z0-9.]` 案例：\n\n解析：这个案例匹配所有大写字母、所有数字、  `.` 字符。\n\n> You need to give me 1$.\n>\n\n##### 2.4 对范围的取反 `[^]` \n匹配除方括号里的所有字符。例如： `[^a]` 匹配除了字符 `a` 以外的所有字符，包括换行、tab等特殊字符。\n\n案例： `[^c]ar` 能够匹配 `par`、 `lar` 等字符串但不能匹配 `car` 。\n\n##### 2.5 重复匹配\n字符后跟着 `?` 、 `+` 、 `*` 元字符的表示重复匹配。不同元字符表示不同含义。\n\n###### 2.5.1 `*` 号\n表示 `*` 号前面的字符或字符集出现0或更多次。例如： \n\n+ `a*` 表示任意次字母 `a` 的重复，包括空串（0次重复）。\n+ `(abc)*` 表示任意次 `abc` 的重复，包括空串（0次重复）。\n\n注意点：\n\n+ 默认贪婪。例如：已知字符串 #@##，使用 `#@#*` 来匹配会匹配整个串，而不是 `#@#`。\n+ TODO `abc abc` 里面有多少个空串\n\n###### 2.5.2 `+` 号\n表示 `+` 号前面的字符或字符集出现1或更多次。例如：\n\n+ `a+` 表示至少一次字母 `a` 的重复。\n+ `(abc)+` 表示至少一次 `abc` 的重复。\n\n注意点：\n\n+ 默认贪婪。例如：已知字符串 #@##，使用 `#@#+` 来匹配会匹配整个串，而不是 `#@#`。\n+ 因为需要至少一次，所以空串就不会进行匹配了。\n\n###### 2.5.3 `?` 号\n1. 表示 `?` 前面的字符或字符集出现0或1次。例如：\n    - `t?he` 可以匹配 `the`，也可以匹配 `he` \n2. 可以取消默认的贪婪匹配。例如：\n    - 字符串：#@##，正则： `#@#*?` 会匹配 `#@` 。因为不用贪婪策略怎么短就怎么来，直接重复0次。\n    - 字符串：#@##，正则： `#@#+?` 会匹配 `#@#` 。因为不用贪婪策略怎么短就怎么来，直接重复1次。\n\n###### 2.5.4 `{}` 号\n限制指定字符或字符集重复的次数。例如：\n\n+ `a{n}` 表示字符 a 正好重复 n 次\n+ `a{m,n}` 表示字符 a 重复 m 到 n 次，包含 m 和 n\n+ `a{m,}` 表示字符 a 至少重复 m 次，包含 m 次\n\n##### 2.6 字符集 `()` \n表示分组，使用 `()` 能够将多个字符看成一个整体。例如：\n\n+ `(abc)+` 表示将字符串 `abc` 重复 1 到多次，而不是仅对字符 `c` 进行重复。\n+ 在 `()` 中使用 `|` 运算符实现部分“或”的功能。如： `(t|T)he` 可以匹配 `the` ，也可以匹配 `The` \n+ 注意：在 `()` 中的 `.` 表示元字符，匹配任意非换行字符。而不是像 `[]` 中表示字面义。\n\n##### 2.7 或运算符 `|` \n表示逻辑或的关系。注意点： `|` 以字符串来表示并列的元素而不是字符。例如：\n\n`zhangsan|lisi|wangwu` 表示： `zhangsan` 或 `lisi` 或 `wangwu` \n\n##### 2.8 `^` 号\n用来检查匹配的字符串是否在串的开头。例如：\n\n对于字符串 \"the cat sat on the mat\"， `^the` 只能够匹配开头的 \"the\"，对于句中的 \"the\"则不能匹配。\n\n`^` 用来判断该串是否以某一串开头，第2行串的开头也不算开头\n\n##### 2.9 `$` 号\n用来检查匹配的字符串是否在串的结尾。例如：\n\n对于字符串 \"the cat sat on the mat\"， `at$` 只能够匹配结尾的 \"at\"，对于句中的 \"at\"则不能匹配。\n\n`$` 用来判断该串是否以某一串结尾，非最后一行串的结尾也不算结尾\n\n##### \n### 3. 简写字符集\n正则表达式提供了一些常用字符集的简写。包括：\n\n| **简写** | **描述** |\n| :---: | --- |\n| . | 匹配除换行外的所有字符 |\n| \\w | 匹配所有字母、数字、下划线。等价于 `[a-zA-Z0-9_]`  |\n| \\W | 对 `\\w` 取反。等价于 `[^\\w]`  |\n| \\d | 匹配所有数字。等价于 `[0-9]`  |\n| \\D | 匹配所有非数字。等价于 `[^\\d]`  |\n| \\s | 匹配所有空白字符。等价于 `[\\t\\n\\f\\r\\p ]` ，注意里面有一个空格 |\n| \\S | 匹配所有非空白字符。等价于 `[^\\s]`  |\n| \\f | 匹配换页符 |\n| \\n | 匹配换行符 |\n| \\r | 匹配回车符 |\n| \\t | 匹配制表符 |\n| \\v | 匹配垂直制表符 |\n| \\p | 等同于 `\\r\\n` ，用来匹配 DOS 行终止符 |\n| \\b | 匹配字与单词的边界。如 `\\bword\\b` 能够匹配单独的单词 `word` ，<br/>但是不能匹配 `aword`  |\n| \\B | 匹配非字与单词的边界。等价于 `[^\\b]`  |\n\n\n\n\n### 4. 零宽度断言\n##### 4.1 定义\n判断匹配的格式是否满足某种约束，且断言部分不作为匹配字符串。\n\n| **符号** | **描述** |\n| :---: | --- |\n| ?= | 正先行断言-存在 |\n| ?! | 负先行断言-排除 |\n| ?<= | 正后发断言-存在 |\n| ?<! | 负后发断言-排除 |\n\n\n##### 4.2 正先行断言 `?=` \n某一匹配格式在先，后面跟着某种约束。\n\n需求：从字符串中匹配 `there` 中的 `the` 。\n\n尝试：如果正则为 `the` ，则不能满足找到的是 `there` 中的 `the` 。若正则为 `there` ，但需求中要找的是 `the`，并不是 `there` 。\n\n分析：经观察可以得出，需要匹配的字符串需要满足条件：1. 包含字符串 `the`  2. `the` 后面紧跟着字符串 `re` 。使用正先行断言。\n\n解答：正则： `the(?=re)` ，可以看到正则里面先匹配 `the` ，但是这个 `the` 后面必须跟着 `re` 。以此满足需求。\n\n注意：断言里面可以使用元字符，例如上面可以改成 `the(?=[a-z]e)` \n\n##### 4.3 负先行断言 `?!` \n这个和 `正先行断言` 相反。 `正先行断言` 需要匹配的字符串后面跟着某一格式的串， `负先行断言` 则需要匹配的字符串后面不能包含某一格式的串。\n\n例如：对于字符串 `there` ，使用正则 `the[?!re]` 就无法匹配。因为指定串后面有 `re` ，但是 `负先行断言` 指定后面不能跟 `re` 。\n\n##### 4.4 正后发断言 `?<=` \n和先行断言相似，但断言是放在匹配串的前面的。\n\n例如：对于字符串 `there` ，使用正则 `(?<=[t|T]h)ere` 就可以匹配到 `there` 里的 `ere` \n\n##### 4.5 负后发断言 `?<!` \n和正后发断言相似，但是前面不能有指定的断言。\n\n例如：对于字符串 `there` ，使用正则 `(?<![t|T]h)ere` 就不能匹配到，因为指定前面不能有 `th` 或 `Th` ，但是字符串里面却有。\n\n\n\n### 5. 标志\n标志也叫模式修正符，这些标志可以任意的组合使用。\n\n| 标志 | 描述 |\n| --- | --- |\n| i | 匹配时忽略大小写 |\n| g | 全局搜索，不加只会返回第一个匹配的串。 |\n| m | 多行修饰符：将 `^` 和 `$` 的工作范围更改为每行的起始。 |\n\n\n\n\n'),
       (5, 5, '### 1. 概念\nDocker 是一个开源的应用容器引擎，基于 Go 语言并遵从 Apache2.0 协议开源。\n\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。\n\n### 2. 安装\n#### 2.1 Mac & Windows\n直接去[官网](https://www.docker.com/get-started/)下载安装包安装即可。\n\n安装完成之后在控制台使用`docker -v`查看是否安装完成。\n\n#### 2.2 配置镜像\n我们下面以阿里云镜像为例：\n\n1. 登录阿里云\n2. 点击右上角控制台\n3. 点击左上角汉堡按钮并搜索“镜像”\n4. 选择“容器镜像服务”->“镜像工具”->“镜像加速器”\n5. 根据文档配置镜像。我这边就是在APP的`Docker Engine`里面输入：\n\n```json\n{\n  \"builder\": {\n    \"gc\": {\n      \"defaultKeepStorage\": \"20GB\",\n      \"enabled\": true\n    }\n  },\n  \"experimental\": false,\n  \"registry-mirrors\": [\"https://zstsmy48.mirror.aliyuncs.com\"]\n}\n```\n\n#### 2.3 更换镜像下载地址\nWindows 下镜像默认下到 C 盘，因此我们需要更改镜像下载地址。\n\n1. 退出`Docker`软件；\n2. 运行`wsl --shutdown`；\n3. 创建两个目录`Z:\\Docker\\wsl\\distro`与`Z:\\Docker\\wsl\\data`，盘符自定；\n\n### 3. 命令\n#### 3.1 服务命令\n- 启动服务：`systemctl start docker`\n- 停止服务：`systemctl stop docker`\n- 重启服务：`systemctl restart docker`\n- 查看服务状态：`systemctl status docker`\n- 设置开机自启动：`systemctl enable docker`\n\n#### 3.2 镜像命令\n##### 3.2.1 查看镜像\n使用`docker images`命令查看本地安装的镜像，查询的结构如下：\n\n```plain\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\ntomcat       latest    b64abfdee99c   2 years ago   668MB\n```\n\n+ `REPOSITORY`镜像名称；\n+ `TAG`镜像版本；\n+ `IMAGE ID`镜像 id；\n+ `CREATED`镜像制作文件而不是安装到本地的时间；\n+ `SIZE`镜像大小；\n\n我们还可以使用`docker images -q`命令即加上`-q`参数来查询所有镜像的 id。\n\n##### 3.2.2 搜索镜像\n使用`docker search <镜像名>`来搜索相关镜像，例如执行`docker search redis`的结果如下：\n\n```plain\nNAME                                DESCRIPTION                                      STARS     OFFICIAL\nredis                               Redis is an open source key-value store that…   12829     [OK]\nredislabs/redisearch                Redis With the RedisSearch module pre-loaded…   64        \nredislabs/redisinsight              RedisInsight - The GUI for Redis                 102       \nredis/redis-stack-server            redis-stack-server installs a Redis server w…   76        \nredis/redis-stack                   redis-stack installs a Redis server with add…   106       \nredislabs/rebloom                   A probablistic datatypes module for Redis        27        \n```\n\n最后一个`OFFICIAL`表示该镜像是否是官方镜像。注意搜索镜像是联网查找，因此需要网络环境。\n\n##### 3.2.3 拉取镜像\n将网上的镜像拉取到本地可以使用`docker pull <镜像名:版本>`，如果不加版本号默认拉取版本号为`latest`的镜像即维护的最新镜像。\n\n例如`docker pull redis`就是拉取最新的 redis 镜像，如果我想拉取某一个版本的镜像但又不知道该版本是否存在于远程仓库里，可以到[官网](https://hub.docker.com/)搜索查看该镜像有哪些版本，以 reids 为例：\n\n![](/upload/covers/278c9a48f3024c308c4b81ff4d84ff07.png)\n\n##### 3.2.4 删除镜像\n删除本地安装的镜像有两种方式，一种通过镜像名与版本号，另一种通过 id：\n\n```shell\n# 按照镜像名与版本号删除镜像\ndocker rmi redis:latest\n\n# 按照 id 删除镜像，可以使用`docker images`命令查看某镜像的 id\ndocker rmi b64abfdee99c\n```\n\n如果想删除本地所有镜像，可以使用下面的命令：\n\n```shell\n# 先使用 docker images -q 查询所有镜像 id，并将其作为参数全部删除\ndocker rmi `docker images -q`\n```\n\n#### 3.3 容器命令\n容器可以理解成镜像的实例，一个镜像可以生成若干个容器。以后程序什么的都会运行在容器之中。\n\n##### 3.3.1 查看容器\n使用`docker ps`命令可以查看正在运行的容器，已经关闭的容器是看不到的。\n\n想要查看所有容器包括已经关闭的可以添加`-a`参数即使用`docker ps -a`命令。\n\n除此之外还有`-q`参数表示返回容器的 id，因此`docker ps -aq`表示查看所有容器的 id。\n\n##### 3.3.2 创建容器\n创建容器使用`docker run`命令，这个命令后面需要指定若干参数，分别有：\n\n+ `-i`创建完成后启动容器，通常配合`-t`参数使用。\n+ `-t`进入容器并为容器分配一个终端，通常配合`-i`参数实现：容器创建完成之后直接进入容器，容器退出后自动关闭容器。\n+ `-d`以守护模式创建容器，创建完成并不会自动进入容器，退出容器也不会关闭容器。\n+ `--name`为创建的容器命名。\n\n一般我们使用`-it`创建一个交互式容器，特点是：创建即进，退出则关；使用`-id`创建守护式容器，手动进入关闭。我们创建容器的一个示例：\n\n```shell\ndocker run -it --name=c1 centos:7 /bin/bash\n```\n\n下面我们详细解读一下这个例子：\n\n1. 使用`-it`指定创建完成之后直接进入容器且为容器分配终端；\n2. 使用`--name`指定容器的名字为`c1`；\n3. 后面紧跟着的是使用的镜像为`centos`，版本为`7`；\n4. 最后是指定进入容器之后立刻运行的指令，对于`centos`镜像默认就是`/bin/bash`，所以可以省略；`/bin/bash`可以简写为`bash`；\n\n##### 3.3.3 进出容器\n上面讲使用`-id`参数创建的容器，创建完之后是不会进入的。想要进入只能使用`docker exec`命令手动进入：\n\n```shell\ndocker exec -it c2 /bin/bash\n```\n\n下面详细解读一下这个例子：\n\n1. `-it`表示进入容器之后为容器分配一个终端；\n2. 后面紧跟容器的名称；\n3. 最后是进入容器要做的指令（这边指令不能省略）；\n\n退出容器直接使用`exit`指令即可。\n\n##### 3.3.4 启动 & 停止容器\n1. 使用`docker start <容器名称>`指令开启容器；\n2. 使用`docker stop <容器名称>`指令停止容器；\n\n##### 3.3.5 删除容器\n使用`docker rm <容器名 | 容器id>`指令删除一个容器，删除容器可以使用容器名或容器 id 指定容器。容器的 id 可以通过`docker ps -a`指令查看。\n\n如果想要删除所有的容器，可以使用`docker rm `docker ps -aq``指令，这和删除所有镜像有异曲同工之妙。\n\n##### 3.3.6 容器信息\n使用`docker inspect <容器名称>`来查看一个容器的详细信息。\n\n#### 3.4 数据卷命令\n##### 3.4.1 数据卷\n数据卷是为了解决容器的数据通信问题：\n\n1. 容器之间如何数据互通？\n2. 其它机器与本机中的容器互通？\n\n我们可以把数据卷理解成本机的一个目录或文件，我们可以通过指令将数据卷挂载到容器中，也就是说容器操作的就是数据卷的内容。有了数据卷的概念：\n\n1. 本机或其它机器可以操作数据卷来达到和容器通信的目的；\n2. 一个数据卷可以挂载到多个容器中，因此多个容器也可以通过数据卷通信；\n3. 删除容器时，并不影响数据卷的完整性，因为数据卷只是挂载过去的；\n\n##### 3.4.2 配置数据卷\n在创建容器的时候指定`-v <本机目录>:<容器目录>`参数进行挂载数据卷，挂载有几个注意点：\n\n+ 挂载的目录必须是绝对路径；\n+ 如果目录不存在会自动创建；\n+ 如需挂载多个数据卷就得使用多个`-v`参数；\n\n例如：\n\n```shell\ndocker run -it --name=c1 -v /Users/luyan/Downloads/data:/root/container_data centos:7\n```\n\n这边我就是将本机`/Users/luyan/Downloads/data`目录挂载到容器的`/root/container_data`目录下。下面不论你是直接操作本机的目录还是在容器里面操作，实际都是操作本机的目录。\n\n注意：一个容器可以挂载多个数据卷，一个数据卷可以被多个容器挂载。\n\n##### 3.4.3 数据卷容器\n容器之间进行通信还是比较常见的需求，之前我们说过让这些容器都挂载同一个数据卷就可以实现。但问题是如果数据卷数目较多，容器也较多，此时创建容器的命令很长很容易出错。这种情况下我们可以：\n\n1. 创建一个数据卷容器，也就是挂载了数据卷的容器；\n2. 创建其它容器的时候使用`--volumes-form <数据卷名称>`参数指定与哪一个数据卷容器共享数据卷；\n\n```bash\n# 创建数据卷容器\ndocker run -it --name=baseC -v /volume centos:7\n\n# 通过数据卷容器创建容器\ndocker run -it --name=c1 --volumes-from baseC centos:7\n```\n\n注意：这边创建数据卷容器挂载数据卷的时候，直接使用一个目录`/volume`而不是我们上面的写法。\n\n解析：`/volume`表示容器内的目录，与之对应的数据卷在本机的目录可以通过`docker inspect baseC`来查看，主要查看详细信息的`Mounts`部分：\n\n```json\n \"Mounts\": [\n    {\n        \"Type\": \"volume\",\n        \"Name\": \"e832cf42ed86957ffdabff3895e8a9846ea2a90519afc2f04463e9a22cb7161c\",\n        \"Source\": \"/var/lib/docker/volumes/e832cf42ed86957ffdabff3895e8a9846ea2a90519afc2f04463e9a22cb7161c/_data\",\n        \"Destination\": \"/volume\",\n        \"Driver\": \"local\",\n        \"Mode\": \"\",\n        \"RW\": true,\n        \"Propagation\": \"\"\n    }\n]\n```\n\n里面的`Source`表示本机目录，`Destination`表示容器内目录。\n\n对于数据卷容器有几个注意事项：\n\n+ 当然我们创建数据卷容器的时候可以使用标准写法，同时指定两个目录；\n+ 基于数据卷容器创建的容器本质上就是将数据卷容器的挂载点设置到本容器中，也就是说创建完成之后删除掉数据卷容器也是没有关系的；\n\n### 4. 应用部署\n#### 4.1 mysql 部署\n首先谈一谈需求：我想创建一个 mysql 容器，并且数据不会随着容器的删除而丢失，最后我可以在外界通过可视化软件连接上这个数据库。\n\n下面谈谈实现细节：\n\n+ 需要创建 mysql 容器，那么肯定需要先拉取 mysql 镜像；\n+ 数据不能因为容器删除而删除，那么就需要将 mysql 核心数据挂载数据卷；\n+ 外界不能直接访问容器，但能访问宿主机，因此需要做宿主机与容器之间的端口映射；\n\n端口映射就是访问宿主机某端口会被映射到容器的某端口。下面开始实现：\n\n1. 拉取 mysql 镜像\n\n```shell\ndocker pull mysql:<版本号>\n```\n\n2. 创建数据卷目录\n\n```shell\nmkdir mysql\ncd mysql\n```\n\n3. 创建容器\n\n```shell\ndocker run -id \\\n-p 3306:3306 \\\n--name=c_mysql \\\n-v $PWD/conf:/etc/mysql/conf.d \\\n-v $PWD/logs:/logs \\\n-v $PWD/data:/var/lib/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\nmysql\n```\n\n+ `-p 3306:3306`将宿主机 3306 端口与容器的 3306 端口映射起来；\n+ 下面三个`-v`是为了挂载 mysql 核心文件，`$PWD`获取当前目录；\n+ `-e`定义全局变量，这边定义数据库 root 账户的密码；\n+ 最后的`mysql`是镜像名称；\n\n做好之后，我们就可以使用`navcat`之类的工具连接数据库。注意连接的是宿主机的 3306 端口，因此得填写宿主机的 ip，当然如果是宿主机自己想连接，可以填写`localhost`。\n\n#### 4.2 tomcat 部署\n描述需求：我需要一个 tomcat 容器，能接受本机或其它机器的 war 包，并且项目部署之后能给其它机器访问。实现细节：\n\n+ 需要拉取一个 tomcat 镜像到本地；\n+ 为了能接受其它来源的 war 包，需要对 tomcat 的`webapps`目录做挂载处理；\n+ 为了容器部署的项目能被其它机器访问，需要做端口映射；\n\n下面是实现步骤：\n\n1. 拉取 tomcat 镜像\n\n```shell\ndocker pull tomcat\n```\n\n2. 创建数据卷\n\n```shell\nmkdir webapps\ncd webapps\n```\n\n3. 创建容器\n\n```shell\ndocker run -id --name=c_tomcat \\\n-p 8080:8080 \\\n-v $PWD:/usr/local/tomcat/webapps \\\ntomcat\n```\n\n这边就做了端口映射和数据卷挂载，后面我们就可以将项目包拖到`webapps`目录下运行了。\n\n#### 4.3 nginx 部署\n废话不多说，安装 nginx 也是为了部署项目，直接上流程。\n\n1. 拉取 nginx 镜像\n\n```shell\ndocker pull nginx\n```\n\n2. 创建数据卷\n\n```shell\n创建 nginx/conf 目录，并将 nginx.conf 放到里面，文件内容见下面。\n当前目录设置为 nginx 下\n```\n\n[nginx.txt](https://space-jiangsu.yuque.com/attachments/yuque/0/2024/txt/1561375/1717073405560-1e9a9d7e-170a-4d6a-aca1-309cf40752e3.txt)\n\n3. 创建容器\n\n```shell\ndocker run -id --name=c_nginx \\\n-p 80:80 \\\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\\n-v $PWD/logs:/var/log/nginx \\\n-v $PWD/html:/usr/share/nginx/html \\\nnginx      \n```\n\n解读一下：\n\n+ 配置 80 端口映射；\n+ 将必要的配置文件及经常用到的目录做挂载配置；\n\n后面将项目放到`nginx/html`目录下即可。\n\n#### 4.4 redis 部署\nredis 的部署比较简单，只需要额外设置一个端口映射：\n\n```shell\ndocker run -id --name=c_redis -p 6379:6379 redis\n```\n\n### 5. 镜像制作\n目前我们已经学会了镜像的获取，以及基于镜像的容器创建。\n\n思考一个问题：如果我创建了一个 tomcat 容器，但是默认的配置不满足我们的需求怎么办？\n\n我们不禁会回答：我们在容器里面做某些修改直到满足我们的需求不就行了？\n\n但一旦做了修改就可能出现新问题：我的 tomcat 容器是定制化的（修改过），别人基于镜像创建的 tomcat 容器是默认的，那么同一个代码在我这可能是通的，在别人的容器上可能就错了。\n\n#### 5.1 容器转镜像\n为了解决容器不一致的问题，Docker 允许我们将容器转为镜像。别人拿到我们制作的镜像创建容器，那么我们两个人的容器就是一样的。\n\n主要涉及到三个命令：\n\n```shell\n# 使用 commit 指令对容器生成镜像，版本号可省略，省略的话默认为 latest\ndocker commit <容器id> <镜像名称>:<版本号>\n\n# 将指定镜像压缩成一个包\ndocker save -o <压缩文件名称>.tar <镜像名称>:<版本号>\n\n# 从压缩包中还原镜像\ndocker load -i <压缩文件名称>.tar\n```\n\n之所以需要用到压缩的操作，是因为镜像不能传输，需要压缩之后才能传输。\n\n我们使用之前创建过的`c_tomcat`容器举例子：\n\n```shell\n# 基于 c_tomcat 容器创建镜像\ndocker commit 44d3539ce43b c_tomcat:1.0\n\n# 查看镜像是否成功创建\ndocker images\n```\n\n但是注意：使用`commit`命令创建的镜像会忽略掉容器中挂载的文件，因此这样制作的镜像可能是不全的，所以不推荐使用这种方式制作镜像。\n\n#### 5.2 Dockerfile\n##### 5.2.1 含义\nDockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n\n| **指令** | **说明** |\n| :---: | --- |\n| `FROM` | 指定基础镜像，用于后续的指令构建。 |\n| | `FROM nginx` |\n| `MAINTAINER` | 指定Dockerfile的作者（已弃用，推荐使用LABEL指令）。 |\n| | `MAINTAINER luyan<luyan9812@163.com>` |\n| `LABEL` | 添加镜像的元数据，使用键值对的形式。 |\n| | `LABEL <键 1>=<值 1>...` |\n| `RUN` | `docker build`过程中执行的命令。 |\n| | `RUN <shell 命令>`<br/>`RUN [\"<命令>\", \"<参数 1>\", ...]` |\n| `CMD` | `docker run/start`过程中执行的命令（可以被覆盖）。 |\n| | `CMD <shell 命令>`<br/>`CMD [\"<命令>\", \"<参数 1>\", ...]` |\n| `ENTRYPOINT` | `docker run/start`过程中执行的命令（不可被覆盖）。 |\n| | `ENTRYPOINT [\"<命令>\",\"<参数 1>\", ...]` |\n| `EXPOSE` | 声明容器运行时监听的特定网络端口。 |\n| | `EXPOSE <端口1> ...` |\n| `ENV` | 在容器内部设置环境变量，环境变量在运行后的容器中是存在的。 |\n| | `ENV <键 1>=<值 1> ...` |\n| `COPY` | 将上下文目录（本机）中的文件或目录复制到镜像中指定位置。 |\n| | `COPY index.html /mydir/` |\n| `ADD` | 功能和`COPY`一样，但复制`tar`格式的压缩包时会自动解压缩，不需要自动解压缩的时候**推荐使用**`**COPY**`。 |\n| | `ADD index.html /mydir/` |\n| `VOLUME` | 为容器创建默认数据卷，可以在启动容器时使用`-v`参数覆写。 |\n| | `VOLUME [\"<路径1>\", ...]`<br/>这边设置的路径是容器内路径，本机对应的路径是自动生成的不可指定。 |\n| `WORKDIR` | 设置后续指令的工作目录，路径是容器中的路径。 |\n| | `WORKDIR <工作目录路径>` |\n| `USER` | 指定执行后续指令的用户和用户组。 |\n| | `USER <用户名>[:<用户组>]` |\n| `ARG` | 定义在构建过程中传递给构建器的变量，该变量在容器中不存在。 |\n| | `ARG <键 1>=<值 1> ...` |\n| `ONBUILD` | 当该镜像被用作另一个构建过程的`FROM`时，才会触发。 |\n| | `ONBUILD <指令>` |\n| `STOPSIGNAL` | 设置发送给容器以退出的系统调用信号。 |\n| | `STOPSIGNAL 0` |\n| `HEALTHCHECK` | 定义周期性检查容器健康状态的命令。 |\n| | `HEALTHCHECK [选项] CMD <命令>` |\n| `SHELL` | 指定 RUN、CMD 和 ENTRYPOINT 指令运行的前缀。 |\n| | `SHELL [\"powershell\",\"-command\"]`<br/>将上述三个指令的前面添加`powershell -command` |\n\n\n##### 5.2.2打包 springboot 项目\n首先我们在控制台当前目录下编写 Dockerfile 文件，内容如下：\n\n```dockerfile\n# 项目基于 java 11\nFROM openjdk:11\nMAINTAINER luyan<luyan9812@163.com>\n# 添加 jar 包并改名为 app.jar\nADD springboot_demo-1.0-SNAPSHOT.jar app.jar\n# 启动容器的时候自动运行 java 指令\nCMD java -jar app.jar\n```\n\n控制台当前路径需要有`springboot_demo-1.0-SNAPSHOT.jar`文件。\n\n接着使用如下指令基于 Dockerfile 文件构建镜像：\n\n```shell\ndocker build -f demo_dockerfile -t helloboot .\n```\n\n里面的`demo_dockerfile`是 Dockerfile 文件的名称，上面的命令会生成一个名为`helloboot`的镜像，最后的`.`表示本机的上下文环境是当前目录。我们只需要使用 run 就可以基于镜像创建容器：\n\n```shell\ndocker run -id -p 8080:8080 helloboot \n```\n\n### 6. compose\n\n\n### 7. 私有仓库\n#### 7.1 仓库搭建\n搭建私有仓库非常简单，只需要在机器上创建 registry 容器并运行即可：\n\n```shell\n# 拉取 registry 镜像\ndocker pull registry\n\n# 创建 registry 容器\ndocker run -id --name=registry -p 5001:5000 registry\n```\n\n因为是在 mac 上创建，mac 的 5000 端口被 airplay 功能占用，我不想关所以映射到 5001 端口。\n\n容器启动之后可以到浏览器访问`http://localhost:5001/v2/_catalog`，网址部分应该改成私服的 ip 地址，我是本机所以直接`localhost`。访问的返回内容：\n\n```json\n{\n  \"repositories\": []\n}\n```\n\n返回的 json 串记录着私服里面的镜像。\n\n#### 7.2 上传镜像\n想要上传镜像到私服，首先将私服地址配置到 Docker 的受信任名单中。我直接在桌面端的`Docker Engine`里面添加以下内容（记得域名要换成私服域名）：\n\n```json\n\"insecure-registries\":[\"localhost:5001\"]\n```\n\n下面上传镜像只需要两步，以`centos:7`举例子：\n\n1. 将待上传镜像标记为私服镜像\n\n```shell\ndocker tag centos:7 localhost:5001/centos:7\n\n# 标注完之后，本地镜像列表中会出现一个名为 localhost:5001/centos 版本号为 7 的镜像\n```\n\n2. 上传标记后的镜像\n\n```shell\ndocker push localhost:5001/centos:7\n```\n\n上传完成之后可以再次访问之前说的网址检验是否成功：\n\n```json\n{\n  \"repositories\": [\n    \"centos\"\n  ]\n}\n```\n\n#### 7.3 拉取镜像\n拉取镜像和以前一样，不过是镜像名称前面加上了私服地址：\n\n```shell\ndocker pull localhost:5001/centos:7\n```\n\n\n\n\n'),
       (6, 6, '### 1. 安装及基本概念\n##### 1.1安装`openpyxl`库\n```python\npip3 install openpyxl\n```\n\n##### 1.2 关于 Excel 的一些基本概念\n1. 工作薄：以`.xlsx`结尾的文件就是一个工作薄\n2. 工作表：工作薄里面的`sheet表`就是工作表\n3. 活动表：当前用户正在查看的工作表或者关闭前用户最后查看的工作表叫做活动表\n4. 单元格：工作表里面一个小格子就是单元格\n\n### 2. 使用\n##### 2.1 打开工作薄和工作表\n```python\nimport openpyxl  # 导入模块\n\n\n# 打开已经存在的工作薄，返回一个 Workbook 对象。\n# 若是文件不存在，就抛出 FileNotFoundError 异常。\nwb = openpyxl.load_workbook(\'/Users/luyan/Desktop/岗位需求数据.xlsx\')\nprint(wb)\n\n\n# wb.sheetnames 返回当前工作薄里所有工作表的名称，返回类型是字符串列表。\nprint(wb.sheetnames, type(wb.sheetnames))\n\n\n# wb[\'任务说明\'] 可以直接获取到某个工作表（Worksheet）对象。\n# 若是对应的工作表不存在，抛出 KeyError 异常。\nsheet = wb[\'任务说明\']\nprint(sheet)\n\n\n# wb.active 返回活动表对象，也是一个 Worksheet 对象。\nprint(wb.active)\n```\n\n##### 2.2 读取单元格信息\n```python\n\"\"\" 下面两种方式都能获取单元格对象，返回类型是 Cell 对象。 \"\"\"\n# 直接通过下标获取，这边表示获取第 10 行、第 AB（28） 列的单元格对象。\n# 注意了，字母在前数字在后，也就是列下标在前，行下标在后。如果写成 10AB 抛 ValueError 异常。\n# 对于列下标，使用的字母不区分大小写，也就是说 ab10 也是合法的。\ncell = sheet[\'AB10\']\n\n# 使用数字下标的方式获取单元格对象。下面表示获取第 10 行、第 28 列的单元格对象。\n# 不论行下标还是列下标，都是一个大于 0 的整数，这边就不能写 AB 之类的来表示列了。\ncell = sheet.cell(row=10, column=28)\n\n# 获取单元格里的内容，若是没有内容就返回 None。\nprint(cell.value)\n\n# 获取单元格的行下标，下标从 1 开始计数。\nprint(cell.row)\n\n# 获取单元格的列下标，下标从 1 开始计数。\nprint(cell.column)\n\n# 获取单元格的行列下标，返回的类似于 AB10 这样的字符串。\nprint(cell.coordinate)\n```\n\n##### 2.3 获取工作表行列数\n```python\n\"\"\"工作表理论上是无限大的，但是我们这边讨论的范围都是：\n    左上角 - A1，\n    右下角 - 从有内容的单元格或代码中获取的Cell对象中取最右下方那一个下标。 \n   由左上角和右下角单元格对象围起来的区域才是有效区域。\n\"\"\"\n# 使用 sheet.rows 获取工作表有效区域里所有的行。\n# 返回一个元组列表。元组里存的是第 i 行的所有 Cell 对象，所有的行再构成一个列表。\nprint(list(sheet.rows))\n\n# 使用 sheet.columns 获取工作表有效区域里所有的列。\n# 返回一个元组列表。元组里存的是第 j 列的所有 Cell 对象，所有的列再构成一个列表。\nprint(list(sheet.columns))\n\n# sheet.max_row 获取有效区域的最大行数。\n# sheet.max_column 获取有效区域的最大列数。\n# 但是，如果这是一个空表，给出的最大行列都是 1 而不是 0。\nprint(sheet.max_row, sheet.max_column)\n```\n\n##### 2.4 单元格的切片\n```python\n\"\"\"单元格的切片：\n       切片是指给定左上角和右下角坐标，获取范围内的所有单元格对象。\n    \n   对于 sheet[p1: p2]\n       我们称 p1 到 p2 之间的行数为 rows。若 p1 所在行下标大于 p2 行下标，则 rows = 0。\n       我们称 p1 到 p2 之间的列数为 cols。\n           若 p1 所在列下标大于 p2 列下标或 rows = 0，则 cols = 0。\n\"\"\"\n# 1. 首先两个下标要合法，否则会抛 ValueError 异常。\n# 2. 返回一个二维元组，里层元组包含一行单元格对象，多行对象在一起就构成了外层元组。\n# 3. 二维元组的形状必然是 rows * cols\ncell_row = sheet[\'A1\': \'B2\']\nprint(cell_row)\n```\n\n##### 2.5 创建工作薄\n```python\n# 直接创建一个空白的工作薄对象。\nwb = openpyxl.Workbook()\n\n# 对于新创建的空白工作薄，里面默认有一个名为 Sheet 的工作表。\nprint(wb.sheetnames)\n\n# 创建完成之后记得保存工作薄。里面的文件路径是必选项。\nwb.save(\'/Users/luyan/Desktop/demo.xlsx\')\n```\n\n##### 2.6 创建修改工作表\n```python\nwb = openpyxl.load_workbook(\'/Users/luyan/Desktop/demo.xlsx\')\nprint(wb.sheetnames)\n\n# 获取名为 Sheet 的工作表对象\nsheet = wb[\'Sheet\']\n\n# 修改工作表的名字\nsheet.title = \'自定义工作表名\'\n\n# 创建一个名为“销售记录”的工作表\nwb.create_sheet(\'销售记录\')\n\n# 在下标为 0 的地方创建一个工作表，也就是说这张工作表会放在所有工作表的最前面。\nwb.create_sheet(\'冠军组\', index=0)\nprint(wb.sheetnames)\n\n# 删除某一张工作表\ndel wb[\'自定义工作表名\']\nprint(wb.sheetnames)\n```\n\n##### 2.7 单元格数据操作\n```python\nfrom openpyxl.styles import Side, Border, Font, PatternFill\n\n\n# 获取工作薄和工作表对象\npath = \'/Users/luyan/Desktop/demo.xlsx\'\nwb = openpyxl.load_workbook(path)\nsheet = wb[\'冠军组\']\n\n# 获取单元格对象\ncell = sheet[\'A1\']\n\n# 对单元格的 value 属性进行赋值。也就是修改单元格里的值。\ncell.value = \'你好\'\nsheet[\'A1\'] = \'你好\'  # 你也可以直接这样操作\n\n\n# 给单元格的文字添加样式：楷体、加粗、倾斜、颜色（RGB）\ncell.font = Font(name=\'楷体\', b=True, i=True, color=\'8470FF\')\ncell.font = Font()  # 清空文字样式\n\n\n# 给单元格添加背景色，注意前面的 patternType 是必须的。\ncell.fill = PatternFill(patternType=\'solid\', bgColor=\'FEFEFE\')\ncell.fill = PatternFill()  # 清空背景色\n\n\n# 创建边框对象，样式是粗单直线，颜色为红色。\nside = Side(style=\'thick\', color=\'FF0000\')\n# 将单元格的上下边框设置为上面的边框样式。当然你也可以指定 left 和 right。\ncell.border = Border(top=side, bottom=side)\ncell.border = Border()  # 清空边框线样式\n# 常见边框样式\nborder_map = {\'thin\': \'细单直线\', \'thick\': \'粗单直线\', \'medium\': \'中等粗细单直线\',\n        \'double\': \'双直线\', \'dotted\': \'波浪线\', \'hair\': \'锯齿波浪线\',\n        \'dashed\': \'细虚线\', \'mediumDashed\': \'中等粗细虚线\',\n        \'dashDot\': \'细点横线（一个点一小段横线...）\', \'mediumDashDot\': \'中等粗细点横线\',\n        \'dashDotDot\': \'细点点横线（两个点一小段横线...）\',\n        \'mediumDashDotDot\': \'中等粗细点点横线（两个点一小段横线...）\',\n        \'slantDashDot\': \'麻绳线（长得像麻绳）\'\n}\n\n\n# 设置单元格文字的对齐方式，horizontal 表示水平方向，vertical 表示竖直方向。\n# 水平方向有：left，right，center；竖直方向有：top，bottom，center；\ncell.alignment = Alignment(horizontal=\'center\', vertical=\'bottom\')\n\n#! 一定要记得保存啊，不然改了等于没改。\nwb.save(path)\n```\n\n##### 2.8 筛选、排序和公式\n###### 2.8.1 筛选\n```python\n# 选中筛选的区域\nsheet.auto_filter.ref = \'B1:C1\'\n\n# 添加过滤条件，0 表示筛选已选区域的第 0 列，这边表示 B 列。\n# 筛选条件用列表来表示，这边表示 B 列值等于‘上海’的所有行。\nsheet.auto_filter.add_filter_column(0, [\'上海\'])\n\n\"\"\"这部分内容没啥用，因为筛选等于没有筛选。代码里面读取文件可不管你有没有筛选，都是读取全部。\n\"\"\"\n```\n\n###### 2.8.2 排序\n虽然 Python 操作排序没什么用，但是你可以在 Excel 软件里面排序，然后 Python 读取数据，那就是有序的了。简直神奇。\n\n```python\n# 选中筛选区域\nsheet.auto_filter.ref = \'C1:C6\'\n\n# 添加排序字段，和排列顺序\nsheet.auto_filter.add_sort_condition(ref=\'C1:C6\', descending=True)\n\n\"\"\"这部分内容没啥用，因为根本排不了，需要手动排序。\n\"\"\"\n```\n\n###### 2.8.3 公式\n```python\nsheet[\'A1\'] = 100\nsheet[\'B1\'] = 200\n\n# C1 单元格的值就是一个公式，其值由 A1+B1 获得。\n# 打开 Excel 软件，查看发现其值确实变为了 300。\nsheet[\'C1\'] = \'=SUM(A1+B1)\'\n\n# 但是你打印一下 C1 单元格的值发现，输出的并不是 300 而是字符串“=SUM(A1+B1)”\n# 很坑爹有没有？\nprint(sheet[\'C1\'].value)\n```\n\n##### 2.9 设置单元格宽高\n以下设置一下 2 行 B 列单元格的宽高。\n\n```python\n# 设置第二行的高为 50\nsheet.row_dimensions[2].height = 50\n\n# 设置第 B 列的宽为 80\nsheet.column_dimensions[\'B\'].width = 80\n```\n\n###### 2.10 单元格的拆分\n```python\n# 合并 A1 为左上角、D3 为右下角的区域。\n# 若是区域不对，例如左上角的下标跑到右边或下边去了，直接报错。\nsheet.merge_cells(\'A1:D3\')\n\n# 注意合并完的单元格赋值，只能给原来左上角的下标处赋值。\n# 这边若是你给 B2 赋值，是错误的，因为不存在 B2 单元格了，被合并掉了。\nsheet[\'A1\'].value = \'B2Value\'\n\n# 拆分单元格，单元格的范围不能擅自缩小，多大范围合并起来的就多大范围拆分。\nsheet.unmerge_cells(\'A1:D3\')\n```\n\n###### 2.11 单元格的冻结\n所谓冻结就是移动表格时，某一行或某一列不会移动。\n\n```python\n# 冻结单元格 B3 上面所有行和前面所有列。\n# 也就是冻结第 1，2 行和第 A 列\nsheet.freeze_panes = \'B3\'\n\n# 解除冻结就赋值 None\nsheet.freeze_panes = None\n```\n\n'),
       (7, 7, '## 一. 数据请求\n### 1. urllib 库\n##### 1.1 get 请求\n```python\nimport urllib.request as request  # 导入请求模块\n\n# 使用 GET 方式请求一个网址，返回一个 HTTPResponse 对象\nresponse = request.urlopen(\"https://www.python.org\")\n\n# 有参数要传递，可以直接拼接在 URL 后面\n# response = request.urlopen(\"https://www.httpbin.org/get?name=luyan\")\n\nprint(response.status)  # 响应码。200-成功，404-找不到资源，500-服务器出错\n\n# 所有响应头信息，以元组列表的形式存在[(\'Server\', \'nginx\'), (...)]\nprint(response.getheaders())\nprint(response.getheader(\'Server\'))  # 获取响应头里指定的信息\n\n# 响应内容，例如 HTML 代码。因为直接 read 返回的是二进制字符串，所以需要转码成普通字符串\nprint(response.read().decode(\'utf-8\'))\n```\n\n##### 1.2 post 请求\n```python\nimport urllib.parse as parse  # 将字典转换成 post 表单信息时用到的模块\nimport urllib.request as request\n\n# 先将字典转换成表单信息，如 {\'name\': \'luyan\'} ==> name=luyan\n# 再将信息转码成 bytes 类型并指定使用 utf-8 格式转码\ndata = bytes(parse.urlencode({\'name\': \'luyan\'}), encoding=\'utf-8\')\n\n# 使用 urlopen 时传入 data 属性就会变为 POST 请求\nresponse = request.urlopen(\"https://www.httpbin.org/post\", data=data)\n\n# 以下内容和上面一样\nprint(response.status)\nprint(response.getheaders())\nprint(response.getheader(\'Server\'))\nprint(response.read().decode(\'utf-8\'))\n```\n\n##### 1.3 urlopen 的 timeout 参数\n```python\nimport socket\nimport urllib.error\nimport urllib.request\n\ntry:\n    # 设置超时时间是 0.1 秒，若是访问超时会抛 urllib.error.URLError 异常\n    response = urllib.request.urlopen(\'https://www.httpbin.org/get\', timeout=0.1)\nexcept urllib.error.URLError as e:\n    # 判断是否是超时异常\n    if isinstance(e.reason, socket.timeout):\n        print(\'TIME OUT\')\nelse:\n    # 没有出异常则执行读取数据操作\n    print(response.read())\n```\n\n##### 1.4 构建 Request 对象指定 headers\n```python\nimport socket\nfrom urllib import request, parse, error\n\n# 要访问的 url\nurl = \'https://www.httpbin.org/post\'\n# 要是想使用 GET 方式访问这个参数可以不要\ndata = bytes(parse.urlencode({\'name\': \'Luyan\'}), encoding=\'utf-8\')\n# 自定义 headers，这边就先定义下 User-Agent\nheaders = {\n    \'User-Agent\': \'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\',\n}\n\n# 构造 Request 对象\nreq = request.Request(url=url, data=data, headers=headers, method=\'POST\')\n# 也可以使用这样的方式添加 header\nreq.add_header(\'Host\', \'www.httpbin.org\')\n\ntry:\n    # 可以将 Request 对象传入 urlopen 函数里面\n    res = request.urlopen(req, timeout=1)\nexcept error.URLError as e:\n    if isinstance(e.reason, socket.timeout):\n        print(\'访问超时\')\n    else:\n        print(e)\nelse:\n    print(res.read().decode(\'utf-8\'))\n\n```\n\n##### 1.5 使用 Handler 通过基本身份验证\n基本身份验证是什么？万维网协议自带的验证体系，不是人为做出登陆的弹窗。\n\n```python\nfrom urllib.error import URLError\nfrom urllib.request import HTTPPasswordMgrWithDefaultRealm\nfrom urllib.request import HTTPBasicAuthHandler, build_opener\n\nusername = \'admin\'\npassword = \'admin\'\nurl = \"https://ssr3.scrape.center\"\n\n# 对应 url 的用户名和密码\np = HTTPPasswordMgrWithDefaultRealm()\np.add_password(None, url, username, password)\n\n# 基本验证处理器\nauth_handler = HTTPBasicAuthHandler(p)\n\n# 使用验证处理器生成 opener\nopener = build_opener(auth_handler)\n\ntry:\n    # 打开需要验证的网页\n    result = opener.open(url)\n    html = result.read().decode(\'utf-8\')\n    print(html)\nexcept URLError as e:\n    print(e.reason)\n```\n\n##### 1.6 使用 Handler 设置代理\n```python\nfrom urllib.error import URLError\nfrom urllib.request import ProxyHandler, build_opener\n\n# 代理服务器地址\nproxy_handler = ProxyHandler({\n    \'http\': \'http://127.0.0.1:8080\',\n    \'https\': \'https://127.0.0.1:8080\'\n})\n\n# 生成对应的 opener\nopener = build_opener(proxy_handler)\n\ntry:\n    response = opener.open(\'https://www.baidu.com\')\n    print(response.read().decode(\'utf-8\'))\nexcept URLError as e:\n    print(e.reason)\n\n```\n\n##### 1.7 使用 Handler 操作 Cookie\n```python\nimport http.cookiejar, urllib.request\n\n# 创建空 Cookie 对象\ncookie = http.cookiejar.CookieJar()\n\n# 将 Cookie 传入 Handler\nhandler = urllib.request.HTTPCookieProcessor(cookie)\n\n# 有 handler 就有 opener\nopener = urllib.request.build_opener(handler)\n\n# 使用 opener 打开 url\nresponse = opener.open(\'https://www.baidu.com\')\n\nfor item in cookie:  # 访问成功就可以遍历 cookie 内容了\n    print(f\"{item.name} = {item.value}\")\n```\n\n##### 1.8 使用 Handler 保存或加载 Cookie\n```python\nimport http.cookiejar\nimport urllib.request\n\n# cookie 要存放的路径，以 txt 结尾\nfilename = \'/Users/luyan/Desktop/cookie.txt\'\n# 创建 MozillaCookie 对象，用来保存和读取 cookie\ncookie = http.cookiejar.MozillaCookieJar(filename)\n\n# 如果本地有 cookie 文件，就用下面 load 函数加载本地 cookie\n#cookie.load(filename, ignore_discard=True, ignore_expires=True)\n\n# 创建 handler\nhandler = urllib.request.HTTPCookieProcessor(cookie)\n# 创建 opener\nopener = urllib.request.build_opener(handler)\n# 访问网页\nresponse = opener.open(\'https://www.baidu.com\')\n\n# 使用 save 函数保存 cookie\ncookie.save(ignore_discard=True, ignore_expires=True)\n\nfor item in cookie:\n    print(f\"{item.name} = {item.value}\")\n```\n\n##### 1.9 关于异常\n```python\nimport socket\nfrom urllib import request, error\n\nurl = \'https://www.baidu.com\'\n\ntry:\n    response = request.urlopen(url, timeout=1)\nexcept error.HTTPError as e:  # 这个异常是 URLError 的子类\n    # 可以打印响应码、出错原因、响应头信息\n    print(e.code, e.reason, e.headers, sep=\'\\n\')\nexcept error.URLError as e:\n    # 如果是超时异常，就特别输出\n    if isinstance(e.reason, socket.timeout):\n        print(\'TIME OUT\')\n    else:\n        print(e.reason)\nelse:\n    # 成功打印页面内容\n    print(response.read())\n```\n\n##### 1.10 parse 模块的一些常用函数\n```python\nurl = \'https://www.baidu.com/index.html;user?name=luyan#common\'\n# ParseResult(scheme=\'https\', netloc=\'www.baidu.com\', path=\'/index.html\', \n# 	params=\'user\', query=\'name=luyan\', fragment=\'common\')\nprint(parse.urlparse(url))  # 解析链接，结果如上\n\n# SplitResult(scheme=\'https\', netloc=\'www.baidu.com\', path=\'/index.html;user\', \n#	query=\'name=luyan\', fragment=\'common\')\nprint(parse.urlsplit(url))  # 解析链接，params 部分归属于 path，不单独解析\n\n\n# 合成的结果：https://www.baidu.com/index.html;user?name=luyan\n# data 可以是元组，只要各个元素按照上面的元素对照好就行：\n# scheme netloc path params query fragment\ndata = [\'https\', \'www.baidu.com\', \'index.html\', \'user\', \'name=luyan\', \'\']\nprint(parse.urlunparse(data))  # 合成链接\n\n# 合成的结果：https://www.baidu.com/index.html?name=luyan\n# data 可以是元组，只要各个元素按照上面的元素对照好就行：\n# scheme netloc path params query fragment\ndata = [\'https\', \'www.baidu.com\', \'index.html\', \'name=luyan\', \'\']\nprint(parse.urlunsplit(data))  # 合成链接，只是忽略 params 选项\n\n\n# 以下字典将被转换成：name=Luyan&age=18\nparams = {\'name\': \'Luyan\', \'age\': 18}\nprint(parse.urlencode(params))  # 将字典转换成网络参数格式的字符串\n\n# 以下字符串将被解析成：{\'name\': [\'Luyan\', \'Tom\'], \'age\': [\'18\']}\nparams_str = \'name=Luyan&name=Tom&age=18\'\nprint(parse.parse_qs(params_str))  # 将网络参数格式字符串解析成字典\n\n# 解析为：[(\'name\', \'Luyan\'), (\'name\', \'Tom\'), (\'age\', \'18\')]\nparams_str = \'name=Luyan&name=Tom&age=18\'\nprint(parse.parse_qsl(params_str))  # 将字符串解析成元组列表\n\n\n# 拼接网址，下面案例输出：http://www.baidu.com/page\nprint(parse.urljoin(\'http://www.baidu.com/\', \'/page\'))\n\n\n# 以下打印：https://www.baidu.com?wd=%E5%8D%A2%E7%A0%94\nurl = \'https://www.baidu.com?wd=\'\nurl = f\'{url}{parse.quote(\"卢研\")}\'  # quote 可以将字符串使用 URL 方式编码\nprint(url)\n\n# 以下打印：https://www.baidu.com?wd=卢研\nurl = \'https://www.baidu.com?wd=%E5%8D%A2%E7%A0%94\'\nprint(parse.unquote(url))  # 将编码后的字符串转换成原字符串\n\n```\n\n\n\n### 2. requests 库（需安装）\n##### 2.1 GET 请求\n###### 2.1.1 中规中矩的写法\n```python\nimport requests\n\n# 使用 Get 方式携带参数请求某一网址\nurl = \'https://www.httpbin.org/get?name=luyan\'\n\nresponse = requests.get(url)\n\nprint(response.status_code)  # 响应码\nprint(response.headers)  # 响应头，字典形式\nprint(response.url)  # 访问的网址\nprint(response.cookies)  # cookie\nprint(response.text)  # 返回的内容，如 HTML 内容等\n\nprint(response.encoding)  # 响应编码\nresponse.encoding = \'gbk\'  # 有时候需要指定编码，不然返回的数据可能乱码\n```\n\n###### 2.1.2 优雅写法\n```python\nurl = \'https://www.httpbin.org/get\'\n\n\n# 直接传入一个字典作为参数，就可以不自己拼接参数。多优雅！\ndata = {\'name\': \'luyan\', \'age\': 18}\nresponse = requests.get(url, params=data)\n\n\n# 自定义 headers，优雅有没有\nheaders = {\'User-Agent\': \'xxx\'}\nresponse = requests.get(url, headers=headers)\n\n\n# 若是返回的数据 r.text 是 json 格式的，则可以直接使用 json() 方法将返回的字符串转换成字典\n# 若是格式不对，则转换会抛出 json.decoder.JSONDecoderError 异常\nprint(response.json())\n```\n\n###### 2.1.3 抓取多媒体文件\n```python\nimport requests\n\n# 这个网址指向一个图片\nurl = \'https://scrape.center/favicon.ico\'\n\nresponse = requests.get(url)\n\n# 将抓取到的图片信息写进文件里，注意涉及文件是二进制读写\nwith open(\'/Users/luyan/Desktop/favicon.ico\', \'wb\') as f:\n    # 图片的二进制数据存储在 content 属性里面，不是 text\n    f.write(response.content)\n```\n\n##### 2.2 POST 请求\n```python\nimport requests\n\nurl = \'https://www.httpbin.org/post\'\n\n# 要提交的数据直接使用字典的形式，然后直接传到请求函数里面\ndata = {\'name\': \'Luyan\', \'age\': 18}\nresponse = requests.post(url, data=data)\nprint(response.text)\n\n\n# 使用返回的状态码判断动作\nexit() if response.status_code != requests.codes.ok else print(\'nice\')\n\n# 常用的状态码\n200 - requests.codes.ok\n404 - requests.codes.not_found\n500 - requests.codes.internal_server_error\n```\n\n##### 2.3 高级用法\n###### 2.3.1 文件上传\n```python\n\"\"\"文件上传\"\"\"\n\nimport requests\n\nurl = \'https://www.httpbin.org/post\'\n\n# 将要上传的文件放入字典\nfiles = {\'file_name\': open(\'/Users/luyan/Desktop/favicon.ico\', \'rb\')}\n\n# 上传的时候直接指定 file 参数就可以了\nresponse = requests.post(url, files=files)\nprint(response.text)\n```\n\n###### 2.3.2 cookie 操作\n+ 获取 cookie\n\n```python\nimport requests\n\nurl = \'https://www.baidu.com\'\n\nresponse = requests.get(url)\n\n# 获取 cookie\nfor key, value in response.cookies.items():\n    print(f\'{key}={value}\')\n```\n\n+ 自定义 headers 来上传 cookie\n\n```python\n# 直接拿到 cookie 放进 headers 里面来上传\ncookies = \'cookie内容\'\nheaders = {\n    \'Cookie\': cookies\n}\n\nresponse = requests.get(\'https://www.github.com\', headers=headers)\nprint(response.text)\n```\n\n+ 逐一添加 cookie\n\n```python\n# 用逐个添加的方式上传 cookie\ncookies = \'name=luyan;age=18;....\'\n\n# 创建 cookie 对象\njar = requests.cookies.RequestsCookieJar()\n\n# 将信息填入 cookie 之中\nfor cookie in cookies.split(\';\'):\n    key, value = cookie.split(\'=\', 1)\n    jar.set(key, value)\n    \nresponse = requests.get(\'https://www.github.com\', cookies=jar)\nprint(response.text)\n```\n\n###### 2.3.3 Session 维持\n多次访问同一个网站，共用服务端同一个session，也就是保持同一个身份\n\n```python\n\"\"\"方案一：\n    多次访问携带同一个 cookie，那 session 肯定是同一个\n\"\"\"\nurl = \'https://www.httpbin.org/cookies\'\ncookie = urllib.parse.urlencode({\'name\': \'luyan\'})\nheaders = {\'Cookie\': cookie}\n# 每次访问都带上同一个 cookie，用以维持 session\nresp = requests.get(url, headers=headers)\nprint(resp.text)\n\n\n\"\"\"方案二：\n    使用 requests.Session 维持身份\n\"\"\"\nurl = \'https://www.httpbin.org/cookies\'\ns = requests.Session()\n\n# 同一个 session 下，多次请求的cookie是一样的，所以可以起到维持 session 的作用\ns.get(f\'{url}/set/name/luyan\')  # 第一次请求携带信息\nresp = s.get(url)  # 第二次请求不用携带\n\nprint(resp.text)\n```\n\n###### 2.3.4 SSL 验证\n+ 解决方案\n\n```python\n# 有些网站没有https证书，导致访问网站的时候有异常。表现在chrome里面就是提示该网站不是私密连接\n# 当我们试图访问这个网站的时候会报 requests.exceptions.SSLError 异常\nresp = requests.get(url)\n\n# 但是我们就是想要继续访问，可以更改 verify 参数来继续访问\n# 虽然这样可以正常访问，但控制台还是会报警告。虽不影响功能，但是不好看\nresp = requests.get(url, verify=False)\n```\n\n+ 屏蔽警告的方法\n\n```python\n# 屏蔽警告的方法 1\nimport logging\n\nlogging.captureWarnings(True)  # 捕获警告\nresp = requests.get(url, verify=False)\n\n\n# 屏蔽警告的方法 2\nfrom requests.packages import urllib3\n\nurllib3.disable_warnings()  # 使用 requests 库里的方法\nresp = requests.get(url, verify=False)\n```\n\n###### 2.3.5 超时时间\n```python\n# 请求的时候直接指定 timeout 选项即可。下面指定用于连接和读取的超时总时间为 1 秒\nresp = requests.get(url, timeout=1)\n\n# 可以同时指定，连接超时时间和读取超时时间\nresp = requests.get(url, timeout=(1, 3))\n```\n\n###### 2.3.6 身份验证\n```python\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nurl = \'https://ssr3.scrape.center\'\n\n# 传入用户名和密码\nauth = HTTPBasicAuth(\'admin\', \'admin\')\n\n# 访问的时候传入 auth 信息\nresp = requests.get(url, auth=auth)\nprint(resp.text)\n\n\n\n# auth 参数可以直接传入一个元组，元组里面封装用户名和密码\n# requests 内部会默认使用 HTTPBasicAuth() 来封装用户名密码\nresp = requests.get(url, auth=(\'admin\', \'admin\'))\nprint(resp.text)\n```\n\n###### 2.3.7 代理\n```python\nimport requests\n\nurl = \'https://www.baidu.com\'\nproxies = {\n    \'http\': \'http://127.0.0.1:8080\',\n    \'https\': \'http://127.0.0.1:8080\'\n}\n\n# 设置代理也就是一个字典的事情，优雅不？\nrequests.get(url, proxies=proxies)\n```\n\n###### 2.3.8 Prepared Request\n```python\nfrom requests import Request, Session\n\n\"\"\"\n更灵活但稍有复杂的请求方式\n\"\"\"\n\nurl = \'https://www.httpbin.org/post\'\ndata = {\'name\': \'Luyan\'}\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)\'\n                  \' AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36\'\n}\n\ns = Session()\n# 构建 Request 对象，也可以构建 GET 请求的\nreq = Request(\'POST\', url, data=data, headers=headers)\n# 构建 Prepared Request 对象\npr = s.prepare_request(req)\n# 发送请求，这边使用 POST 方式请求\nresp = s.send(pr)\nprint(resp.text)\n```\n\n### \n### 3. httpx 库（需安装）\n##### 3.1 安装\n不论是 urllib 还是 requests 都不支持 http2 协议。所以遇到网站只支持 http2 协议的，这两个库就没有办法了。于是我们需要使用 httpx 来支持 http2 协议，在 pycharm 控制台输入以下指令进行安装。\n\n```python\n# 安装 httpx\npip3 install httpx\n\n# 安装 httpx 对 http2 协议的支持\npip3 install \'httpx[http2]\'\n```\n\n##### 3.2 简单使用\n```python\nimport httpx\n\nurl = \'https://www.httpbin.org/get\'\n\nheaders = {\n    \'User-Agent\': \'myself agent\'\n}\n\n# 和 requests 很像，传入 url 和请求头\n# 还可以传入 params 字典；若是 post 请求可以传入 data 字典\n# 和 requests 简直一模一样啊，有没有？\nresp = httpx.get(url, headers=headers)\n\n\n\n\"\"\"\nresponse 有如下属性和函数可用：\n    status_code: 响应码\n    text: 响应体文本内容\n    content: 响应体二进制内容，文件内容就在这\n    headers: 响应头\n    \n    json: 函数。将 text 转成字典（json），如果格式不对会报错\n\"\"\"\n\nprint(resp.status_code)\nprint(resp.headers)\nprint(resp.text)\n```\n\n##### 3.3 http2 协议支持\n```python\n# 默认 httpx 也只是支持 http1.1，想要支持 http2，需要额外打开支持\nimport httpx\n\n# 打开 http2 开关\nclient = httpx.Client(http2=True)\n# 请求的时候用 Client 对象请求\nresp = client.get(url, headers=headers)\n\nprint(resp.status_code)\nprint(resp.headers)\nprint(resp.text)\n```\n\n##### 3.4 Client 对象\n```python\n# 官方写法推荐\nimport httpx\n\nurl = \'https://spa16.scrape.center/\'\n\nheaders = {\n    \'User-Agent\': \'myself agent\'\n}\n\ndata = {\n    \'name\': \'Luayn\'\n}\n\n# 使用同一个 Client 对象进行多次访问的环境是一样的，如下面每一次访问都使用同样的headers\n# 和文件写法很像，有没有？这样写，系统会自动关闭 Client 对象，避免内存泄漏\nwith httpx.Client(headers=headers, http2=True) as client:\n    # 里面还是一样的用法\n    resp = client.get(url, params=data)\n    print(resp.text)\n```\n\n##### 3.5 代理\n```python\nimport httpx\n\nurl = \'https://www.httpbin.org/get\'\nproxies = {\n    \'http\': \'http://127.0.0.1:8080\',\n    \'https\': \'http://127.0.0.1:8080\'\n}\n\n# 在 get 方法里面设置 proxies 参数就设置了代理了\nresp = httpx.get(url=url, proxies=proxies)\nprint(resp.text)\n\n\n# 同样的，在 Client 对象的构造里面设置 proxies 参数也能设置代理\nwith httpx.Client(proxies=proxies) as client:\n    # 里面还是一样的用法\n    resp = client.get(url)\n    print(resp.text)\n```\n\n\n\n## 二. 数据解析\n### 1. lxml  库（需安装）\n##### 1.1 html 文本修复\n###### 1.1.1 从字符串读取\n```python\nfrom lxml import etree\n\ntext = \"\"\"<div>\n    <div></div>\n    <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    </ul>\n</div>\n\"\"\"\n\nhtml = etree.HTML(text)  # 使用文本构造 HTML 对象，这里就修复不配套或缺少的节点了\nresult = etree.tostring(html)  # 将对象转换成二进制字符串\nprint(result.decode(\'utf-8\'))  # 将二进制字符串转换成编码 utf-8 的普通字符串\n\n\n\"\"\"补全节点是指：\n    1. 假设有这样的一个节点：<li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    我们可以看出，这个 li 节点是不闭合的，生成 HTML 对象时会自动补全这个节点\n    \n    2. 按照上面的例子，甚至还会给节点包装一层 <html><body></body></html>\n\"\"\"\n```\n\n###### 1.1.2 从文件读取\n```python\nfrom lxml import etree\n\n# 直接从文件构造 HTML 对象\nhtml = etree.parse(\'demo.html\', etree.HTMLParser())\n\nresult = etree.tostring(html)  # 对象转二进制字符串\nprint(result.decode(\'utf-8\'))  # 将二进制串解码成 utf-8 编码的字符串\n```\n\n##### 1.2 数据解析\n###### 1.2.1 XPath 常用语法\n| 表达式 | 描述 |\n| --- | --- |\n| . | 当前节点 |\n| .. | 父节点 |\n| @ | 获取属性 |\n| /nodename | “/” 放在开头指向“根”，“根”是指整个文档，不是最外层节点。<br/>不论是否开头， “/” 都表示获取直接子节点。<br/><br/>后面的 nodename 非必须，没有的话，就返回一个空列表，因为根不属于节点<br/>“/*” 表示当前节点的所有直系子节点；<br/>“/div” 表示当前节点的所有直系子 div 节点； |\n| //nodename | “//” 放在开头指向最外层节点，对于网页来说往往是 html 节点。<br/>不论是否开头，“//” 表示获取所有子孙节点。<br/><br/>后面的 nodename 是必须的。<br/>“//*” 表示所有子孙节点，不包含自己；但是开头的 //* 就包含自己了。<br/>“//div” 表示当前节点下的所有子孙节点，不含当前节点。 |\n| nodename | 获取名字为 nodename 的节点。不可单独使用，需要配合上面的 “/” 和 “//” |\n\n\n###### 1.2.2 数据\n```python\nfrom lxml import etree\n\ntext = \"\"\"<div>\n    <div></div>\n    <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    </ul>\n</div>\n\"\"\"\n\nhtml = etree.HTML(text)  # 使用文本构造 HTML 对象，这里就修复不配套或缺少的节点了\n```\n\n###### 1.2.3 顺序访问\n```python\n\"\"\"以下同名节点可能返回多个，为了简便，li*5 表示返回 5 个 li 节点\"\"\"\n\n# 返回“根”下的所有子节点：[html]\nprint(html.xpath(\"/*\"))\n\n# 返回最外层节点（html）下的所有子孙节点，因为属于开头，所以包含自己\n# [html、body、div*2、ul、li*5、a*5]\nprint(html.xpath(\"//*\"))\n\n# “根”下的所有 div 子节点，因为不存在，所以返回空列表：[]\nprint(html.xpath(\"/div\"))\n\n# 返回最外层节点（html）下的所有子孙 div 节点\n# 虽然属于开头，但是自己是 html 节点，不满足 div 的条件，所以没有自己\n# [div*2]\nprint(html.xpath(\"//div\"))\n\n# 最外层（html）节点下所有子孙 ul 节点下所有直接子 a 节点\n# 因为 ul 下没有子 a 节点，返回空列表：[]\nprint(html.xpath(\"//ul/a\"))\n\n# html 子孙 ul 节点的子孙 a 节点：[a*5]\nprint(html.xpath(\"//ul//a\"))\n```\n\n###### 1.2.4 父节点、属性筛选、返回属性\n```python\n# html 子孙 ul 节点的子孙 a 节点的父节点：[li*5]\nprint(html.xpath(\"//ul//a/..\"))\n\n# html 子孙 ul 节点的子孙 a 节点的父节点：[li*5]\nprint(html.xpath(\"//ul//a/parent::*\"))\n\n# html 子孙 ul 节点的子孙 a 节点的所有父 p 节点，因为不存在，返回：[]\nprint(html.xpath(\"//ul//a/parent::p\"))\n\n# 返回属性。\n# //li 表示 html 的所有子孙 li 节点；/@class 表示返回当前节点的 class 属性\n# 返回 html 所有子孙 li 节点的 class 属性：[\'item-inactive\', \'item-0\'*2, \'item-1\'*2]\nprint(html.xpath(\"//li/@class\"))\n\n# 属性筛选。\n# //li 表示 html 所有子孙 li 节点；\n# [@class=\'item-inactive\'] 表示当前节点中满足 class 是 item-inactive 的所有节点；\n# 返回 html 所有子孙 class 是 item-inactive 的 li 节点：[li*1]\nprint(html.xpath(\"//li[@class=\'item-inactive\']\"))\nprint(html.xpath(\"//li[@class=\'item-0\']\"))  # [li*2]\n\n# html 子孙 ul 子孙 a 的所有 class 是 item-inactive 的父节点：[li*1]\nprint(html.xpath(\'//ul//a/parent::*[@class=\"item-inactive\"]\'))\n\n\n# 下面这个比较复杂\n# //ul//a/.. 指的是：html 子孙 ul 子孙 a 节点的父节点：[li*5]\n# //ul//a/../* 指的是：... a 节点父节点的所有子节点（这边的例子，还是 a 节点本身）：[a*5]\n# //ul//a/../*[@class=\"item-0\"]这边指的是：以 item-inactive 为 class 的 a 节点:[]\n# 因此本例中，下面指的是以 item-inactive 为 class 的所有 li 节点：[li*1]\nprint(html.xpath(\'//ul//a/../../*[@class=\"item-inactive\"]\'))\n\n# 返回 ul 节点的 class 属性，因为 ul 节点没有 class 属性，所以返回：[]\n# 尤其注意 .. 后面不能直接使用 @ 或 [@]\nprint(html.xpath(\'//ul//a/../../@class\'))\n```\n\n###### 1.2.5文本获取、属性多值、多属性确定\n    - 代码实例\n\n```python\nfrom lxml import etree\n\n\ntext = \"\"\"\n<div>\n    <div>内部 div</div>\n    <p class=\"p-1 p-2\">你好</p>\n    <p class=\'p-3\' name=\'greet\'>我是 Jack</p>\n</div>\n\"\"\"\n\nhtml = etree.HTML(text)\n\n\"\"\" 文本获取 text() \"\"\"\n# //div 指向 html 节点下所有 div 节点；/text() 表示获取当前节点的文本值\n# 获取值按照自上而下的顺序获取\nprint(html.xpath(\'//div/text()\'))  # [\'\\n\', \'内部 div\', \'\\n\', \'\\n\', \'\\n\']\n\n# //div 指向 html 节点下的所有 div 节点；//text() 表示获取当前及子孙节点的文本值\n# 获取值按照自上而下的方式获取[\'\\n\', \'内部 div\', \'\\n\', \'你好\', \'\\n\', \'我是 Jack\', \'\\n\']\nprint(html.xpath(\'//div//text()\'))\n\n\n\n\"\"\" 属性多值 \"\"\"\n# 使用这样的表达式是获取不到指定节点的，因为该节点的 class 有两个属性\nprint(html.xpath(\'//p[@class=\"p-1\"]/text()\'))\n\n# 使用 contains 来判断属性里是否包含某个值\nprint(html.xpath(\'//p[contains(@class, \"p-1\")]/text()\'))\n\n\n\n\"\"\" 多属性匹配 \"\"\"\n# 使用 or 表示或关系\nprint(html.xpath(\'//p[contains(@class, \"p-1\") or @name=\"greet\"]/text()\'))\n\n# 使用 and 表示与关系\nprint(html.xpath(\'//p[contains(@class, \"p-3\") and @name=\"greet\"]/text()\'))\n\n\n\n\"\"\" 多个表达式取或 | \"\"\"\n# 使用 | 连接多个表达式\nprint(html.xpath(\'//p[@name=\"greet\"] | //div/div\'))\n```\n\n    - 运算符，作用于 [] 中\n\n| or | 或。多个条件取或 |\n| --- | --- |\n| and | 与。多个条件取与 |\n| mod | 算术取余。5 mod 2 = 1 |\n| | | 计算两个节点值。/p | /div |\n| + | 算术加法。1 + 1 = 2 |\n| - | 算术减法。1 - 1 = 0 |\n| * | 算术乘法。1 * 2 = 2 |\n| div | 算术除法。4 div 2 = 2 |\n| = | 相等关系。age=18 表示 age 值为 18 |\n| != | 不等关系。age != 18 表示 age 值不为 18 |\n| < | 小于关系。 |\n| <= | 小于等于关系。 |\n| > | 大于关系。 |\n| >= | 大于等于关系。 |\n\n\n###### 1.2.6 按序选择\n```python\nfrom lxml import etree\n\n\ntext = \"\"\"\n<div>\n    <a> a1 </a>\n    <p> <a> a2 </a> </p>\n    <ul>\n        <li> <a> a3 </a> </li>\n        <li> <a> a4 </a> </li>\n        <li> <a> a5 </a> </li>\n    </ul>\n    <a> a6 </a>\n</div>\n\"\"\"\n\nhtml = etree.HTML(text)\n\n# 获取所有 a 节点的文本：[\' a1 \', \' a2 \', \' a3 \', \' a4 \', \' a5 \',\' a6 \' ]\nprint(doc.xpath(\'//a/text()\'))\n\n# 若某个 a 标签在其父节点下是第 2 个 a 节点，则选中它：[\' a6 \']\nprint(doc.xpath(\'//a[2]/text()\'))\n\n# 下标越界，返回空列表：[]\nprint(doc.xpath(\'//a[-1]/text()\'))\n\n# 下标越界，返回空列表：[]\nprint(doc.xpath(\'//a[10]/text()\'))\n\n# 若某个 a 节点是其父节点下的倒数第 2 个 a 节点，则选中它：[\' a1 \']\nprint(doc.xpath(\'//a[last() - 1]/text()\'))\n\n# 若某个 a 节点在其父节点下是第 n 个 a 节点（n > 1），则选中它：[\' a6 \']\nprint(doc.xpath(\'//a[position() > 1]/text()\'))\n\n# 若某个 a 节点在其父节点下是第 n 个 a 节点（2 < n < 5），则选中它：[]\nprint(doc.xpath(\'//a[position() < 5 and position() > 2]/text()\'))\n```\n\n###### 1.2.7 节点轴\n```python\nfrom lxml import etree\n\n\ntext = \"\"\"\n<div>\n    <ul>\n        <li class=\"item-0\">\n            <a href=\"link1.html\">first item</a>\n            <span>呼哈</span>\n        </li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <div>\n            <p>嘿嘿嘿</p>\n        </div>\n    </ul>\n</div>\n\"\"\"\n\nhtml = etree.HTML(text)\n\n# ancestor::* 获取当前节点的所有祖先节点\nprint(html.xpath(\'//a[@href=\"link1.html\"]/ancestor::*\'))\n\n# ancestor::div 获取当前节点的所有祖先 div 节点\nprint(html.xpath(\'//a[@href=\"link1.html\"]/ancestor::div\'))\n\n\n# child::* 获取当前节点所有直接子节点\nprint(html.xpath(\'//a[@href=\"link1.html\"]/child::*\'))\n\n# descendant::div 获取当前节点所有子孙 div 节点\nprint(html.xpath(\'//a[@href=\"link1.html\"]/descendant::div\'))\n\n\n# following::p 获取当前节点后面的所有 p 节点，不论层次\nprint(html.xpath(\'//a[@href=\"link1.html\"]/following::p/text()\'))\n\n# following-sibling::span 获取当前节点后面的兄弟 span 节点\nprint(html.xpath(\'//a[@href=\"link1.html\"]/following-sibling::span/text()\'))\n\n# attribute::href 获取当前节点的 href 属性\nprint(html.xpath(\'//a[@href=\"link1.html\"]/attribute::*\'))\n```\n\n\n\n### 2. Beautiful Soup 库（需安装）\n##### 2.1 安装环境\n```python\n# 安装的是 beautifulsoup4\npip install beautifulsoup4\n\n# 还需要安装 lxml 库配合使用\n```\n\n##### 2.2 简单使用\n```python\nfrom bs4 import BeautifulSoup\n\ntext = \"\"\"\n<p class=\"p_1\" name=\"greet\">你好</p>\n<p id=\"username\" class=\"title_1 p_1\">Luyan</p>\n<div>\n    <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    </ul>\n</div>\n\"\"\"\n\n# 使用 lxml 作为解析器构造 BeautifulSoup 对象\n# 这也会补充缺失的节点，包括不闭合的和html、body\nsoup = BeautifulSoup(text, \"lxml\")\n\n# 调用 soup.prettify() 将网页内容格式化（带换行缩进）\nprint(soup.prettify())\n```\n\n##### 2.3 提取信息\n###### 2.3.1 获取文本\n```python\n# soup 默认情况下指向“根”，不是最外层节点哦。\n# 但是打印的时候，因为打印的是自己和子孙节点，所以和打印 html 节点没啥区别。\nprint(soup)\n\n\n# 使用 . 的方式查找节点，是在当前节点的子孙节点里面查找，自己不算哦。\n# 所以下面表示：从“根”的子孙里面找 p 节点。若有多个则返回第 1 个；若没有返回 None。\nprint(soup.p)\n\n\n# 返回当前标签的名称：p\nprint(soup.p.name)\n\n\n# 返回找到的第一个 p 节点的文本值：你好\n# 若是没找到对应节点，这样调用是要报错的。因为 None.string 是什么玩意？\n# 更奇葩的是：若是当前节点有子标签，则 .string 都是返回 None。\nprint(soup.p.string)\n\n\n# 最后的 name 是关键字，表示获取节点名称。\n# 因此 name 被拦截了，即使 body 下面真有一个 name 节点也是访问不到的。\nprint(soup.html.body.name)\n```\n\n###### 2.3.2 获取属性\n```python\n# 获取 p 节点的所有属性，是一个字典\n# {\'class\': [\'p_1\'], \'name\': \'greet\'}\nprint(soup.p.attrs)\n\n\n# 获取 p 节点的 class 属性，其实就是访问字典嘛\n# 因为 class 属性可能有多个值，所以返回一个字符串列表：[\'p_1\']\nprint(soup.p.attrs[\'class\'])\n\n\n# 获取 p 节点的 class 属性，简写\n# 同样的返回一个字符串列表：[\'p_1\']\nprint(soup.p[\'class\'])\n\n\n# 获取 p 节点的 name 属性\n# 因为 name 属性只能有一个值，所以返回一个字符串：greet\nprint(soup.p[\'name\'])\n\n\n# 上面不论哪种取值方案，都是从字典取值，若是 key 不存在，会抛异常\n# 使用 get 方法获取属性，若是找不到则返回自己定义的默认值，未指定默认值返回 None\nprint(soup.p.get(\'id\', \'Not Found\'))\n```\n\n###### 2.3.3 关联选择\n```python\ntext = \"\"\"\n<p class=\"p_1\" name=\"greet\">\n    你好\n    <span>\n        <a href=\"#\">Luyan</a>\n    </span>\n</p>\n<div>\n    <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    </ul>\n</div>\n\"\"\"\n\n# 获取所有直接子节点，返回一个列表\n# 注意，若是本节点里面有文本，那此文本也在返回的列表中\n# 文本在列表中是字符串类型；节点在列表中是 Tag 类型，可以继续链式调用。\nprint(soup.p.contents)\n\n# 和上面一样，获取当前节点的所有直接子节点。\n# 但返回的不是一个列表，而是生成器类型。\nprint(soup.p.children)\n\n# 获取当前节点的所有子孙节点，返回一个生成器\nprint(soup.p.descendants)\n\n\n\n# 返回当前节点的父节点。因为父节点只会有一个，所以返回一个 Tag 类型\nprint(soup.p.parent)\n\n# 返回当前节点的所有祖先节点，返回一个生成器\n# 尤其注意：html 节点的父节点是“根”，而“根”打印出来和 html 节点是一致的\n# 所以下面 p 的祖先节点有：body，html，“根”（和 html 表现形式是一致的）\n# 因此，找祖先节点的时候，看起来最后两个重复了\nprint(soup.p.parents)\n\n\n\n# 返回当前节点的下一个兄弟节点，返回一个 Tag 类型\nprint(soup.p.next_sibling)\n\n# 返回当前节点后面的所有兄弟节点，返回一个生成器\nprint(soup.p.next_siblings)\n\n# 返回当前节点的上一个兄弟节点，返回一个 Tag 类型\nprint(soup.p.previous_sibling)\n\n# 返回当前节点前面的所有兄弟节点，返回一个生成器\nprint(soup.p.previous_siblings)\n```\n\n###### 2.3.4 方法选择器\n```python\n\"\"\"find_all(name, attrs, recursive, text, **kwargs)\n    解释：从当前节点的子孙节点中找满足条件的所有节点\n\n    name: 要寻找的标签名字，是一个字符串类型\n    attrs: 要具备某些属性，是一个字典\n    text: 要匹配的文本，可以是字符串也可以是正则对象\n    \n    注意：下面的说的列表其实是 bs4.element.ResultSet 类型，但和列表使用没啥两样\n\"\"\"\n# 找“根”的所有子孙节点，没有限制条件\nprint(soup.find_all())\n\n# 从“根”的子孙中找所有 li 节点，返回一个列表\nprint(soup.find_all(name=\'li\'))\n\n# 返回第一个 div 下面的所有 a 节点列表\nprint(soup.div.find_all(name=\'a\'))\n\n# 从“根”的子孙中找所有具有 href 属性且属性值为 # 的节点列表\nprint(soup.find_all(attrs={\'href\': \'#\'}))\n\n# 从“根”的子孙中找所有 id 为 link 的节点列表\nprint(soup.find_all(id=\'link\'))\nprint(soup.find_all(attrs={\'id\': \'link\'}))\n\n# 返从“根”的子孙中找所有 class 中包含 p_1 的节点列表，注意是包含\nprint(soup.find_all(class_=\'p_1\'))\nprint(soup.find_all(attrs={\'class\': \'p_1\'}))\n\n# 从“根”的子孙中找所有 class 等于 p_1 p_2 的节点列表，注意是等于（顺序、值完全等于的等于）\nprint(soup.find_all(class_=\'p_1 p_2\'))\nprint(soup.find_all(attrs={\'class\': \'p_1 p_2\'}))\n\n\n# 使用正则匹配当前节点及子孙节点的文本，返回能匹配的文本字符串列表\n# 1. 匹配看的是文本内容；2. 返回的是字符串列表\nprint(soup.find_all(text=re.compile(\'u\')))\n\n# 若当前节点或子孙节点有文本内容完全等于传入的字符串，则返回这些文本字符串列表\n# ps：我都传进去了，完全匹配你才返回，有毛病吧？最多用来统计你传入的字符串出现了几次\nprint(soup.find_all(text=\'u\'))\n\n\n\n\"\"\"其他相同用法方法：\n    find(): 从当前节点的子孙节点中找第一个满足条件的节点，返回 Tag 类型\n    \n    find_parent(): 层级从里到外，找第一个满足条件的祖先节点，返回 Tag 类型\n    find_parents(): 找所有满足条件的祖先节点，返回一个 Tag 列表\n    \n    find_next_sibling(): 往后找一个满足条件的兄弟节点，返回 Tag 类型\n    find_next_siblings(): 往后找所有满足条件的兄弟节点，返回一个 Tag 列表\n    \n    find_previous_sibling(): 往前找一个满足条件的兄弟节点，返回 Tag 类型\n    find_previous_siblings(): 往前找所有满足条件的兄弟节点，返回一个 Tag 列表\n    \n    find_next(): 往后找一个满足条件的节点，返回 Tag 类型\n    find_all_next(): 获取当前节点后面所有满足条件的节点，返回一个 Tag 列表\n    \n    find_previous(): 往前找一个满足条件的节点，返回 Tag 类型\n    find_all_previous(): 获取当前节点前面所有满足条件的节点，返回一个 Tag 列表\n\"\"\"\n```\n\n###### 2.3.5 CSS 选择器\n```python\n\"\"\"select()\n    解释：从当前节点的子孙节点中找满足条件的所有节点\n\"\"\"\n\n# 从第一个 p 节点下按照 CSS 选择器寻找满足条件的节点，返回一个 Tag 列表\nprint(soup.p.select(\'#link a\'))\n```\n\n\n\n### 3. pyquery 库（需安装，CSS 专业户）\n##### 3.1 初始化\n###### 3.1.1 字符串初始化\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<p class=\"p_1 p_2 p_3\" name=\"greet\">\n    你好\n    <span id=\"link\" class=\"p_1\">\n        <h1>A上</h1>\n        <a href=\"#\">Luyan</a>\n        <h1>A下</h1>\n    </span>\n</p>\n<div class=\"p_1\">\n    <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    </ul>\n</div>\n\"\"\"\n\n# 使用字符串构造 PyQuery 对象\ndoc = pq(html)\n\nprint(doc)\n```\n\n###### 3.1.2 URL 初始化\n```python\nfrom pyquery import PyQuery as pq\n\n\n# 也可以直接使用一个 URL 构造 PyQuery 对象\ndoc = pq(url=\'https://cuiqingcai.com\')\n\nprint(doc)\n```\n\n###### 3.1.3 文件初始化\n```python\nfrom pyquery import PyQuery as pq\n\n\n# 也可以读取本地 html 文件来初始化\ndoc = pq(filename=\'demo.html\')\n\nprint(doc)\n```\n\n###### 3.1.4 修复标签\n1. 未闭合的标签必然会修复完整\n2. 若是没有 html、body 标签则：\n    1. 若是从 html 文件读取，则会补充完整。因为这样系统知道，这是 html，所以会补充完整\n    2. 若是从字符串读取，则不会补充。因为系统不知道这是 html 还是普通 xml，因此不会修复\n3. 若是字符串读取且有多个根节点，则会看情况修复\n    1. 都是行级元素，会在最外面套一个 <span>\n    2. 有块级元素，会在最外面套一个 <div>\n\n```python\n\"\"\"场景 a：\n原 html 代码：\n<a>a1</a>\n<a>a2</a>\n\n修复后：\n<span>\n    <a>a1</a>\n    <a>a2</a>\n</span>\n\"\"\"\n\n\n\"\"\"场景 b：\n原 html 代码：\n<a>a1</a>\n<p>p</p>\n\n修复后：\n<div>\n    <a>a1</a>\n    <p>p</p>\n</div>\n\"\"\"\n```\n\n##### 3.2 范围使用 CSS 选择器\n###### 3.2.1 全局查找\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<p class=\"p_1 p_2 p_3\" name=\"greet\">\n    你好\n    <span id=\"link\" class=\"p_1\">\n        <h1>A上</h1>\n        <a href=\"#\">Luyan</a>\n        <h1>A下</h1>\n    </span>\n</p>\n<div id=\"div_1\" class=\"p_1\">\n    <ul>\n        <li class=\"item-0\">\n            <a href=\"link1.html\">first item</a>\n            <span>span</span>\n            li\n        </li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    </ul>\n</div>\n\"\"\"\n\n# 利用指定字符串构造 PyQuery 对象\ndoc = pq(html)\n\n# 输出所有 p 节点及其对应子孙节点的文本\n# 你好\\nA上\\nLuyan\\nA下\nprint(doc(\'p\').text())\n\n# 输出所有 li 节点及其子孙节点的文本\n# first item span li second item third item fourth item fifth item\nprint(doc(\'li\').text())\n\n\n# 输出根据CSS选择器选中的第一个 li 节点内部的html代码\nprint(doc(\'#div_1 li\').html())\n\n# 输出上例中所有 li 节点内部的 html 代码\nfor item in doc(\"#div_1 li\").items():\n    print(item.html())\n    \n    \n    \n\"\"\"科普时间到\n    全局查找 p 标签使用：doc(\'p\')\n    问：doc(\'p\') 与 doc.find(\'p\') 有什么关系？\n    答：doc(\'p\') 与 doc.find(\'p\') 基本等价。\n        但有一点不同，doc(\'p\') 这种方式从自己和自己的子孙之中进行查找，\n        而 doc.find(\'p\') 只从自己的子孙里进行查找。\n    \n    问：为什么说 doc(\'p\') 是全局查找 p 标签？\n    答：其实 doc 是一个指向整个 html 最外层节点的 PyQuery 对象。\n        结合上面的答案，doc(\'p\') 从自己和自己的子孙里查找 p，所以算是全局查找。\n    \n    你要是不相信上面的问答，你可以试试：\n    print(doc(\'li\')(\'p\'))  # 这是找不到的\n    print(doc(\'li\')(\'a\'))  # 这个可以找到\n\"\"\"\n```\n\n###### 3.2.2 从子孙里查找\n```python\ndoc = pq(html)  # PyQuery 对象\n\n# 获取 ul 节点，类型也是 PyQuery 对象\nitem = doc(\'ul\')\n\n# 从 ul 节点的子孙里找满足选择器的节点，显然是找不到的\nprint(item.find(\'#link h1\').text())\n\n\n\n# 获取 div 节点，类型也是 PyQuery 对象\nitem = doc(\'div\')\n\n# 从 div 节点的子孙里找满足选择器的节点，找到了\n# 有人问：为啥找到了？很显然下面选择器的匹配结果应当在 p 节点下面，不在 div 下面啊\n# 我来答：因为这个字符串有两个根节点，且根节点里面有块级元素。所以构造的时候默认添加一个 div\nprint(item.find(\'#link h1\').text())\n\n\n\"\"\"\n    注意：find 方法里面的 CSS选择器参数是不能省略的\n\"\"\"\n```\n\n###### 3.2.3 从直接子节点查找\n```python\ndoc = pq(html)\n\n# 找以 p_1 为 class 的节点，其实就是 p 节点\nitem = doc(\'.p_1\')\n\n# 从 item 的直接子节点中找满足条件的，很明显找到了\nprint(item.children(\'#link h1\').text())\n\n\n\n# 找 div 节点，这会找到两个。一个是最外层系统加的；另一个是自己定义的\nitem = doc(\'div\')\n\n# 从 item 的直接子节点中找满足条件的，很明显找不到。\n# 因为不管哪个 div 节点，都没有满足条件的儿子节点。\nprint(item.children(\'#link h1\').text())\n\n\n\"\"\"children 方法里面CSS选择器参数可以省略，这样表示获取所有子节点\"\"\"\n```\n\n###### 3.2.4 从直接父节点查找\n```python\ndoc = pq(html)\n\nitem = doc(\'#link\')\n\n# 获取该节点的直接父节点\nprint(item.parent())\n\n# 获取 id 为 ss 的直接父节点\n# 若是父节点 id 不对，那就找不到\nprint(item.parent(\'#ss\'))\n```\n\n###### 3.2.5 从祖先节点查找\n```python\ndoc = pq(html)\n\nitem = doc(\'#link\')\n\n# 获取该节点的所有祖先节点\nprint(item.parents())\n\n# 获取 class 为 p_1 的祖先节点\nprint(item.parents(\'.p_1\'))\n```\n\n###### 3.2.6 从兄弟节点查找\n```python\ndoc = pq(html)\n\nitem = doc(\'li.item-inactive\')\n\n# 找当前节点所有兄弟节点，不论前后\nprint(item.siblings())\n\n# 使用CSS选择器限制兄弟节点\nprint(item.siblings(\'.item-0\'))\n```\n\n##### 3.3 节点访问\n###### 3.3.1 节点的遍历\n通过CSS选择器选中的节点，可能有0，1和多个。他们都返回一个 PyQuery 对象，因此遍历是必要的。\n\n```python\nitem = doc(\'li.item-inactive\')\nprint(item.text())  # 若节点唯一，则可以使用 text 方法输出对应文本\n\n\n# text = 自己的文本值 + 子孙的文本值\n# 返回 text。注意文本是按照先后顺序拼接的，不同标签的文本用空格分开\nprint(doc(\'li\').text())\n\n\n# 调用 items() 返回一个生成器，可以这样访问多个节点\nfor item in doc(\'li\').items():\n    print(item.text())\n```\n\n###### 3.3.2 获取节点属性\n```python\nitem = doc(\'li.item-inactive\')\nprint(item.attr(\'class\'))  # 若节点唯一，则可以使用 attr 方法输出对应属性\n\n\nitem = doc(\'li\')\nprint(item.attr(\'class\'))  # 若节点不唯一，这样做返回的是第一个节点的 class 属性\n\n\n# 多节点需要循环遍历属性\nfor item in doc(\'li\').items():\n    print(item.attr(\'class\'))\n    \n    \n\"\"\"注意：attr() 方法里面的参数不可省略\"\"\"\n\n\n# 访问属性还能这样玩\nfor item in doc(\'a\').items():\n    print(item.attr.href)  # 直接通过属性的方式来访问\n\nitem.attr.class_  # 对于 class 属性，因为是关键字，所以也使用 class_ 代替\n```\n\n###### 3.3.3 获取节点内的网页代码\n```python\nprint(doc(\'p\').html())  # 若节点唯一，则可以使用 html 方法输出其内部的网页代码\n\n\n# 若节点不唯一，这样做返回的是第一个节点的内部网页代码\nprint(doc(\'li\').html())\n\n\n# 调用 items() 返回一个生成器，可以这样访问多个节点\nfor item in doc(\'li\').items():\n    print(item.html())\n```\n\n##### 3.4 节点操作\n###### 3.4.1 addClass 和 removeClass\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<div>\n    这是 DIV\n    <p>这是 P</p>\n</div>\n\"\"\"\n\ndoc = pq(html)\n\n# 获取 div 节点\ndiv = doc(\'div\')\n\n# 为 div 节点添加一个 d_1 类\ndiv.addClass(\'d_1\')\n\nprint(doc(\'div\'))  # 添加可不是只给那个变量添加，是这个节点添加了\n\n# 删除一个 class\ndiv.removeClass(\'d_1\')\nprint(doc(\'div\'))\n```\n\n###### 3.4.2 属性操作\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<div>\n    这是 DIV\n    <p>这是 P</p>\n</div>\n\"\"\"\n\ndoc = pq(html)\n\ndiv = doc(\'div\')\nprint(div.attr(\'name\'))  # 获取 name 属性\n\ndiv.attr(\'name\', \'div_name\')  # 因为此时不存在 name 属性，所以是添加属性\nprint(div.attr(\'name\'))\n\ndiv.attr(\'name\', \'div_name_2\')  # 因为此时 name 属性已经存在，所以是修改属性\nprint(div.attr(\'name\'))\n\ndiv.attr(\'name\', \'\')  # 将 name 属性置空\nprint(div.attr(\'name\'))\n```\n\n###### 3.4.3 内容操作\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<div>\n    这是 DIV\n    <p>这是 P</p>\n</div>\n\"\"\"\n\ndoc = pq(html)\n\ndiv = doc(\'div\')\n\ndiv.text(\'你好\')  # 将标签内所有内容替换成指定文本\nprint(div)  # 结果：<div>你好</div>。显而易见，内部的 p 标签也没了\n\ndiv.text(\'<a>这是一个链接</a>\')  # 试图将一个html标签塞进去，但是会失败\nprint(div)  # 结果：<div>&lt;a&gt;这是一个链接&lt;/a&gt;</div>\n\n\ndiv.html(\'<a>这是一个链接</a>\')  # 要是想塞标签，显然应该调用 html 方法啊\nprint(div)  # 结果：<div><a>这是一个链接</a></div>\n\n\n\"\"\"\n    text() 方法用来读取节点内文本；\n    text(\'content\') 方法用来塞文本进入节点\n    \n    \n    html() 方法用来读取节点内 html 代码；\n    html(\'</>\') 方法用来塞标签进入节点\n\"\"\"\n```\n\n###### 3.4.5 节点删除\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<div>\n    这是 DIV\n    <p>这是 P</p>\n    <span>SPAN</span>\n</div>\n\"\"\"\n\ndoc = pq(html)\n\ndiv = doc(\'div\')  # 找到 div 节点\n\n\n# 删除 div 节点下的 p 和 span 节点\n# 但是注意，是不可以删除最外层节点的。不会报错，但是删除不会成功\n# 这个方法可以返回删除掉的 PyQuery 对象\ndel_node = div(\'p, span\').remove()\nprint(doc)  # <div>这是 DIV</div>\n\n\ndiv.empty()  # 清空 div 节点下面的所有内容\n```\n\n###### 3.4.6 节点添加\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<div>\n    这是 DIV\n    <p>这是 P</p>\n    <span>SPAN</span>\n</div>\n\"\"\"\n\ndoc = pq(html)\n\ndiv = doc(\'div\')  # 找到 div 节点\n\n# 往 div 节点最后添加文本\ndiv.append(\'你好\')\n\n# 往 div 节点最后添加一个标签\ndiv.append(\'<a>你好</a>\')\nprint(doc)\n\n\n# 往 div 节点最前面添加文本\ndiv.prepend(\'你好\')\n\n# 往 div 节点最前面添加一个标签\ndiv.prepend(\'<a>你好</a>\')\nprint(doc)\n```\n\n##### 3.5 伪类选择器\n```python\nfrom pyquery import PyQuery as pq\n\n\nhtml = \"\"\"\n<a>a1</a>\n<ul>\n    <a>a2</a>\n    <li><a>a3</a></li>\n    <li><a>a4</a></li>\n    <li><a>a5</a></li>\n    <a>a6</a>\n</ul>\n<a>a7</a>\n\"\"\"\n\ndoc = pq(html)\n\n\n# 选取所有 a 节点\n# 紧跟着这个 a 节点的文本也会被选中\n# 对于这样的 html：<div><a>a tag</a>你好</div>\n# 获取 doc(\'a\') 结果是：<a>a tag</a>你好\n# 简直神奇\nprint(doc(\'a\'))\n\n\n# 若某个 a 节点是它所在父节点下的第一个节点，则会选中它，文本不算节点。\n# 这边能选中的元素有：a1, a2, a3, a4, a5\n# a1 是最外层 div 的首个子节点，故选中。a2 是 ul 节点的首个子元素，故选中。\n# a3, a4, a5 都是 li 节点的首个子元素，故选中\nprint(doc(\'a:first-child\'))\n\n\n# 若某个 a 节点是它所在父节点下的最后一个节点，则会选中它，文本不算节点。\n# 这边能选中的元素有：a3, a4, a5, a6, a7。它们都是对应父节点的最后一个元素。\nprint(doc(\'a:last-child\'))\n\n\n# 若某个 a 节点是它所在父节点下的第 3 个节点，则会选中它，文本不算节点。\n# 这边能选中的元素有：a7。只有 a7 是其父节点下的第 3 个节点\nprint(doc(\'a:nth-child(3)\'))\n\n\n# 这是一个线性公式，将 n = 0, 1, 2... 带入，发现所选下标是：1，3，5...\n# 若某个 a 节点是它所在父节点下的第 1, 3, 5... 个节点，则会选中它，文本不算节点。\n# 这边能选中的元素有：a1, a2, a3, a4, a5, a6, a7，每一个都是其所在父节点下的奇数下标子节点\nprint(doc(\'li:nth-child(2n+1)\'))\n\n\n# 这是一个线性公式，将 n = 0, 1, 2... 带入，发现所选下标是：0，2，4...\n# 若某个 a 节点是它所在父节点下的第 2, 4, 6... 个节点，则会选中它，文本不算节点。\n# 因为，所有 a 节点都是奇数下标，所以偶数下标选取不到\nprint(doc(\'li:nth-child(2n)\'))\n\n\n# 选取当前或子孙节点内文本包含 sss 的 li 节点\nprint(doc(\'li:contains(sss)\'))\n```\n\n##### 3.6 常见 CSS 选择器\n| **选择器** | **含义** |\n| --- | --- |\n| * | 选择所有元素 |\n| #id | 选择指定 id 的元素 |\n| .class | 选择指定 class 的元素 |\n| element | 选择指定标签。如 p 表示选择所有 p 标签 |\n| selector1, selector2 | 选择多个。如 div, p 表示选择所有 div 标签和 p 标签 |\n| selector1 selector2 | 从 selector1 的子孙里找 selector2。<br/>如 ul a 表示选择所有 ul 标签下的 a 标签 |\n| selector1>selector2 | 从 selector1 的直接子元素里找 selector2。<br/>如 ul a 表示选择所有父节点是 ul 的 a 标签 |\n| selector1+selector2 | 查找紧跟着 selector1 的兄弟 selector2 节点。<br/>注意：<br/>1. selector1 和 selector2 是兄弟<br/>2. selector2 必须紧跟着 selector1 |\n| selector1~selector2 | 查找 selector1 后面所有兄弟 selector2 节点。<br/>注意：<br/>1. selector1 和 selector1 是兄弟<br/>2. selector2 位于 selector1 的后面 |\n| [attr] | 选择带有某个属性的所有标签。<br/>如 [href] 表示选择所有定义了 href 属性的节点 |\n| [attr=val] | 选择属性 attr 值等于 val 的所有标签。<br/>如 [href=#] 表示 href 属性值等于 # 的所有元素 |\n| [attr^=val] | 选择属性 attr 值以 val 开头的所有标签。<br/>如 [href^=https] 表示 href 属性值以 https 开头的所有元素 |\n| [attr$=val] | 选择 attr 属性以 val 结尾的所有标签。<br/>如 [name$=md] 表示 name 属性值以 md 结尾的所有元素 |\n| [attr*=val] | 选择 attr 属性值内包含 val 的所有标签。<br/>如 [name*=me] 表示 name 属性值内包含 me 的所有元素 |\n\n\n\n\n### 4. parsel 库（需安装）\n##### 4.1 初始化\n```python\nfrom parsel import Selector\n\nhtml = \"\"\"\n<div>\n    <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n    </ul>\n</div>\n\"\"\"\n\n# 使用字符串初始化 Selector 对象\n# 会自己添加 html、body 标签\nselector = Selector(text=html)\n\n# 通过 css选择器获取元素\nitems = selector.css(\'.item-0\')\nprint(len(items))  # 获取选取到多少个元素\nprint(items)\n\n# 通过 xpath 获取元素\nitems = selector.xpath(\'//li[@class=\"item-0\"]\')\nprint(\'\\n\\n\\n\', items)\n```\n\n##### 4.2 文本提取\n```python\nfrom parsel import Selector\n\nhtml = \"\"\"\n<div>\n    <a> a1 </a>\n    <p> demoP </p>\n    <p> pb <a> a2 </a> pe </p>\n    <ul id=\'ul\'>\n        <li> <a> a3 </a> </li>\n        <li> <a> a4 </a> </li>\n        <li> <a> a5 </a> </li>\n    </ul>\n    <a> a6 </a>\n</div>\n\"\"\"\n\nselector = Selector(html)\n\n# 查询所有 a 标签，返回一个 SelectorList\nprint(selector.xpath(\'//a\'))\n# 查询所有 a 标签的文本，返回一个 SelectorList\nprint(selector.xpath(\'//a/text()\'))\n\n\n# 查询所有 a 标签，返回查到的第一个 a 标签代码（字符串）\nprint(selector.xpath(\'//a\').get())  # <a> a1 </a>\n# 查询所有 a 标签的文本，返回查到的第一个 a 标签文本（字符串）\nprint(selector.xpath(\'//a/text()\').get())  #  a1 \n\n\n# 查询所有 a 标签，返回所有 a 标签代码组成的字符串列表\nprint(selector.xpath(\'//a\').getall())\n# 查询所有 a 标签，返回所有 a 标签文本组成的字符串列表\nprint(selector.xpath(\'//a/text()\').getall())\n\n\n# 查询不存在的节点返回一个空的 SelectorList\nprint(selector.xpath(\'//span\'))\nprint(selector.xpath(\'//span/text()\'))\n\n\n# 对不存在的节点列表使用 get 返回 None\nprint(selector.xpath(\'//span\').get())\n# 对不存在的节点列表使用 getall 返回空列表 []\nprint(selector.xpath(\'//span\').getall())\n\n\n# 使用 css 选择器获取文本的写法\nprint(selector.css(\'p::text\'))\n```\n\n##### 4.3 获取属性\n属性的获取和上面的文本获取类似\n\n```python\n# 使用 css 选择器获取 ul 标签的 id 属性\nprint(selector.css(\'ul::attr(id)\'))\n\n\n# 使用 xpath 选择器获取 ul 标签的 id 属性\nprint(selector.xpath(\'//ul/@id\'))\n```\n\n##### 4.4 使用正则匹配\n```python\n# 使用正则匹配所有 a 标签。如果正则里面有分组，则返回的都是分组信息\nprint(selector.re(re.compile(r\'<a>(.*?)</a>\', re.S)))\n\n# 使用正则匹配 ul 标签下面的 a 标签\nprint(selector.css(\'ul\').re(re.compile(r\'<a>(.*?)</a>\', re.S)))\n\n# 使用正则匹配 ul 标签下第一个 a 标签\nprint(selector.css(\'ul\').re_first(re.compile(r\'<a>(.*?)</a>\', re.S)))\n```\n\n'),
       (8, 8, '### 1. 协程\n##### 1.1 简单使用\n```python\n# 需要这个包的支持\nimport asyncio\n\n\n# 定义函数前加上 async 关键字，那这个函数就变成协程函数了\nasync def execute(x):\n    print(x)\n\n# execute 函数的返回值是一个协程对象\ncoroutine = execute(1)\n\n# 获取事件循环\nloop = asyncio.get_event_loop()\n\n# 将协程对象注册到事件循环上。这样这个协程函数才会真正执行\nloop.run_until_complete(coroutine)\n```\n\n##### 1.2 将协程对象封装成 Task 对象\nTask 对象可以获取当前协程的运行状态，还可以获取协程函数的返回值。\n\n```python\nimport asyncio  # 需要这个包\n\n# 一样定一个一个协程函数，但是有返回值\nasync def execute(x):\n    print(x)\n    return x\n\n# 执行协程函数得到协程对象\ncoroutine = execute(1)\n\n# 通过 asyncio.ensure_future 方法包装协程对象为 Task 对象\ntask = asyncio.ensure_future(coroutine)\n\n# 一样获取事件循环\nloop = asyncio.get_event_loop()\n\n# Task 对象也可以使用事件循环来创建\n# task = loop.create_task(coroutine)\n\n# 注册 Task 对象到事件循环上\nloop.run_until_complete(task)\n\n# 还可以获取协程函数的返回值，没有返回值就是 None\n# 但是一定等到任务被执行后才能获取，否则没有result会报错\nprint(task.result())\n```\n\n##### 1.3 绑定回调\n```python\nimport asyncio\n\n# 协程函数\nasync def execute(x):\n    print(x)\n    return x\n\n# 回调函数，接受一个 Task 对象\ndef callback(task):\n    print(f\'Get {task.result()}\')\n\n# 获取协程对象\ncoroutine = execute(1)\n\n# 封装成 Task 对象\ntask = asyncio.ensure_future(coroutine)\n\n# 为 Task 绑定执行完毕后的回调\ntask.add_done_callback(callback)\n\n# 获取事件循环\nloop = asyncio.get_event_loop()\n\n# 执行这个 task\nloop.run_until_complete(task)\n\n# 一样可以获取到协程函数的返回值\nprint(task.result())\n```\n\n##### 1.4 多任务协程\n```python\nimport asyncio\n\n# 协程函数\nasync def execute(x):\n    return x ** 2\n\n# 执行完毕回调\ndef callback(task):\n    print(task.result())\n\n\ndef main():\n    tasks = []\n    # 生成多个绑定了回调的 task 对象\n    for i in range(1, 6):\n        t = asyncio.ensure_future(execute(i))\n        t.add_done_callback(callback)\n        tasks.append(t)\n        \n    # 获取事件循环\n    loop = asyncio.get_event_loop()\n    \n    # 使用 asyncio.wait 将多个任务绑定到事件循环上\n    # 不要以为这样就是异步执行多个任务了，里面的每个任务都是同步执行的，坑爹\n    loop.run_until_complete(asyncio.wait(tasks))\n\n\nif __name__ == \'__main__\':\n    main()\n```\n\n##### 1.5 异步请求\n###### 1.5.1 背景\n有一个网站：[https://www.httpbin.org/delay/5](https://www.httpbin.org/delay/5)，访问这个网站需要5秒才会有返回结果。现在需要访问10次，那就需要50秒，那还得了？所以我们使用协程来写异步访问，每次访问请求发出后，就执行下一个请求。这样10个请求差不多也就5秒等待时间，甚至理论上排除干扰的选项外，1000个访问也只等待5秒，这不逆天？\n\n###### 1.5.2 吐槽 requests\n```python\nimport asyncio\nimport requests\n\n\nasync def get(url):\n    print(\'Get the request: {}\'.format(url))\n    \n    # 说过多少遍了，requests 是同步请求。你这样写，下面使用100个协程也是白搭。\n    # 第二个协程要想执行，那第一个协程必须执行完毕或被挂起。\n    # 下面的写法，第二个协程需要等第一个协程访问结束才会开始，那协程有什么用？\n    # resp = requests.get(url)\n    \n    \n    # 使用 await 关键字表示这个动作需要被挂起，这样请求期间就可以运行后面的协程了。\n    # 看样子似乎可以异步请求了，美滋滋。但 requests 不支持 await 关键字修饰。\n    resp = await requests.get(url)\n    print(\'Request succeed: {}\'.format(url))\n    return resp\n\n\ndef main():\n    url = \'https://www.httpbin.org/delay/5\'\n    tasks = [asyncio.ensure_future(get(url)) for _ in range(10)]\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(asyncio.wait(tasks))\n\n\nif __name__ == \'__main__\':\n    main()\n\n```\n\n###### 1.5.3 赞美 aiohttp\n```python\nimport asyncio\nimport aiohttp\n\n\nasync def get(url):\n    print(\'Get the request: {}\'.format(url))\n    session = aiohttp.ClientSession()\n    \n    # 但是！！！aiohttp 支持 await，简直 nice 啊\n    resp = await session.get(url)\n    await session.close()  # 关 session\n    print(\'Request succeed: {}\'.format(url))\n    return resp\n\n\ndef main():\n    url = \'https://www.httpbin.org/delay/5\'\n    tasks = [asyncio.ensure_future(get(url)) for _ in range(10)]\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(asyncio.wait(tasks))\n\n\nif __name__ == \'__main__\':\n    main()\n```\n\n\n\n### 2. aiohttp 使用（需安装）\n##### 2.1 基本使用\n```python\n# 导入协程包和aiohttp\nimport asyncio\nimport aiohttp\n\n\n# 定义一个协程函数\nasync def get(url):\n    # 注意，异步操作里面的 with as 块也要用 async 修饰\n    async with aiohttp.ClientSession() as session:\n        # 关于 await 关键字使用：所有返回协程对象的语句前面都要使用 await 关键字修饰\n        resp = await session.get(url)\n        \n        # 一样的，因为 resp.text() 函数返回一个协程对象，所以需要 await 修饰\n        # 但是 resp.status 只是返回一个整数，所以不需要使用 await\n        print(str(await resp.text())[:100], resp.status)\n\n        \n# 获取事件循环\nloop = asyncio.get_event_loop()\n\n# 执行协程\nloop.run_until_complete(get(\'https://cuiqingcai.com\'))\n```\n\n##### 2.2 携带参数\n```python\nimport asyncio\nimport aiohttp\n\n\nasync def get(url, params):\n    async with aiohttp.ClientSession() as session:\n        # 请求的时候，直接给 params 参数传进去一个字典就可以了\n        resp = await session.get(url, params=params)\n        \n        print(await resp.text(), resp.status)\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(get(\'https://www.httpbin.org/get\', {\'name\': \'Luyan\'}))\n```\n\n##### 2.3 POST 请求\n```python\nimport asyncio\nimport aiohttp\n\n\nasync def post(url, params):\n    async with aiohttp.ClientSession() as session:\n        # 使用 post 方法，并直接传一个字典到 data 参数里面就可以直接上传了。\n        # 对应信息会进入表单域，也很简单。\n        resp = await session.post(url, data=params)\n        \n        # json 格式字符串提交，不需要手动将数据转化成 json 字符串并传到 data 参数里面\n        # 可以直接将字典传到 json 参数里面\n        resp = await session.post(url, json=params)\n        print(await resp.text(), resp.status)\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(post(\'https://www.httpbin.org/post\', {\'name\': \'Luyan\'}))\n```\n\n##### 2.4 响应\n```python\nimport asyncio\nimport aiohttp\n\n\nasync def post(url, params):\n    async with aiohttp.ClientSession() as session:\n        resp = await session.post(url, data=params)\n        print(\'status_code: \', resp.status)  # 响应码\n        print(\'headers: \', resp.headers)  # 响应头\n        print(\'text: \', await resp.text())  # 返回文本\n        print(\'bytes: \', await resp.read())  # 返回二进制数据，爬文件使用\n        print(\'json: \', dict(await resp.json()))  # 将返回文本转化成字典类型\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(post(\'https://www.httpbin.org/post\', {\'name\': \'Luyan\'}))\n```\n\n```python\nimport asyncio\nimport aiohttp\n\n# 简单爬取图片的示例\nasync def get(url):\n    async with aiohttp.ClientSession() as session:\n        resp = await session.get(url)\n        \n        # 打开文件不支持异步，所以不能使用 async 修饰\n        with open(\'/Users/luyan/Desktop/demo.jpg\', \'wb\') as f:\n            f.write(await resp.read())\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(get(\'imgsrc\'))\n```\n\n##### 2.5 超时\n```python\n# 定义超时对象，这边设置为 5 秒\ntimeout = aiohttp.ClientTimeout(total=5)\n\n# 在定义 session 的时候传入超时对象\nasync with aiohttp.ClientSession(timeout=timeout) as session:\n    pass\n\n# 如果请求真的超时了，会抛出 aiohttp.ServerTimeoutError 异常，自己捕获一下\n```\n\n##### 2.6 并发限制\n使用 aiohttp 可以同时异步请求很多次，很可能会给服务器带来压力。所以需要限制，一次请求多少次。\n\n```python\nimport asyncio\nimport aiohttp\n\n# 通过同步锁来限制每次最多请求 5 次\nsemaphore = asyncio.Semaphore(5)\n\n\nasync def get(index):\n    # 执行的代码放在 semaphore 里面\n    async with semaphore:\n        print(f\'Begin with {index}\')\n        await asyncio.sleep(1)  # 强行延迟每次请求的时间，便于观察\n        async with aiohttp.ClientSession() as session:\n            resp = await session.get(\'https://www.baidu.com\')\n            print(resp.status)\n\n\ntasks = [asyncio.ensure_future(get(i)) for i in range(1, 101)]\nloop = asyncio.get_event_loop()\n\n# 下面的两种方式都可以执行多个协程\n# loop.run_until_complete(asyncio.wait(tasks))\nloop.run_until_complete(asyncio.gather(*tasks))\n```\n\n##### 2.7 代理\n```python\nimport asyncio\nimport aiohttp\n\n\nurl = \'https://www.httpbin.org/get\'\nproxy = \'http://127.0.0.1:7890\'\n\n\nasync def main():\n    async with aiohttp.ClientSession() as session:\n        # 请求的时候传入代理地址就可以\n        resp = await session.get(url, proxy=proxy)\n        print(await resp.text())\n\n\nif __name__ == \'__main__\':\n    asyncio.get_event_loop().run_until_complete(main())\n```\n\n##### 2.8 实战\n```python\nimport asyncio\nimport aiohttp\nimport logging\n\n# motor 库支持异步操作 mongodb，需要安装：pip3 install motor\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\n\nCONCURRENCY = 5\n\n# 书籍详情页，可以根据书籍 id 获取书籍的详细信息。返回的就是一个 json\nDETAILS_URL = \'https://spa5.scrape.center/api/book/{}/\'\n\n# 书籍列表页，里面可以获取一群书籍简要信息，包括书籍的 id。返回类型就是一个 json\nINDEX_URL = \'https://spa5.scrape.center/api/book/?limit=18&offset={}\'\n\nsession = None  # 所有请求都使用同一个全局的 aiohttp.ClientSession 对象\n\n# 控制最大并发量的\nsemaphore = asyncio.Semaphore(CONCURRENCY)\n\n# 使用 motor 来连接 mongodb\nclient = AsyncIOMotorClient(\'mongodb://localhost:27017\')\ndb = client[\'books_db\']\ncollection = db[\'books_collection\']\n\nlogging.basicConfig(level=logging.INFO, \n                    format=\'%(asctime)s - %(levelname)s: %(message)s\')\n\n# 抓取一个网页内容\nasync def scrape_page(url):\n    # 控制最大并发量\n    async with semaphore:\n        try:\n            # 因为 response 也是需要关闭的，所以使用 with...as 代码块来打开 response\n            async with session.get(url) as resp:\n                return await resp.json()\n        except aiohttp.ClientError:\n            logging.error(\'Error occurred while scrape %s\', url, exc_info=True)\n\n# 抓取目录页\nasync def scrape_index(page):\n    url = INDEX_URL.format(page)\n    return await scrape_page(url)\n\n# 抓取细节页\nasync def scrape_detail(book_id):\n    url = DETAILS_URL.format(book_id)\n    results = await scrape_page(url)\n    await save_data(results)\n\n# 往 mongodb 里面保存数据\nasync def save_data(data):\n    logging.info(\'save data: %s\', data)\n    if data:\n        await collection.update_one({\'id\': data.get(\'id\')}, {\'$set\': data}, \n                                    upsert=True)\n\n\nasync def main():\n    global session\n    session = aiohttp.ClientSession()\n    tasks = [asyncio.ensure_future(scrape_index(i)) for i in range(1, 2)]\n    \n    # gather 函数其实就是执行任务的，返回的是一个协程对象\n    # 所以直接调用是不正确的，需要放到事件循环里面才行\n    results = await asyncio.gather(*tasks)\n    \n    ids = []\n    for item in results:\n        if not item:\n            continue\n        for book in item.get(\'results\'):\n            ids.append(book.get(\'id\'))\n    tasks = [asyncio.ensure_future(scrape_detail(book_id)) for book_id in ids]\n    await asyncio.gather(*tasks)\n    await session.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n\n\n### 3. Selenium 使用\n##### 3.1 安装\n###### 3.1.1 安装 ChromeDriver\n详细见：[https://space-jiangsu.yuque.com/luyan-cvhqp/qr2sxk/diylpm#DCXOa](https://space-jiangsu.yuque.com/luyan-cvhqp/qr2sxk/diylpm#DCXOa)\n\n###### 3.1.2 安装 selenium 库\n```python\npip3 install selenium\n```\n\n###### 3.1.3 注意事项\n+ 第一次安装的时候，配置完 chromedriver 的环境变量后，重启 pycharm\n\n##### 3.2 初步入门示例\n```python\n\"\"\"下面真的会打开一个 chrome 浏览器，然后访问，接着关闭 chrome\"\"\"\nfrom selenium import webdriver\n\n# 生成chrome浏览器对象\nbrowser = webdriver.Chrome()\ntry:\n    # 访问百度官网，get 方法会在页面框架加载完成后才结束\n    browser.get(\'https://www.baidu.com\')\n    \n    # 获取网页url\n    print(browser.current_url)\n    \n    # 获取 cookie\n    print(browser.get_cookies(), end=\'\\n\\n\\n\')\n    \n    # 获取网页源代码\n    print(browser.page_source)\nfinally:\n    browser.close()\n```\n\n##### 3.3 节点查找\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 在淘宝官网里面，搜索框的 id 和 name 属性都是 q\n    browser.get(\'https://www.taobao.com/\')\n    \n    # 使用 find_element 方法寻找元素，只会返回找到的第一个元素\n    # 默认使用 id 寻找元素，返回一个 WebElement 类型。找不到报错\n    # 元素不存在的时候可以捕获：selenium.common.exceptions.NoSuchElementException\n    q1 = browser.find_element(value=\'q\')\n    \n    # 使用 name 属性找元素，返回找到的第一个，找不到报错\n    q2 = browser.find_element(by=By.NAME, value=\'q\')\n    \n    # 使用 css 选择器找元素，返回找到的第一个，找不到报错\n    q3 = browser.find_element(by=By.CSS_SELECTOR, value=\'#q\')\n    \n    # 使用 xpath 找元素，返回找到的第一个，找不到报错\n    q4 = browser.find_element(by=By.XPATH, value=\'//input[@id=\"q\"]\')\n    \n    print(q1)\n    print(q2)\n    print(q3)\n    print(q4)\n    \n    # 找所有满足条件的元素，返回一个 WebElement 列表。找不到返回空列表。\n    q5 = browser.find_elements(by=By.CSS_SELECTOR, value=\'li\')\nfinally:\n    browser.close()\n```\n\n##### 3.4 节点交互\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 访问淘宝\n    browser.get(\'https://www.taobao.com/\')\n    \n    # 找到搜索框\n    input_ = browser.find_element(by=By.CSS_SELECTOR, value=\'#q\')\n    \n    # 找到搜索按钮\n    send_btn = browser.find_element(by=By.CLASS_NAME, value=\'btn-search\')\n    \n    # 往搜索框里输入“足球”\n    input_.send_keys(\'足球\')\n    \n    # 清除搜索框内容\n    input_.clear()\n    \n    # 往搜索框输入“iPhone 13”\n    input_.send_keys(\'iphone 13\')\n    \n    # 可以再输入一个回车键，这样就可以搜索了\n    # input_.send_keys(Keys.ENTER)\n    \n    # 当然找到搜索按钮并点击它也是可以的\n    send_btn.click()\nfinally:\n    browser.close()\n```\n\n更多交互看：[官方描述](https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement)\n\n##### 3.5 动作链\n```python\n\"\"\"实现拖动元素\"\"\"\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver import ActionChains\n\n\nbrowser = webdriver.Chrome()\ntry:\n    url = \'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable\'\n    browser.get(url)\n    \n    # 还记得 iframe 框架吗？各个框架之间是独立的，寻找元素必须指定在哪个框架里面。\n    # 好巧，这个界面就是分框架的，所以需要选定frame，不选的话默认选择外面的父框架。\n    browser.switch_to.frame(\'iframeResult\')\n    \n    # 选择父框架\n    # browser.switch_to.parent_frame()\n    \n    # 找到拖动元素和要去的位置，按照元素定位\n    source = browser.find_element(By.CSS_SELECTOR, \'#draggable\')\n    target = browser.find_element(By.CSS_SELECTOR, \'#droppable\')\n    \n    # 获取动作链\n    actions = ActionChains(browser)\n    \n    # 将 source 元素拖动到 target 元素所在位置\n    actions.drag_and_drop(source, target)\n    \n    # 开始拖动\n    actions.perform()\nfinally:\n    browser.close()\n```\n\n![](/upload/covers/27a1549ce31d40cdad5e84bdd5c4ffee.png)\n\n\n更多实例：[官方详解](https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains)\n\n##### 3.6 执行 JS 脚本\n```python\nfrom selenium import webdriver\n\n\nbrowser = webdriver.Chrome()\ntry:\n    browser.get(\'https://www.zhihu.com/explore\')\n    \n    # 将网页内容滚动到最下面\n    browser.execute_script(\'window.scrollTo(0, document.body.scrollHeight)\')\nfinally:\n    browser.close()\n```\n\n##### 3.7 获取节点信息\n###### 3.7.1 获取节点属性、文本\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 访问网页\n    browser.get(\'https://spa2.scrape.center/\')\n    \n    # 选中元素\n    img = browser.find_element(By.CLASS_NAME, \'logo-image\')\n    \n    # 获取元素的 src 属性，不存在这个属性就返回 None，存在就返回对应字符串\n    results = img.get_attribute(\'src\')\n    print(results)\n    \n    # 获取本节点及子孙节点内的文本值。返回一个 str，没有文本就是一个空格。\n    print(img.text, type(img.text))\n\nfinally:\n    browser.close()\n```\n\n###### 3.7.2 获取其他信息\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\nbrowser = webdriver.Chrome()\ntry:\n    # 访问网页\n    browser.get(\'https://spa2.scrape.center/\')\n\n    # 选中元素\n    span = browser.find_element(By.CLASS_NAME, \'logo-title\')\n\n    # 获取元素的 id\n    print(span.id)\n    \n    # 获取元素的大小即宽高：{\'height\': 40, \'width\': 73}\n    print(span.size)\n    \n    # 获取元素的位置：{\'x\': 205, \'y\': 13}\n    print(span.location)\n    \n    # 获取元素的标签名：span\n    print(span.tag_name)\nfinally:\n    browser.close()\n```\n\n##### 3.8 延时等待\n使用 get 获取网页时，会等网页框架加载完成后才会结束。但有些网站使用 ajax 等技术来延迟加载，这时 get 方法大概率获取不到完整网页。所以需要延时等待，这分为显示等待和隐式等待。\n\n###### 3.8.1 隐式等待\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 隐式最大等待 10s，若要找的元素 \".cover\", \".ll\" 找齐了就返回这些元素。\n    # 若是要找的元素有没找到的，就等待。直到元素都找齐了或设置的最大等待时间到了。\n    # 若超时了就抛出：selenium.common.exceptions.NoSuchElementException\n    browser.implicitly_wait(10)\n\n    # 访问网页\n    browser.get(\'https://spa2.scrape.center/\')\n\n    # 选中元素。都找到了就继续执行，否则等待，直到都找到了或超时了。\n    span = browser.find_element(By.CLASS_NAME, \'cover\')\n    span2 = browser.find_element(By.CLASS_NAME, \'ll\')\n\n    print(span.id)\n    print(span.size)\n    print(span.location)\n    print(span.tag_name)\nfinally:\n    browser.close()\n```\n\n###### 3.8.2 显示等待\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 访问网页\n    browser.get(\'https://www.taobao.com\')\n\n    # 创建 WebDriverWait 对象，最多等待 10s\n    wait = WebDriverWait(browser, 10)\n\n    # id 为 q 的元素出现在 DOM 树里就返回\n    # input_ = wait.until(EC.presence_of_element_located((By.ID, \'q\')))\n    \n    # id 为 q 的元素可见时返回\n    # input_ = wait.until(EC.visibility_of_element_located((By.ID, \'q\')))\n    \n    # 所有 id 为 q 的元素都可见了。条件随便换，意思一下\n    # input_ = wait.until(EC.visibility_of_all_elements_located((By.ID, \'q\')))\n    \n    # id 为 q 的元素不可见时返回\n    input_ = wait.until(EC.invisibility_of_element_located((By.ID, \'q\')))\n    \n    # class 为 btn-search 的元素可点击时返回\n    btn_search = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, \'.btn-search\')))\n\n    print(input_)\n    print(btn_search)\nfinally:\n    browser.close()\n```\n\n更多实例：[官方详解](https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions)\n\n##### 3.9 前进与后退\n```python\nimport time\nfrom selenium import webdriver\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 访问两个网页\n    browser.get(\'https://www.taobao.com\')\n    browser.get(\'https://www.baidu.com\')\n\n    # 网页后退，退回淘宝界面\n    browser.back()\n    \n    time.sleep(1)\n    \n    # 网页前进，回到百度界面\n    browser.forward()\nfinally:\n    browser.close()\n```\n\n##### 3.10 cookie 操作\n```python\nfrom selenium import webdriver\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 访问网页\n    browser.get(\'https://www.taobao.com\')\n\n    # 获取所有的 cookie\n    print(browser.get_cookies())\n    \n    # 添加 cookie\n    browser.add_cookie({\'name\': browser.get_cookie(\'name\'), \'value\': browser.get_cookie(\'value\')})\n    print(\'\\n\\n\', browser.get_cookies())\n    \n    # 删除某个 cookie\n    browser.delete_cookie(\'name\')\n    print(\'\\n\\n\', browser.get_cookies())\n    \n    # 删除所有 cookie\n    browser.delete_all_cookies()\n    print(\'\\n\\n\', browser.get_cookies())\nfinally:\n    browser.close()\n```\n\n##### 3.11 选项卡管理\n```python\nimport time\nfrom selenium import webdriver\n\n\nbrowser = webdriver.Chrome()\ntry:\n    # 访问百度\n    browser.get(\'https://www.baidu.com\')\n\n    # 执行 js 脚本，打开新标签页\n    browser.execute_script(\'window.open()\')\n    \n    # browser.switch_to.window() 表示切换标签页\n    # browser.window_handles 是一个数组，里面存着所有标签页，下标从 0 开始\n    browser.switch_to.window(browser.window_handles[1])\n    \n    # 在下标为 1 的标签页里面打开淘宝\n    browser.get(\'https://www.taobao.com\')\n    \n    time.sleep(3)  # 等待 3s\n    \n    # 再切回下标为 0 的标签页\n    browser.switch_to.window(browser.window_handles[0])\n    \n    # 在下标为 0 的标签页里打开 Python 官网\n    browser.get(\'https://python.org\')\nfinally:\n    browser.close()\n```\n\n##### 3.12 反屏蔽\n使用 selenium 打开浏览器访问界面时，网页 JS 可以通过 window.navigator 获取到当前是否使用了 selenium。如果没使用，这个属性的值应该是 undefined；否则，值为 webdriver。有些网站会依据这个原理通过 JS 设置反爬。因此，我们这样做来反反爬。\n\n```python\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver import ChromeOptions\n\n\n# Chrome 的启动选项\noption = ChromeOptions()\n\n# 下面两句是用来取消横幅的，selenium 启动的 chrome 会出现一个横幅：自动化工具控制中\noption.add_experimental_option(\'excludeSwitches\', [\'enable-automation\'])\noption.add_experimental_option(\'useAutomationExtension\', False)\n\n# 创建 chrome 对象的时候传入启动选项\nbrowser = webdriver.Chrome(options=option)\n\n# 将 window.navigator 设置为 undefined\nbrowser.execute_cdp_cmd(\'Page.addScriptToEvaluateOnNewDocument\',\n                        {\'source\': \'Object.defineProperty(navigator, \"webdriver\", {get: ()=> undefined})\'})\n# 这样获取就不怕被屏蔽了\nbrowser.get(\'https://antispider1.scrape.center\')\n\ntime.sleep(5)\nbrowser.close()\n```\n\n##### 3.13 无头模式和代理\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver import ChromeOptions\n\n\n# 创建启动选项\noption = ChromeOptions()\n\n# 设置为无头模式，这样启动时就不会打开一个 chrome 界面\noption.add_argument(\'--headless\')\n\n# 设置缓存存储路径，便于登录维持\noptions.add_argument(\'user-data-dir=./userdata\')\n\n# 代理的设置也很简单\nproxy = \'127.0.0.1:8080\'\noption.add_argument(\'--proxy-server=http://\' + proxy)\n\nbrowser = webdriver.Chrome(options=option)\n\n# 设置一下默认界面的大小，默认为：800*600\nbrowser.set_window_size(1366, 768)\nprint(browser.get_window_size())\n\nbrowser.get(\'https://www.baidu.com\')\n\n# 可以将访问到的界面以图片的形式输出\nbrowser.get_screenshot_as_file(\'/Users/luyan/Desktop/preview.png\')\n```\n\n\n\n### 4. Pyppeteer 使用\n##### 4.1 安装\n```python\npip3 install pyppeteer\n```\n\n初次启动会下载一个 Chromium，但是下载的浏览器往往不是陪 m1，所以需要处理一下。具体见：[4.11 填坑](https://space-jiangsu.yuque.com/luyan-cvhqp/fwbl4o/qt4ofx/edit#Xtzvi)\n\n##### 4.2 入门示例\n###### 4.2.1 示例一\n```python\nimport asyncio\nfrom pyquery import PyQuery\nfrom pyppeteer import launch\n\n\nasync def main():\n    # 创建浏览器对象\n    browser = await launch()\n    \n    # 创建新的选项卡\n    page = await browser.newPage()\n    \n    # 访问指定界面\n    await page.goto(\'https://spa2.scrape.center\')\n    \n    \n    # 等待界面加载出下面的css选择器，指定超时时间为 3s。默认超时时间为 30s。\n    # 超时异常：pyppeteer.errors.TimeoutError\n    await page.waitForSelector(\'.item .nae\', timeout=3000)\n    \n    # 也可以使用 xpath 来选择元素，这边没设置超时时间，使用默认的 30s 超时\n    # await page.waitForXPath(\'//*[contains(@class, \"item\")]//*[@class=\"name\"]\')\n    \n    \n    # 获取该网页的 cookies\n    print(await page.cookies())\n    \n    # 获取网页内容并使用 pyquery 来解析\n    doc = PyQuery(await page.content())\n    names = [item.text() for item in doc(\'.item .name\').items()]\n    print(names)\n    \n    # 关闭浏览器\n    await browser.close()\n\n\n# 异步执行\nasyncio.get_event_loop().run_until_complete(main())\n```\n\n###### 4.2.2 示例二\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    # 创建浏览器对象\n    browser = await launch()\n    \n    # 创建选项卡\n    page = await browser.newPage()\n    \n    # 设置浏览器宽高\n    await page.setViewport({\'width\': width, \'height\': height})\n    \n    # 访问指定页面\n    await page.goto(\'https://spa2.scrape.center\')\n    \n    # 等待页面出现指定元素，默认 30s\n    await page.waitForSelector(\'.item .name\')\n    \n    # 异步睡眠 2s\n    await asyncio.sleep(2)\n    \n    # 生成页面快照，保存到桌面\n    await page.screenshot(path=\'/Users/luyan/Desktop/preview.png\')\n    \n    # 界面框架加载完成后执行 JS 脚本获取浏览器宽高和分辨率\n    dimensions = await page.evaluate(\"\"\"() => {\n        return {\n            width: document.documentElement.clientWidth,\n            height: document.documentElement.clientHeight,\n            deviceScaleFactor: window.devicePixelRatio\n        }\n    }\"\"\")\n    print(dimensions)\n    await browser.close()\n\n\nasyncio.get_event_loop().run_until_complete(main())\n```\n\n更多 API：[官方传送门](https://pyppeteer.github.io/pyppeteer/reference.html)\n\n##### 4.3 启动参数（代理）\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nasync def main():\n    # headless 表示无头模式，即无界面模式。默认就是 True，没有界面\n    browser = await launch(headless=True)\n    \n    # devtools 表示开发者模式，设为 True 表示：打开浏览器的同时打开检查窗口\n    # 设置 devtools = True 会打开窗口。所以这会将默认的 headless 设置为 False\n    # 但是！如果你同时设置了 headless = True, devtools = True，那么不会打开窗口\n    browser = await launch(devtools=True)\n    \n    # args=[\'--disable-infobars\'] 表示禁掉浏览器上的提示条：正在受自动化软件控制\n    browser = await launch(headless=False, args=[\'--disable-infobars\'])\n    \n    # 代理的设置如下\n    proxy = \'127.0.0.1:7890\'\n    browser = await launch(args=[\'--proxy-server=http://\' + proxy])\n    \n    page = await browser.newPage()\n    \n    # 在加载前执行 JS 脚本，设置 webdriver 的值。反反爬\n    await page.evaluateOnNewDocument(\'Object.defineProperty(navigator, \"webdriver\", {get: ()=> undefined})\')\n    \n    await page.goto(\'https://www.baidu.com\')\n    await asyncio.sleep(5)\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.4 页面大小设置\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    # 在 args 参数里面设置浏览器的宽高\n    browser = await launch(headless=False, args=[f\'--window-size={width},{height}\'])\n    page = await browser.newPage()\n    \n    # 设置标签页的宽高，使其和浏览器宽高一致\n    await page.setViewport({\'width\': width, \'height\': height})\n    await page.goto(\'https://www.taobao.com\')\n    await asyncio.sleep(100)\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.5 用户数据持久化\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    # 设置了 userDataDir 参数后会将网站里的 cookie 等信息保存到指定目录下\n    # 下一次启动的时候还会读取这个目录的内容，有一定的维持登录作用\n    browser = await launch(headless=False, userDataDir=\'./userdata\')\n    page = await browser.newPage()\n    await page.setViewport({\'width\': width, \'height\': height})\n    await page.goto(\'https://www.taobao.com\')\n    await asyncio.sleep(100)\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.6 无痕浏览\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    browser = await launch(headless=False)\n    \n    # 使用浏览器对象创建一个无痕上下文，并使用无痕上下文创建新标签页\n    context = await browser.createIncogniteBrowserContext()\n    page = await context.newPage()\n    \n    await page.goto(\'https://www.taobao.com\')\n    await asyncio.sleep(100)\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.7 选择器\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    # 启动参数\n    options = {\n        \'headless\': False,\n        \'executablePath\': \'/Applications/Chromium.app/Contents/MacOS/Chromium\',\n        \'args\': [f\'--window-size={width},{height}\']\n    }\n    browser = await launch(**options)\n\n    pages = await browser.pages()\n\n    page = pages[0]\n    await page.setViewport({\'width\': width, \'height\': height})\n\n    await page.goto(\'https://spa2.scrape.center\')\n    \n    # 等待元素出现在 DOM 树里，此时界面上不一定渲染出了这个元素\n    await page.waitForSelector(\'.item .name\')\n    \n    # 等待 1s，以便页面渲染成功了\n    await asyncio.sleep(1)\n\n    # 获取指定条件的第一个元素\n    j_result1 = await page.J(\'.item .name\')\n    j_result2 = await page.querySelector(\'.item .name\')\n    \n    # 获取所有满足条件的元素\n    jj_result1 = await page.JJ(\'.item .name\')\n    jj_result2 = await page.querySelectorAll(\'.item .name\')\n\n    print(j_result1)\n    print(j_result2)\n    print(jj_result1)\n    print(jj_result2)\n\n    # 对元素实行点击操作（若是此时元素没渲染出来就不会有反应）\n    await j_result1.click(options={\n        \'button\': \'left\',\n        \'clickCount\': 1,\n        \'delay\': 1000\n    })\n\n    await asyncio.sleep(10)\n\n    await page.close()\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.8 选项卡操作\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    # 开启浏览器，开启的时候会自动打开一个标签页\n    browser = await launch(headless=False)\n\n    # 新建一个标签页，那现在是有两个标签页了\n    await browser.newPage()\n    \n    # 获取所有的标签页。\n    # 注意：这个列表一旦获取了就不会动态更新了，当前有几个标签页就会获取到几个标签页\n    pages = await browser.pages()\n\n    # 获取第 1 和第 2 个标签页\n    page1, page2 = pages[0], pages[1]\n\n    await page1.goto(\'https://www.baidu.com\')\n    await page2.goto(\'https://www.taobao.com\')\n\n    # 将焦点给到第 1 个标签页\n    await page1.bringToFront()\n\n    await asyncio.sleep(10)\n\n    await page1.close()\n    await page2.close()\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.9 页面操作\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    browser = await launch(headless=False)\n\n    pages = await browser.pages()\n\n    page = pages[0]\n\n    # 访问网址\n    await page.goto(\'https://www.baidu.com\')\n    await page.goto(\'https://www.taobao.com\')\n\n    # 后退\n    await page.goBack()\n    # 前进\n    await page.goForward()\n    # 刷新\n    await page.reload()\n    # 截取当前界面快照\n    await page.screenshot(path=\'/Users/luyan/Desktop/preview.png\')\n\n    # 设置网页内容，也就是 body 标签里面的内容\n    await page.setContent(\'<h2>Hello World！</h2>\')\n    # 设置 user-agent\n    await page.setUserAgent(\'Luyan\')\n    # 设置 headers\n    await page.setExtraHTTPHeaders(headers={})\n\n    await asyncio.sleep(1000)\n\n    await page.close()\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.10 点击、输入\n```python\nimport asyncio\nfrom pyppeteer import launch\n\n\nwidth, height = 1366, 768\n\n\nasync def main():\n    browser = await launch(headless=False)\n\n    pages = await browser.pages()\n\n    page = pages[0]\n\n    await page.goto(\'https://www.taobao.com\')\n    await page.waitForSelector(\'#q\')\n    \n    # 往输入框输入 iPad\n    await page.type(\'#q\', \'iPad\')\n    \n    # 点击搜索按钮，三个参数分别表示：鼠标左键点击，点击 1 次，延时 1s 点击\n    await page.click(\'.btn-search\', options={\n        \'button\': \'left\',\n        \'clickCount\': 1,\n        \'delay\': 1000\n    })\n\n    await asyncio.sleep(1000)\n\n    await page.close()\n    await browser.close()\n\n\nif __name__ == \'__main__\':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\n##### 4.11 填坑\n```python\n# pyppeteer 默认下载的 chromium 不支持 mac m1，会经常崩溃\n# 我们自己安装一个支持 mac m1 的 chromium\nbrew search chromium\nbrew install --cask eloston-chromium\n\n# 安装完毕后，软件会被移到 Application 目录下\n/Applications/Chromium.app\n\n# 在代码里使用时指定浏览器的位置，这边说的位置是可执行文件的位置，而不是软件包的位置\nbrowser = await launch(executablePath=\'/Applications/Chromium.app/Contents/MacOS/Chromium\')\n```\n\n##### 4.12 实战\n```python\nimport json\nimport asyncio\nfrom urllib import parse\nfrom pyquery import PyQuery\nfrom pyppeteer import launch\nfrom pyppeteer.browser import Browser\n\n\nMAX_PAGE = 10\nTIME_OUT = 10\nCONCURRENCY = 5\nWIDTH, HEIGHT = 800, 600\n\nBASE_URL = \'https://spa2.scrape.center/\'\nINDEX_URL = \'https://spa2.scrape.center/page/{}\'\n\nsemaphore = asyncio.Semaphore(CONCURRENCY)\nbrowser, pages, available = None, None, None\n\n\nasync def init():\n    global browser, pages, available\n    options = {\n        \'headless\': False,\n        \'args\': [f\'--window-size={WIDTH},{HEIGHT}\'],\n        \'executablePath\': \'/Applications/Chromium.app/Contents/MacOS/Chromium\'\n    }\n    browser = await launch(**options)\n    for _ in range(CONCURRENCY - 1):\n        page = await browser.newPage()\n        await page.setViewport({\'width\': WIDTH, \'height\': HEIGHT})\n    pages = await browser.pages()\n    available = [1] * CONCURRENCY\n\n\ndef next_page():\n    for i in range(CONCURRENCY):\n        if not available[i]:\n            continue\n        available[i] = 0\n        return pages[i]\n\n\ndef release_page(page):\n    for i in range(CONCURRENCY):\n        if pages[i] == page:\n            available[i] = 1\n            break\n\n\nasync def scrape_url(url, selector):\n    async with semaphore:\n        page = next_page()\n        await page.goto(url)\n        await page.waitForSelector(selector)\n        html = await page.content()\n        release_page(page)\n        return html\n\n\ndef parse_index(html):\n    doc = PyQuery(html)\n    for item in doc.find(\'.name\').items():\n        yield parse.urljoin(BASE_URL, item.attr.href)\n\n\nasync def scrape_index(index):\n    url = INDEX_URL.format(index)\n    html = await scrape_url(url, \'.name\')\n    return parse_index(html)\n\n\ndef parse_detail(html):\n    doc = PyQuery(html)\n    score = doc(\'.score\').text()\n    name = doc(\'.name h2\').text()\n    img_path = doc(\'.cover\').attr.src\n    drama_info = doc(\'.drama p\').text()\n    categories = [item.text() for item in doc(\'.category span\').items()]\n\n    return {\n        \'name\': name,\n        \'score\': score,\n        \'drama_info\': drama_info,\n        \'img_path\': img_path,\n        \'categories\': categories,\n    }\n\n\nasync def scrape_detail(url):\n    html = await scrape_url(url, \'.name h2\')\n    return parse_detail(html)\n\n\nasync def scrape(index, results):\n    detail_urls = await scrape_index(index)\n    for detail_url in detail_urls:\n        results.append(await scrape_detail(detail_url))\n\n\nasync def main():\n    try:\n        await init()\n        results = []\n        tasks = [scrape(i, results) for i in range(1, MAX_PAGE + 1)]\n        await asyncio.gather(*tasks)\n        print(len(results))\n        with open(\'data.json\', \'w\', encoding=\'utf-8\') as fp:\n            json.dump(results, fp, ensure_ascii=False, indent=2)\n    finally:\n        if isinstance(browser, Browser):\n            await browser.close()\n\n\nif __name__ == \'__main__\':\n    asyncio.get_event_loop().run_until_complete(main())\n```\n\n\n\n'),
       (9, 9, '### 1. Scrapy 框架使用\n##### 1.1 安装\n###### 1.1.1 安装命令\n```python\npip3 install Scrapy\n```\n\n###### 1.1.2 配置环境变量\n正常来说，安装完成后控制台会输出这样一句话：\n\n![](/upload/covers/2a81b9f357da470c9a7b9139f88be766.png)\n\n这意味着我们需要配置环境变量，打开 `~/.bash_profile`文件并在里面添加：\n\n```python\nexport PATH=${PATH}:/Users/luyan/Library/Python/3.8/bin\n```\n\n然后使用 `source ~/.bash_profile`来刷新配置。\n\n##### 1.2 小项目入门\n要爬取的网站：[https://quotes.toscrape.com/](https://quotes.toscrape.com/)\n\n###### 1.2.1 创建项目\n在任意目录下打开终端，输入指令如下：\n\n```python\n# 进入指定的目录下\ncd /Users/luyan/Documents/scrapy_project\n\n# 使用 startproject 命令创建项目，项目名为：scrapytutorial\nscrapy startproject scrapytutorial\n```\n\n创建完成后的目录结构是：\n\n![](/upload/covers/4d31f9d6f0a44628bee65cd6df4efa91.png)\n\n###### 1.2.2 定义数据结构\n爬取下来的数据肯定要有一个数据结构来存储的，这一类实体类在 Scrapy 里面被称为 Item。下面我们为这个小项目定一个数据结构，在 `items.py`（这是创建项目时框架自动生成的文件，不是自己创建的，个人创建的实体数据类都在里面定义）里面创建实体类如下：\n\n```python\nimport scrapy\n\n\nclass QuoteItem(scrapy.Item):\n    \"\"\"\n    分析目标网站很容易看出，数据结构包括三个：\n        text：用来存储格言\n        author：用来存储格言作者\n        tags：用来存储这个格言的类型或所属标签\n    属性的定义都是使用 scrapy.Field() 来操作的\n    \"\"\"\n    text = scrapy.Field()\n    author = scrapy.Field()\n    tags = scrapy.Field()\n```\n\n###### 1.2.3 创建一个 Spider\n作为爬虫，你要爬取什么网站、拿到响应你该怎么解析，这些问题框架是没法知道的，需要你自己来定义。这部分在 Scrapy 里被称为 Spider。在项目的根目录即最外层的 `scrapytutorial`目录下使用控制台命令：\n\n```python\n# 使用 genspider 指令自动生成一个爬虫 py 文件。\n# quotes 是文件名，quotes.toscrape.com 表示该爬虫爬取的目标网站域名。\nscrapy genspider quotes quotes.toscrape.com\n```\n\n生成后的样例代码是这样的：\n\n```python\nimport scrapy\n\n\n# 新创建的 Spider 需要继承 scrapy.Spider 类\nclass QuotesSpider(scrapy.Spider):\n    # name 属性用来区分不同的 spider\n    name = \'quotes\'\n    \n    # allowed_domains 表示所有允许爬取的域名。\n    # 如果使用这个爬虫但是请求目标不是这个域名下的，则该请求会被过滤掉。\n    allowed_domains = [\'quotes.toscrape.com\']\n    \n    # start_urls 表示这个爬虫启动时要爬取的网址。\n    start_urls = [\'http://quotes.toscrape.com/\']\n\n    # 见名知意，这是解析函数。当请求完成后，response 会传入这个回调函数，让你实现解析逻辑。\n    def parse(self, response):\n        pass\n\n```\n\n###### 1.2.4 重写 parse 方法处理 response\n```python\nimport scrapy\n\nfrom scrapytutorial.items import QuoteItem\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = \'quotes\'\n    allowed_domains = [\'quotes.toscrape.com\']\n    start_urls = [\'http://quotes.toscrape.com/\']\n\n    # 可以看见，这边的 parse 方法比上面写的多了一个 kwargs 参数\n    # 其实不加没什么问题，这是父类里面有的参数，不加的话垃圾 PyCharm 报黄色提示\n    def parse(self, response, **kwargs):\n        quotes = response.css(\'.quote\')\n        for quote in quotes:\n            \"\"\"\n            获取当前页面所有格言信息，封装成 QuoteItem 对象\n            \"\"\"\n            item = QuoteItem()\n            item[\'text\'] = quote.css(\'.text::text\').extract_first()\n            item[\'author\'] = quote.css(\'.author::text\').extract_first()\n            item[\'tags\'] = quote.css(\'.tags .tag::text\').extract()\n            yield item\n\n        # 从当前界面获取下一页的url\n        next_href = response.css(\'.pager .next a:attr(\"href\")\').extract_first()\n        # 把相对路径拼接成真正的网址\n        url = response.urljoin(next_href)\n        # 封装成请求对象返回出去\n        yield scrapy.Request(url=url, callback=self.parse)\n\n```\n\n###### 1.2.5 启动项目\n```python\n# 使用 crawl 指令启动爬虫\n# 这边启动的是自己定义的 Spider 里面 name 属性等于 quotes 的，并不是文件名\nscrapy crawl quotes\n\n\n# 加一个 -o 表示将爬取结果输出为 quotes.json\n# 好比这边，文件里面就是一个对象列表\nscrapy crawl quotes -o quotes.json\n```\n\n###### 1.2.6 保存文件到数据库\n将爬取的数据保存到文件很简单，可以在运行语句里面加 -o；若是想保存在数据库，这时就需要使用 ItemPipeline 来辅助处理了。所谓的 ItemPipeline 指的是定义在默认 `pipelines.py`里面的类，而且这个类必须实现 `process_item(item, spider)`方法。\n\n```python\nimport pymongo\n\nfrom scrapy.exceptions import DropItem\n\n\nclass TextPipeline(object):\n    \"\"\"\n    文本管道，当数据经过这个管道时，我们将数据的 text 属性限制最大长度为 50.\n    \"\"\"\n    def __init__(self):\n        self.limit = 50\n\n    def process_item(self, item, spider):\n        \"\"\"\n        这个方法是管道必须实现的方法，用来对数据做一定过滤。\n        例如，这里我们做的处理是：限制 item 里 text 属性的长度，长度过长时我们用...代替\n        \"\"\"\n        if item[\'text\']:\n            if len(item[\'text\']) > self.limit:\n                item[\'text\'] = item[\'text\'][:self.limit].rstrip() + \'...\'\n            return item\n        else:\n            # 异常情况返回一个 DropItem，相当于当前处理的这个 item 被过滤了\n            # 那么后面的 pipeline 也就收不到这个 item 了，相当于删除当前 item\n            return DropItem(\'Missing Text\')\n\n\nclass MongoDBPipeline(object):\n    \"\"\"\n    MongoDB 管道，当数据经过这个管道时，我们将数据存到数据库里。\n    后面配置的时候，将这个管道放到“文本管道”后面，就可以及时删掉一些无效 item。\n    \"\"\"\n    def __init__(self, connect_str, dbname):\n        self.dbname = dbname\n        self.connect_str = connect_str\n        self.db, self.client = None, None\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        \"\"\"\n        这个方法是管道的可选方法。这是一个类方法，从 @classmethod 注解就可以看出。\n        如果定义了这个方法，那么系统就会根据这个方法获取当前类的实例，而不是自己创建一个。\n        \"\"\"\n        # 从 crawler.settings 可以直接读取系统 settings.py 里面的值\n        # 往往用来获取一些常量\n        settings = crawler.settings\n        return cls(settings.get(\'CONNECT_STR\'), settings.get(\'DBNAME\'))\n\n    def open_spider(self, spider):\n        \"\"\"\n        这也是管道的可选方法。当启动 Spider 时会调用这个方法，往往会做一些初始化的工作。\n        \"\"\"\n        self.client = pymongo.MongoClient(self.connect_str)\n        self.db = self.client[self.dbname]\n\n    def process_item(self, item, spider):\n        \"\"\"\n        管道必须的方法，用来过滤 Item。这边我们不对 Item 做什么修改，只是将数据存进数据库。\n        \"\"\"\n        collection_name = item.__class__.__name__\n        self.db[collection_name].insert_one(dict(item))\n        return item\n\n    def close_spider(self, spider):\n        \"\"\"\n        管道的可选方法，对应于 open_spider 方法。当 Spider 关闭的时候会调用这个方法。\n        \"\"\"\n        self.client.close()\n\n```\n\n写完管道之后，我们还需要将管道配置到 `settings.py`里面才会生效。\n\n```python\n# 键是管道的引用路径，值是管道的先后排序值。排序值越小，这个管道就越先经过。\nITEM_PIPELINES = {\n   \'scrapytutorial.pipelines.TextPipeline\': 300,\n   \'scrapytutorial.pipelines.MongoDBPipeline\': 400\n}\n```\n\n##### \n'),
       (10, 10, '### 安装 & 配置\n#### 安装\n首先去官网下载压缩包：[传送门](https://maven.apache.org/download.cgi)\n\n![](/upload/covers/ab807ee498c442388881eda52c4aebd6.png)\n\n下载完成后，将压缩包解压放到合适的位置，我就放在：`/Users/luyan/Documents/apache-maven-3.6.3`\n\n**注意：**\n\n+ 太高版本的 Maven 会和 IDEA 不兼容，我尝试了版本 [3.6.3](https://pan.baidu.com/s/1kRlf-bR1xQiR_13t-AEpZg?pwd=m2i3) 是可以运行的。\n+ Maven 需要 JDK 环境，所以需要确认本机环境到位。JDK 版本太高也会报错，经测试版本 11 就很好。\n\n#### 配置\nMaven 的配置文件是：`apache-maven-3.6.3/conf/settings.xml`\n\n主要就是仓库相关的配置，我们项目中需要某些依赖的时候会先从本地仓库查找，找不到会去中央仓库查找。但是中央仓库在海外，直接访问会很慢，所以一般会配置一个镜像仓库，我们下面将会介绍配置阿里云镜像仓库。有了镜像之后的依赖查找顺序就变为：1. 本地仓库  2. 镜像仓库  3. 中央仓库\n\n##### 本地仓库\n我们可以配置本地仓库的目录，我直接放到安装目录下新创建的`repo`目录下：\n\n```xml\n<localRepository>/Users/luyan/Documents/apache-maven-3.6.3/repo</localRepository>\n```\n\n##### 阿里云仓库镜像\n配置阿里云镜像仓库之后可以加快下载依赖的速度：\n\n```xml\n<mirror>  \n	<id>alimaven</id>  \n	<name>aliyun maven</name>  \n	<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n	<mirrorOf>central</mirrorOf>          \n</mirror>\n```\n\n上述配置放在`settings.xml`的`mirrors`标签内部。\n\n##### jdk 版本配置\n```xml\n<profile>\n  <id>jdk-11</id>\n  <activation>\n    <activeByDefault>true</activeByDefault>\n    <jdk>11</jdk>\n  </activation>\n  <properties>\n    <maven.compiler.source>11</maven.compiler.source>\n    <maven.compiler.target>11</maven.compiler.target>\n    <maven.compiler.compilerVersion>11</maven.compiler.compilerVersion>\n  </properties>\n</profile>\n```\n\n上述配置放在`settings.xml`的`profiles`标签内部。\n\n##### 环境变量\n下面我们需要把 Maven 的 bin 目录配置到环境变量里面：\n\n```xml\nvim ~/.bash_profile \n\nexport PATH=${PATH}:/Users/luyan/Documents/apache-maven-3.6.3/bin\n\nsource ~/.bash_profile \n```\n\n配置完之后使用`mvn -version`确实是否成功。\n\n### IDEA 集成 Maven\n#### 配置 Maven 环境\n##### 项目配置 Maven 环境\n项目中配置 Maven 的主要流程：\n\n1. 创建空白工程\n2. 配置 Maven 安装目录、配置文件和本地仓库的路径\n3. 设置 JRE 版本以及编译生成字节码的版本\n\n所有流程按照下面的图进行配置：\n\n![](/upload/covers/4d5ede46130b467d9a98533e745264de.png)\n![](/upload/covers/ef7026e2123c43359b623983f9758a07.png)\n![](/upload/covers/f01cfa76e5184b8bb4db70d8e94c1ff6.png)\n![](/upload/covers/c85853b601be49259997cdf77c9cf385.png)\n\n##### 全局配置 Maven 环境\n每次创建 Maven 工程都进行一次上面的操作很麻烦，我们可以全局配置。看下图，我们可以在 IDEA 项目创建界面点击`Customize -> All settings`：\n\n![](/upload/covers/e61caf4e640146769ef9abf7999eb621.png)\n\n在出来的设置界面里进行和`2.1`一样的设置就可以了。\n\n#### 创建 Maven 项目\n##### 创建普通 Java 工程\n假设我们已经全局配置完毕，创建 Maven 项目的流程是：\n\n1. 创建一个空白项目\n2. 配置项目的 JDK\n3. 在项目里新建一个 Maven Module\n4. 修改好包名之类的信息，点击创建\n\n![](/upload/covers/0ac66be342344c0dba4abb7db0cdb1ce.png)\n![](/upload/covers/a317a92e1e614b38b1cbf4c3fcbadb9b.png)\n![](/upload/covers/1a5fcb42eccb41aaaac08368c0ad9748.png)\n![](/upload/covers/208a8fc0c6574aacb7d9f2030f6885ad.png)\n![](/upload/covers/b9c0abdb6de74de4ac997af2cec19f13.png)\n\n创建完毕之后，项目的目录结构如图：\n\n![](/upload/covers/b1137fa78f094478941c5a1ddeb4942b.png)\n\n+ `src/main`项目开发目录\n    - `java`源代码\n    - `resources`配置文件\n+ `src/test`项目测试目录\n    - `java`源代码\n    - `resources`配置文件\n        * 这个目录默认不存在，可以自己创建\n+ `pom.xml`\n\n到此就可以在`src/main/java`下面创包写代码啦！\n\n##### 创建 Java web 模块\n在创建 web 模块之前，先按照上面的做法创建一个普通模块。\n\n###### 手动创建\n在普通模块的基础上：\n\n1. 补全目录解构`main/webapp/WEB-INFO/web.xml`\n2. 在模块的`pom.xml`的根标签内添加`<packaging>war</packaging>\0`\n\n上面的`web.xml`里面直接填上：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n</web-app>\n```\n\n###### 插件快速创建\n首先安装插件`JBLJavaToWeb`，安装好之后直接右键一个普通模块并点击：\n\n![](/upload/covers/09a8e05e67114b85b63fda6501ca9781.png)\n\n这就可以快速创建 web 模块，实际上就是插件帮你补全文件。\n\n#### 导入 Maven 模块\n操作路径：`Project Structure -> Modules -> + -> Import Module`：\n\n![](/upload/covers/fe908591bc754f8e805dcd5e64b7e69c.png)\n\n注意导入选择文件的时候选的是模块下的`pom.xml`文件，不是目录。\n\n### Maven 的使用\n#### 坐标\nMaven 中的坐标是资源的唯一标识，通过坐标可以唯一定位资源的位置。我们使用坐标定义项目或引入项目需要的依赖。Maven 的坐标组成主要有：\n\n+ `groupId`定义当前项目隶属的组织名称，通常是域名反写\n+ `artifactId`定义当前 Maven 项目名称（其实更常见的是模块名称）\n+ `version`定义当前的项目版本号\n\n定义项目：\n\n```xml\n<groupId>com.luyan</groupId>\n<artifactId>maven01</artifactId>\n<version>1.0-SNAPSHOT</version>\n```\n\n引入项目依赖：\n\n```xml\n<dependency>\n  <groupId>com.luyan</groupId>\n  <artifactId>maven01</artifactId>\n  <version>1.0-SNAPSHOT</version>\n</dependency>\n```\n\n除了这三个配置项，还有一个配置项`packaging`，这个选项主要用来指定创建的模块类型。它有三种取值：\n\n+ `jar`默认值。表示普通的 Java 工程，会打包成`.jar`文件。\n+ `war`表示 Java 的 web 工程，打包成`.war`文件。\n+ `pom`表示不打包，表示做继承的父工程。\n\n#### 依赖配置\nMaven 最核心的功能就是依赖配置，我们的依赖都配置在`pom.xml`的`dependencies\0`标签中。例如我们想要添加`logback`依赖，可以在里面这样配置：\n\n```xml\n<dependency>\n    <groupId>ch.qos.logback</groupId>\n    <artifactId>logback-classic</artifactId>\n    <version>1.2.3</version>\n</dependency>\n```\n\n我们把`XML`添加进去之后要点一下`pom.xml`右上角的同步按钮才会生效。\n\n用起来很方便，但如果包名、版本号之类的信息记不住怎么办？这分两种情况：\n\n##### 旧依赖\n所谓旧依赖是指这个依赖曾经导入过（存在于本地仓库），这种情况下我们输入依赖名 IDEA 会自动提示：\n\n![](/upload/covers/6e6a2bc2e0a445429270a19343f96a84.png)\n\n##### 新依赖\n相对的，新依赖是指这个依赖是第一次导入（不存在于本地仓库）。我们想要获取这个依赖的相关信息也有两种方式：\n\n###### 使用插件\n首先安装插件`maven-search`，然后按照下图操作：\n\n![](/upload/covers/4a7a71ef43154f4d9df15be9c90c8a46.png)\n![](/upload/covers/83db2194466e42dfb2f8a45c9e9387b3.png)\n\n###### 仓库中心\n我们可以去[仓库中心](https://mvnrepository.com/)（挂梯子）寻找该依赖：\n\n![](/upload/covers/541320cfc69846dc91e0f8b768b25557.png)\n\n可能找到的依赖有很多版本，那么选择哪一个？推荐选择使用人数多的版本：\n\n![](/upload/covers/818d127354e844d3aa4ae4366190e931.png)\n![](/upload/covers/9cf71eafd9cc4dee97587bd2d2a566e4.png)\n\n##### 提取属性\n我们在导入依赖的时候，有些属性值是一样的，那么我们就可以把这些值提取出来。例如某些依赖的版本号是一样的，那么这个版本号就可以提取出来。\n\n首先我们在`pom.xml`里面定义`properties`标签，在标签内部定义属性：\n\n```xml\n<properties>\n  <jackson.version>2.16.1</jackson.version>\n</properties>\n```\n\n我们这边定义了`jackson.version`属性，然后在需要的地方使用`${}`引用：\n\n```xml\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n  <version>${jackson.version}</version>\n</dependency>\n```\n\n定义属性命名的时候一般使用两级命名`xxx.yyy`，不然容易与官方的名字冲突。\n\n#### 依赖传递\n我们依赖的时候不仅可以依赖`jar`包，还能依赖工程下的其它模块。看下图：\n\n我们在模块`pom.xml`里面添加的依赖是直接依赖，而我们所依赖的`jar`包或模块还能继续依赖别人，这些就是间接依赖。看下图：\n![](/upload/covers/65f623d461154315a9a347028099c8f3.png)\n\n默认情况下，间接依赖也会传递到我们的模块中。所谓传递到我们的模块里指的是能够直接在模块里使用这些间接依赖。IDEA 提供依赖可视化功能，我们右键模块的`pom.xml`文件，按照下面点选即可：\n\n![](/upload/covers/1529f74cc8e74335bf367fa725a69836.png)\n\n#### 依赖排除\n很多时候，我们自己需要依赖某个`jar`包或模块，而这恰好也被我们的子模块依赖了，但子模块需要的版本与我们需要的不一样。这个时候默认的依赖传递就出问题了，于是我们可以使用依赖排除。\n\n假设我们按照上面的图示，A 依赖 B，B 依赖 C，于是 C 被传递给了 A。我们的目的是从 A 中排除这个 C，因为 C 是 B 直接依赖的，所以可以在 B 的引用`xml`里面添加`exclusions\0`标签，在这个标签里面配置多个`exclusion`子标签表示依赖排除。\n\n```xml\n<!-- 添加依赖 projectB -->\n<dependency>\n    <groupId>com.example</groupId>\n    <artifactId>projectB</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <exclusions>\n      	<!-- 排除依赖 projectC -->\n        <exclusion>\n            <groupId>com.example</groupId>\n            <artifactId>projectC</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n```\n\n我们排除这个依赖之后，我们就无法使用这个依赖了，想要使用只能自己在`pom.xml`里面添加需要的依赖。\n\n#### 依赖范围\n依赖的资源默认情况下可以在任何地方使用，主要有：\n\n+ 主程序范围（`main`目录下）\n+ 测试程序范围（`test`目录下）\n+ 是否参与打包运行\n\n作用范围我们是可以通过`scope`标签手动配置的，主要有以下取值：\n\n| **scope 值** | **主程序** | **测试程序** | **打包** |\n| :---: | :---: | :---: | :---: |\n| `compile`（默认值） | Y | Y | Y |\n| `test` | - | Y | - |\n| `provided` | Y | Y | - |\n| `runtime` | - | Y | Y |\n\n\n#### 生命周期\n##### 介绍\nMaven 生命周期是为了对所有的 Maven 项目构建过程进行抽象和统一。Maven 中有三套完全独立的生命周期，分别是：\n\n+ `clean`：主要做清理工作\n+ `default`：核心工作，如编译、测试、安装、打包、部署等\n+ `site`发布报告、生成站点等\n\n每套生命周期都会包含一系列阶段，这些阶段有先后顺序，同一套生命周期里后面的阶段依赖于前面的阶段。主要的阶段有：\n\n![](/upload/covers/066e387b7447426cacd7c822d36eba65.png)\n\n我们需要着重关注的阶段有 5 个，分别是：\n\n+ `clean`：移除上一次构建生成的文件，主要是删除`target`目录\n+ `compile`：编译项目的源代码\n+ `test`：使用合适的单元测试框架进行测试，一般是`Junit`\n+ `package`：将编译后的文件打包，一般是`jar`包或`war`包\n+ `install`：安装项目到本地仓库，安装完之后我们就可以在其它项目引用它\n\n##### 执行阶段\n我们可以在 IDEA 的 Maven 面板里面手动运行各个阶段，如果不存在这个面板可以按照下图寻找：\n\n![](/upload/covers/9bcbb133a4e44324b340673c38d34b29.png)\n\n我们在 Maven 面板里面选择对应的项目，展开里面的`Lifecycle`选项：\n\n![](/upload/covers/a2ba476264c148078a24ea94e7ace720.png)\n\n可以看到常用的阶段基本都包含在了里面，我们可以双击对应的选项来运行该阶段。\n\n注意，我们上面说的**同一套生命周期里面的各阶段是相互依赖的**，因此直接运行后面的阶段，会自动将前面的阶段运行完。\n\n例如，直接双击`package`，那么会自动运行`compile`和`test`，但不会运行`clean`。 \n\n有些时候，我们想要跳过某个阶段，比如`test`阶段，可以先选中这个阶段，然后点击上面的闪电标记：\n\n![](/upload/covers/3f0fa1300eea4506979160f312f69271.png)\n\n可以看到`test`被加上了删除线，下次再执行会自动跳过这个阶段。\n\n除了使用 IDEA 提供的图形化界面，我们还可以到模块的目录下（`pom.xml`所在目录）使用 Maven 指令来进行相关的阶段操作，例如：`mvn clean`、`mvn package`等。\n\n#### 继承\n开发过程中我们可以会遇到这样的场景：一个项目分为多个模块由不同的人开发，这些模块里面可能有部分模块都需要依赖同一个包，自由发展的话可能大家导入的是不同的版本，这就有可能出现冲突。解决方案就是创建一个父模块，然后在父模块里面声明依赖，子模块导包的时候直接使用父模块提供的版本。父模块导依赖有两种方式：\n\n+ 直接在父模块的`dependencies\0`标签里导包。但这样做的话，所有子模块不管需不需要包，都会和父模块同步，这就有点冗余了。\n+ 更好的做法是父模块只管声明依赖而不是直接导入依赖看下面例子：\n\n```xml\n<!-- 父模块声明依赖 -->\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.16.1</version>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<!-- 子模块导入依赖时不写 version，这表示使用父模块指定的版本 -->\n<dependencies>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n    </dependency>\n</dependencies>\n```\n\n一般而言，父模块是不需要`src`目录的，且父模块也不需要参与打包。因此父模块的`packaging`属性一般会指定为`pom`。\n\n想要指定父子关系有两种做法：\n\n+ 一种是直接在父模块上右键创建模块，此时创建的模块会默认指定父模块。\n+ 在子模块里面手动添加下面的标签：\n\n```xml\n<!-- 使用 parent 标签指定父模块 -->\n<parent>\n    <artifactId>javase-parent</artifactId>\n    <groupId>com.luyan</groupId>\n    <version>1.0-SNAPSHOT</version>\n</parent>\n```\n\n#### 聚合\n聚合是构建上的概念，还是上面的场景：一个父模块下面有多个子模块，构建的时候要挨个模块进行构建不是很烦？而且如果子模块之间存在互相引用的情况，子模块的构建顺序也很重要。\n\n这时聚合就可以帮我们解决烦恼，聚合能够一次性构建所有的子模块，且构建顺序也不需要我们操心。想要把子模块聚合起来只需要在父模块使用`modules\0`标签：\n\n```xml\n<modules>\n    <module>javase-child-01</module>\n    <module>javase-child-02</module>\n</modules>\n```\n\n默认情况下创建的子模块都会加入聚合里面，不想加入的直接删除即可。\n\n这样我们构建的时候直接构建父模块即可，而不需要挨个构建子模块。\n\n\n\n\n\n'),
       (11, 11, '### 简介\nSpring 是一个支持快速开发 JavaEE 应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发 JavaEE 应用程序的必备。\n\n### 容器\nSpring 容器是 Spring 框架的核心，是用来管理对象的。容器负责创建对象、配置对象，并管理对象的整个生命周期（从创建到销毁）。\n\nSpring 中常见的容器实现类：\n\n| `ClassPathXmlApplicationContext` | 通过读取类路径下的 xml 配置文件创建 IoC 容器对象。 |\n| :---: | --- |\n| `FileSystemApplicationContext` | 通过读取文件路径下的 xml 配置文件创建 IoC 容器对象。 |\n| `AnnotationConfigApplicationContext` | 通过读取 Java 配置类创建 IoC 容器对象。 |\n| `WebApplicationContext` | 专门为 Web 应用准备，基于 Web 环境创建 IoC 容器对象，并将对象引用存到 ServletContext 域中。 |\n\n\n实际开发中我们用`AnnotationConfigApplicationContext`和`WebApplicationContext`比较多。\n\n### Ioc & DI\n#### IoC\n**loC**（Inversion of Control）即控制反转主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 loC 容器来创建和管理，即控制由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 loC 容器维护着构成应用程序的对象，并负责创建这些对象。\n\n#### DI\n**DI**（Dependency Injection）即依赖注入是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，Dl 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。\n\n### xml 配置\n#### 创建 xml 文件\n在进行 xml 配置前我们需要先导包：\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>5.3.32</version>\n</dependency>\n```\n\n首先我们需要创建 xml 文件，一般我们在`src/main/resources`目录下创建 xml 文件。由于要导必要的约束，因此我们不是直接创建 xml 文件，而是如下图：\n\n![](/upload/covers/d44dcf3064a94a34b1a32a1734c79d79.png)\n\n创建出来的 xml 格式如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n</beans>\n```\n\n#### 配置普通对象\n我们想要将某些类的创建等操作交给 Spring 容器，最简单的配置如下：\n\n```xml\n<bean id=\"testBean1\" class=\"com.luyan.TestBean\"/>\n```\n\n使用`bean`标签表示一个对象，`id`属性是这个对象的唯一标识，`class`属性指定这个类的全限定名。\n\n当我们获取 id 为 testBean1 的对象时相当于执行了`new com.luyan.TestBean()`。\n\n但是要**注意**：这样配置的对象，默认是单例模式即每次从 Spring 容器中获取的对象都是同一个对象。\n\n#### 工厂模式\n我们正常开发中有些对象是通过工厂模式创建的，工厂模式分为静态工厂和非静态工厂。\n\n##### 静态工厂\n对于静态工厂，对象是通过静态方法返回的，我们可以如下配置：\n\n```xml\n<bean id=\"testBean2\" class=\"com.luyan.StaticFactory\" factory-method=\"getTestBean\"/>\n```\n\n`id`指定对象的唯一标识，`class`指定静态工厂类，`factory-method`指定使用工厂类的哪一个静态方法。当我们获取`id`为 testBean2 的对象时相当于执行了：\n\n```java\ncom.luyan.StaticFactory.getTestBean()\n```\n\n##### 非静态工厂\n对于非静态工厂，我们需要先实例化工厂对象，然后调用工厂对象的实例方法返回我们需要的对象。因此我们配置的时候需要分两步：\n\n+ 将工厂对象配置到 xml 文件中；\n+ 使用配置好的工厂对象配置我们需要的对象；\n\n```xml\n<!-- 配置工厂类，id 指定为 nsFactory -->\n<bean id=\"nsFactory\" class=\"com.luyan.NoneStaticFactory\"/>\n<bean id=\"testBean3\" factory-bean=\"nsFactory\" factory-method=\"getTestBean\"/>\n```\n\n配置对象的时候使用`factory-bean`属性指定工厂类的`id`，`factory-method`属性指定调用哪一个非静态方法。这样当我们获取`id`为 testBean3 的对象时相当于执行了：\n\n```java\nnew com.luyan.NoneStaticFactory().getTestBean()\n```\n\n#### 依赖注入\n##### 数据定义\n上面的配置都是很简单的配置，没有注入依赖。所谓注入依赖就是传递对象需要的各种参数，如果一个类没有无参构造，那么使用上面的方法配置对象是会报错的。因此这种情况下我们就需要注入依赖，参数可以通过构造方法或对应的`Setter`指定。假设我们有下面的类定义：\n\n```java\npublic class UserDao { }\n\npublic class UserService {\n    private String name;\n    private int age;\n    private UserDao userDao;\n\n    public UserService(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    public UserService(String name, int age, UserDao userDao) {\n        this.name = name;\n        this.age = age;\n        this.userDao = userDao;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n}\n```\n\n##### 构造注入\n我们现在想把`UserService`配置到 xml 里面，首先我们肯定需要先把`UserDao`配置到里面，因为注入的数据也必须受 Spring 管控；其次我们发现`UserService`没有无参构造，所以我们需要配置构造参数：\n\n```xml\n<!-- 配置 UserDao -->\n<bean id=\"userDao\" class=\"com.luyan.UserDao\"/>\n\n<!-- 配置 UserService -->\n<bean id=\"userService\" class=\"com.luyan.UserService\">\n    <constructor-arg value=\"张三\"/>\n    <constructor-arg value=\"18\"/>\n    <constructor-arg ref=\"userDao\"/>\n</bean>\n```\n\n我们在`UserService`的`bean`标签内部使用`constructor-arg`标签配置构造参数，`value`和`ref`属性都是为了配置参数，`value`属性用来配置字面量，`ref`属性用来配置 Spring 里面`bean`的`id`。\n\n默认情况下配置的构造参数是按照定义的顺序依次配置的，但我们可以使用`name`或`index`属性指定具体的参数。`name`属性里面填写要配置的参数名，`index`属性里面填写要配置参数的下标（从 0 开始）。\n\n```xml\n<!-- 使用 index 属性指定参数下标 -->\n<bean id=\"userService\" class=\"com.luyan.UserService\">\n    <constructor-arg index=\"1\" value=\"18\"/>\n    <constructor-arg index=\"0\" value=\"张三\"/>\n    <constructor-arg index=\"2\" ref=\"userDao\"/>\n</bean>\n\n<!-- 使用 name 属性指定参数名字 -->\n<bean id=\"userService\" class=\"com.luyan.UserService\">\n    <constructor-arg name=\"age\" value=\"18\"/>\n    <constructor-arg name=\"name\" value=\"张三\"/>\n    <constructor-arg name=\"userDao\" ref=\"userDao\"/>\n</bean>\n```\n\n上面三种配置`UserService`的方法都相当于执行：\n\n```java\nnew com.luyan.UserService(\"张三\", 18, new com.luyan.UserDao())\n```\n\n##### Setter 注入\n我们给对象里面某个变量赋值还可以使用 Setter 注入，Setter 注入就是调用变量对应的 set 方法：\n\n```xml\n<bean id=\"userService\" class=\"com.luyan.UserService\">\n  <constructor-arg name=\"userDao\" ref=\"userDao\"/>\n\n  <property name=\"age\" value=\"18\"/>\n  <property name=\"name\" value=\"张三\"/>\n</bean>\n```\n\n我们使用`property`标签进行 Setter 注入，`name`属性指定要注入的变量名，`value/ref`属性指定注入的值。**注意：**Setter 注入并不能绕过构造方法，所以要保证构造参数是齐全的。\n\n#### 获取对象\n我们想要获取配置的对象，首先需要创建 Spring 容器。容器有好几种，我们常用的是`ClassPathXmlApplicationContext`：\n\n```java\n// 创建 Spring 容器并传入配置名称\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n        \"spring_01.xml\");\nUserService userService1 = (UserService) applicationContext.getBean(\"userService\");\nUserService userService2 = applicationContext.getBean(\"userService\", UserService.class);\nUserService userService3 = applicationContext.getBean(UserService.class);\n```\n\n我们获取对象的时候使用容器的`getBean`方法，这个方法有三种重载：\n\n+ 直接传入一个`bean`的`id`，返回一个`Object`，需要我们手动强转成对应的类型；\n+ 传入`bean id`的同时再传入一个`.class`表示返回对象的类型，这就不需要强转了；\n+ 直接传一个`.class`，由容器自己寻找合适的`bean`并返回对象给我们，这种方法有个注意点：\n    - 配置文件中`class`属性为此类型的`bean`只能有一个，不然会报错；\n\n一些其他注意事项：\n\n+ `ClassPathXmlApplicationContext`的构造方法里面可以传多个配置文件名；\n+ 使用`getBean`时，传入的类型可以是对象的接口类型。\n\n#### 周期 & 作用域\n##### 生命周期\n交由 Spring 容器管理的对象可以配置生命周期方法，主要有两个周期方法：\n\n+ 创建时调用的周期方法；\n+ 销毁时调用的周期方法；\n\n这两个方法必须使用`public void`修饰且没有参数，方法名不重要。配置文件中我们可以使用`bean`标签里面的`init-method`和`destroy-method`属性来指定两个周期方法：\n\n```xml\n<bean id=\"userDao\" class=\"com.luyan.UserDao\" init-method=\"init\" destroy-method=\"destroy\"/>\n```\n\n这个两个周期方法调用的时机与这个对象的作用域有关，下面我们详细看看。\n\n##### 作用域\n作用域主要描述对象在什么范围内有效，我们可以通过`bean`标签的`scope`属性来指定。`scope`属性主要有两个值可选：\n\n| **取值** | **含义** |\n| --- | --- |\n| `singleton` | 单实例，**默认值** |\n| `prototype` | 多实例，每次获取的对象都是一个全新的对象 |\n\n\n**注意：**Spring 容器启动的时候会创建所有配置的对象到容器中，后面单例模式的对象都是共享的一个，而多例对象每次获取都会重新创建新的。单例对象随着容器的销毁（调用`application.close()`）而销毁，而多例对象的销毁由用户自己管理，不受容器管控。\n\n在`WebApplicationContext`环境下还有两个值可选（但不常用）：\n\n| **取值** | **含义** |\n| --- | --- |\n| `request` | 请求范围内有效的实例 |\n| `session` | 会话范围内有效的实例 |\n\n\n```xml\n<!-- 单例对象，因为是默认值，所以此时可以不指定 scope 属性 -->\n<bean id=\"userDao\" class=\"com.luyan.UserDao\" scope=\"singleton\"/>\n\n<!-- 多例对象 -->\n<bean id=\"userDao\" class=\"com.luyan.UserDao\" scope=\"prototype\"/>\n```\n\n#### 标准工厂\n上面我们介绍过两种工厂的配置方法，下面我们介绍一下标准工厂的配置。主要步骤可以分为：\n\n1. 创建工厂类实现`FactoryBean`接口；\n2. 实现接口里面必要的方法；\n3. 将工厂类配置到 xml 文件里；\n\n```java\npublic class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name=\'\" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\npublic class UserFactoryBean implements FactoryBean<User> {\n    @Override\n    public User getObject() throws Exception {\n        User user = new User();\n        user.setName(\"张三\");\n        return user;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return User.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n```\n\n`FactoryBean`接口主要有三个方法：\n\n+ `getObject`方法书写创建对象的代码；\n+ `getObjectType`方法返回要创建对象的类型；\n+ `isSingleton`方法返回创建的对象是否单例，这个方法默认实现是返回`true`。\n\n接下来我们将工厂配置到 xml 文件中：\n\n```xml\n<bean id=\"user\" class=\"com.luyan.UserFactoryBean\"/>\n```\n\n`class`属性填写工厂的全限定符，因为获取这个`bean`的时候返回的是实体类，所以我们将这边的`id`属性指定为`user`。\n\n从本质上讲，这种方式就是非静态工厂创建对象的方法。因此实际上工厂对象也是存在于容器中的，对应的工厂类对象可以使用`id`为`&user`获取（就是在实体类的`id`前面加上`&`）。\n\n如果我们想创建对象的时候，有些信息能够通过配置获取，应该怎么做？\n\n```java\npublic class UserFactoryBean implements FactoryBean<User> {\n    private String userName;\n\n    @Override\n    public User getObject() throws Exception {\n        User user = new User();\n        user.setName(userName);\n        return user;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return User.class;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n}\n```\n\n```xml\n<bean id=\"user\" class=\"com.luyan.UserFactoryBean\">\n    <property name=\"userName\" value=\"张三\"/>\n</bean>\n```\n\n我们的实现思路是通过 Setter 给工厂类传递参数，然后`getObject`方法直接访问这个变量即可。\n\n#### 占位符\n开发时有些数据是配置在`properties`文件里面的，我们的 xml 可以读取这些数据。\n\n+ 首先我们在`main/resources`目录下创建`properties`文件；\n+ 按照下面的方式配置并读取\n\n```xml\n<!-- 配置要读取的属性文件路径 -->\n<context:property-placeholder location=\"classpath:data.properties\" />\n\n<bean id=\"user\" class=\"com.luyan.UserFactoryBean\">\n    <!-- 通过 ${属性名} 获取对应的属性值 -->\n    <property name=\"userName\" value=\"${name}\"/>\n</bean>\n```\n\n我们在获取的时候可能获取不到配置的属性，此时我们可以`${name:默认值}`添加默认值。\n\n### 注解配置\n#### Spring bean\n实际开发中我们使用注解配置会更多一点，Spring bean 的配置主要有以下几种：\n\n| **注解** | **说明** |\n| --- | --- |\n| `@Component\0` | 用来标识 Spring bean，标注之后这个类就由 Spring 管控。 |\n| `@Repository\0` | 功能与`@Component`一样，主要用于 DAO 层的标注。 |\n| `@Service\0` | 功能与`@Component`一样，主要用于 Service 层的标注。 |\n| `@Controller\0` | 功能与`@Component`一样，主要用于 Controller 层的标注。 |\n\n\n这四种注解其实都是等价的，只不过为了更好的代码可读性人为的起了四个名字。因为这些注解都是为了标注 Spring bean 的，所以这些注解只能有用类上，不能用于方法上。\n\n```java\n@Repository  // 因为是 DAO 层，所以我们使用 Repository 进行注解\npublic class UserDao {\n}\n```\n\n我们使用这些注解之后，还需要将包配置在 xml 里面这些注解才会生效。\n\n```xml\n<context:component-scan base-package=\"com.luyan\"/>\n```\n\n`base-package`属性用来配置 Spring 扫描的根包，这个包下面的所有子包都会参与扫描。没有参与扫描的包下的注解类是不会被 Spring 管控的。\n\n有时我们会排除掉某些注解，不让 Spring 扫描它。我们可以：\n\n```xml\n<context:component-scan base-package=\"com.luyan\">\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/>\n</context:component-scan>\n```\n\n这种写法是指我们会扫描`com.luyan`包下所有的非`@Service`注解。\n\n有指定不包含的，就有指定包含的：\n\n```xml\n<context:component-scan base-package=\"com.luyan\" use-default-filters=\"false\">\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/>\n</context:component-scan>\n```\n\n这么写是指只扫描`com.luyan`包下`@Service`注解，记得把`use-default-filters`属性置为`false`。\n\n我们使用注解将类配置到容器之后，`id`属性默认是类名的首字母小写。例如`UserDao`使用注解配置之后，在容器里的`id`默认为`userDao`。当然我们可以在注解里面传参数修改这个值：\n\n```java\n@Repository(\"UD\")  // 将这个类 id 命名为 UD\npublic class UserDao {\n}\n```\n\n#### 周期 & 作用域\n之前我们讲过使用 xml 配置初始化和销毁方法，我们现在看看注解的配置方式：\n\n```java\n@Component\npublic class User {\n    @PostConstruct\n    public void init() {\n        System.out.println(\"User init\");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        System.out.println(\"User destroy\");\n    }\n}\n```\n\n`@PostConstruct`表示初始化注解，`@PreDestroy`表示销毁注解。这两个方法的定义还是需要满足`public void`修饰、无参这两个条件。触发的时机也和上面 xml 的配置是一样的。\n\n关于`scope`的配置也使用注解，看下面的例子：\n\n```java\n@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)\npublic class User {\n}\n\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class User {\n}\n```\n\n不难理解，一个是单例，一个是多例，其中单例是默认值。`Scope`注解即可以放在类上，也可以放在方法上（用于方法上主要为了配置工厂方法）。\n\n#### 依赖注入\n##### 引用类型注入\n引用类型注入主要使用`@Autowired`注解，这个注解可以写在字段上、Setter 上、构造上。\n\n```java\n@Service\npublic class UserService {\n    @Autowired\n    private UserDao userDao;\n\n    public void show() {\n        userDao.show();\n    }\n}\n```\n\n我们可以将`Autowired`翻译成自动装配，装配的时候有以下几种情况（以这边的代码举例）：\n\n+ 如果容器里没有这个类型的对象，则装配失败，报错；\n+ 如果容器里有唯一的`UserDao`类型的对象，则使用这个对象进行装配；\n+ 如果容器里有多个`UserDao`类型的对象，则会使用定义的变量名作为`id`寻找对象。\n\n有多个对象的时候的，我们可以使用`@Qualifier(\"userDao\")\0`注解来指定装配对象的`id`，`@Qualifier`注解一定要和`@Autowired`注解配合使用。\n\n我们将注解放到 Setter 上，代码就变为：\n\n```java\n@Autowired\n@Qualifier(\"userDao\")  // 指定要装配对象的 id\npublic void setUserDao(UserDao userDao) {\n    this.userDao = userDao;\n}\n```\n\n在 Setter 上面加注解，会在创建对象的时候将数据注入到 Setter 的形参里面。\n\n除此之外，我们还可以使用`@Resource`注解来替代`@Autowired+@Qualifier`的组合：\n\n```java\n@Resource(name = \"userDao\")\npublic UserService(UserDao userDao) {\n    this.userDao = userDao;\n}\n```\n\n这边我们将注解放到构造方法上面，创建对象的时候会将数据注入到构造形参里。\n\n但是注意，使用`@Resource`注解需要导额外的包：\n\n```xml\n<dependency>\n  <groupId>javax.annotation</groupId>\n  <artifactId>javax.annotation-api</artifactId>\n  <version>1.3.2</version>\n</dependency>\n```\n\n##### 值类型注入\n对于值类型的注入，我们可以使用`@Value`注解：\n\n```java\n@Component\npublic class User {\n    @Value(\"张三\")\n    String username;\n\n    @Value(\"19\")  // 注意：注解内部需要的是字符串\n    int gae;\n}\n```\n\n如果只是这样用，还不如直接使用`int age = 19`这样的写法直接赋值，`@Value`注解主要用于从配置文件获取数据注入的场景。和使用 xml 类似，我们需要先将`properties`文件的路径配置到 xml 文件中，然后直接使用`${}`来获取。\n\n```xml\n<!-- 配置 properties 文件路径 -->\n<context:property-placeholder location=\"classpath:data.properties\"/>\n```\n\n```java\n@Component\npublic class User {\n    @Value(\"${username}\")  // 使用小脚本直接获取配置文件的内容\n    String username;\n}\n```\n\n### 配置类\n目前为止，我们学了如何使用注解配置 Spring。但还是没有完全摆脱 xml 文件，例如：\n\n+ 我们需要使用 xml 配置扫描包，不然注解无法生效；\n+ 我们需要使用 xml 导入`properties`文件，否则无法使用小脚本；\n+ 对于三方库的类，我们无法使用注解配置它们；\n\n为了解决这些问题，Spring 支持我们创建配置类来完全摆脱 xml。\n\n#### 基本使用\n```java\n@PropertySource(\"classpath:data.properties\")\n@ComponentScan(\"com.luyan\")\n@Configuration\npublic class JavaConfiguration {\n}\n```\n\n我们创建了一个类`JavaConfiguration`，我们习惯上把这个类放到`config`包下。我们为这个类添加了三个注解：\n\n+ `@Configuration`注解表示将当前类作为配置类；\n+ `@ComponentScan`注解用来指定扫描的包，当需要指定多个包时可以传`{\"package1\", \"package2\"}`，实际上就是给一个字符串数组赋值；\n+ `@PropertySource`注解用来指定配置文件，当需要指定多个配置文件时可以传`{\"path1\", \"path2\"}`，也是给一个字符串数组赋值；\n\n当然我们光创建配置类是没有用的，我们需要在创建 Spring 容器的时候指定配置类才行。我们这边创建`AnnotationConfigApplicationContext`：\n\n```java\nApplicationContext applicationContext \n    = new AnnotationConfigApplicationContext(JavaConfiguration.class);\n```\n\n#### 配置三方类对象\n##### 基本使用\n下面看看如何配置三方库里面的对象，假设我们有一个三方库的类`ThirdPart`，我们可以：\n\n```java\n@ComponentScan(\"com.luyan\")\n@Configuration\npublic class JavaConfiguration {\n    @Bean\n    public ThirdPart thirdPart() {\n        ThirdPart thirdPart = new ThirdPart();\n        thirdPart.setUsername(\"root\");\n        thirdPart.setPassword(\"123456\");\n        return thirdPart;\n    }\n}\n```\n\n我们主要需要在配置类里面写一个配置方法，这个方法有以下注意点：\n\n+ 方法必须被`@Bean`注解；\n+ 方法返回值指定为你需要配置的对象的类型；\n+ 方法名默认会作为这个对象在容器里的`id`；\n\n我们只需要在这个方法里面写创建对象的过程，并将创建的对象返回即可。\n\n##### 修改 bean id\n上面我们说默认会使用方法名作为该对象在容器里的`id`，我们可以通过修改`@Bean`注解里面的`name/value`属性修改其`id`：\n\n```java\n@Bean(\"anotherId\")\n// @Bean(name = \"anotherId\")\npublic ThirdPart thirdPart(){\n    // ...\n}\n```\n\n##### 周期方法\n如果我们想给三方库的对象添加初始化与销毁方法，可以指定`@Bean`注解里面的`initMethod`和`destroyMethod`属性：\n\n```java\n@Bean(value = \"thirdId\", initMethod = \"init\", destroyMethod = \"destroy\")\npublic ThirdPart thirdPart(){\n    // ...\n}\n```\n\n只需要在`initMethod`和`destroyMethod`属性里面填写对应的方法名即可，周期方法的定义要求与之前是一样。\n\n##### 作用域\n如果我们想给三方对象设置单例还是多例，可以在方法上加一个`@Scope`注解：\n\n```java\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)  // 多例\n@Bean(value = \"thirdId\")\npublic ThirdPart thirdPart(){\n    // ...\n}\n```\n\n##### 基础类型注入\n很多时候我们创建三方对象的时候，需要注入一些数据进去。我们先看看基本数据类型的注入，一种方式是直接写数据的字面量就像上面使用的`thirdPart.setUsername(\"root\")`；如果要注入的数据存在于`properties`文件里面，此时如何注入呢？\n\n一种解决方案如下，定义类变量并使用`@Value`将属性注入进去，然后在方法里面访问变量的值即可。\n\n```java\n@PropertySource(\"classpath:data.properties\")\n@ComponentScan(\"com.luyan\")\n@Configuration\npublic class JavaConfiguration {\n    @Value(\"${username}\")\n    private String username;\n    @Value(\"${password}\")\n    private String password;\n\n    @Bean\n    public ThirdPart thirdPart() {\n        ThirdPart thirdPart = new ThirdPart();\n        thirdPart.setUsername(username);\n        thirdPart.setPassword(password);\n        return thirdPart;\n    }\n}\n```\n\n第二种方案是直接对参数做`@Value`注解，如下：\n\n```java\n@Bean\npublic ThirdPart thirdPart(\n        @Value(\"${username}\") String username, \n        @Value(\"${password}\") String password) {\n    ThirdPart thirdPart = new ThirdPart();\n    thirdPart.setUsername(username);\n    thirdPart.setPassword(password);\n    return thirdPart;\n}\n```\n\n上面两种方法都可以实现读取`properties`文件，一般情况下数据需要被多个方法共享的，使用定义变量的方式，如果数据只有某个方法需要那就直接使用参数注入的方式。\n\n##### 引用类型注入\n引用类型数据的注入，有两种方式：\n\n1. 当数据也是在 Java 配置类里面使用`@Bean`注解的时候，我们可以直接调用对应的方法\n\n```java\n@Bean\npublic ThirdPart thirdPart(\n        @Value(\"${username}\") String username,\n        @Value(\"${password}\") String password) {\n    ThirdPart thirdPart = new ThirdPart();\n    thirdPart.setUsername(username);\n    thirdPart.setPassword(password);\n    return thirdPart;\n}\n\n@Bean\npublic ThirdService thirdService() {\n    ThirdService thirdService = new ThirdService();\n    // 需要一个 ThirdPart，直接调用上面的方法获取\n    // 需要参数的话随便写，反正上面的参数是注入进去的与实参无关\n    thirdService.setContent(thirdPart(null, null));\n    return thirdService;\n}\n```\n\n2. 数据不是在 Java 配置类里面定义的，那我们直接通过参数注入\n\n```java\n@Bean\npublic ThirdService thirdService(ThirdPart thirdPart) {\n    ThirdService thirdService = new ThirdService();\n    thirdService.setContent(thirdPart);\n    return thirdService;\n}\n```\n\n这边只是定义了一个形参`thirdPart`，其它什么都没做。但是容器在创建`ThirdService`对象时会自己进行依赖注入，注入时：\n\n    - 若容器里没有`ThirdPart`对象，会报错；\n    - 有唯一的`ThirdPart`对象，会使用这个对象进行注入；\n    - 有多个`ThirdPart`对象，会将形参作为`id`寻找对应的对象，找不到会报错；\n\n第二种方式是推荐的写法！\n\n#### 多个配置类整合\n当我们项目里面定义的配置类比较多的时候，一种方式是创建容器的时候导入多个配置类：\n\n```java\nApplicationContext applicationContext = new AnnotationConfigApplicationContext(\n    JavaConfigurationA.class, JavaConfigurationB.class);\n```\n\n有多少个配置类就需要在构造方法里面引入多少个配置类，写法比较臃肿。\n\n第二个做法是使用`@Import`注解将多个配置类整合成一个，然后创建容器的时候导入那一个就行：\n\n```java\n// 有多少就导多少\n@Import({JavaConfigurationA.class, JavaConfigurationB.class})\n@Configuration\npublic class JavaConfiguration {\n\n}\n```\n\n### 整合测试\n我们写单元测试的时候，第一件事就是创建容器，很烦。于是就有了专门整合 Spring 测试的包，首先导包：\n\n```xml\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-api</artifactId>\n    <version>5.10.2</version>\n    <scope>test</scope>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>5.3.32</version>\n</dependency>\n```\n\n之后创建测试类、编写测试方法：\n\n```java\n@SpringJUnitConfig(JavaConfiguration.class)\npublic class SpringTest {\n    @Autowired\n    private ThirdService thirdService;\n\n    @Test\n    public void test01() {\n        System.out.println(thirdService);\n    }\n}\n```\n\n基本上和之前没有区别，不过多了`@SpringJUnitConfig(JavaConfiguration.class)`。这个注解表示框架会自己帮我们使用`JavaConfiguration`配置类创建一个容器，后面就可以直接按照 Spring 的写法进行依赖注入，简化测试代码的书写。\n\n框架除了能根据配置类创建容器，还可以根据 xml 文件创建容器，不过注解要改成`@SpringJUnitConfig(location=\"classpath:data.properties\")`。\n\n### AOP\nAOP 是面向切面编程，一般的应用场景是在某些方法执行前、执行后、出异常等情况下做一些特殊的处理。例如某些方法只有登录用户才能访问，这就需要在方法执行前做一个验证；再如某些方法在执行的各个阶段需要使用日志记录某些信息。在这些情况下，日志也好、权限验证也罢，这部分代码都是通用的，在每个方法里面写一遍就很冗余，于是出现了面向切面编程。\n\n#### 简单使用\n我们的需求是写一个计算器类，它能够做简单的加减乘除，我们希望在这些方法里面加一点日志输出。使用 Spring AOP 有以下五个步骤：\n\n##### 导包\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-aspects</artifactId>\n    <version>5.3.32</version>\n</dependency>\n```\n\n##### 定义目标类\n```java\n@Component  // 想使用 Spring 框架给这个类创建代理类，这个类必须归容器管\npublic class Calculator {\n    public int add(int i, int j) {\n        return i + j;\n    }\n\n    public int sub(int i, int j) {\n        return i - j;\n    }\n\n    public int mul(int i, int j) {\n        return i * j;\n    }\n\n    public int div(int i, int j) {\n        return i / j;\n    }\n}\n```\n\n需要被代理的类已经定义好了，需要被增强的方法也写好了。\n\n##### 定义切面类\n我们把增强的代码写到切面类中（这个类一般放在`advice`包里）：\n\n```java\n@Aspect  // 切面类需要 @Aspect 注解\n@Component  // 切面类也需要归容器管\npublic class LogAdvice {\n    @Before(\"execution(* com.luyan.service.*.*(..))\")\n    public void before() {\n        System.out.println(\"方法开始了\");\n    }\n\n    @AfterReturning(\"execution(* com.luyan.service.*.*(..))\")\n    public void afterReturning() {\n        System.out.println(\"方法返回了\");\n    }\n\n    @AfterThrowing(\"execution(* com.luyan.service.*.*(..))\")\n    public void afterThrowing() {\n        System.out.println(\"方法出异常了\");\n    }\n\n    @After(\"execution(* com.luyan.service.*.*(..))\")\n    public void after() {\n        System.out.println(\"方法finally了\");\n    }\n}\n```\n\n增强方法都是打印一句话。重点介绍一下各个与增强相关的注解：\n\n+ `@Before`标注前置增强；\n+ `@AfterReturning`标注后置增强；\n+ `@AfterThrowing`标注异常增强；\n+ `@After`标注 finally 增强；\n+ `@Around`标注环绕增强；\n\n这些注解都表示一种位置，即增强的代码放在哪。例如我们需要增强`add`方法，容器会创建一个代理类，各个增强的位置如下伪代码：\n\n```java\ntry {\n    // 前置增强的位置\n    add();  // 核心代码\n    // 后置增强的位置\n} catch (Exception e) {\n    // 异常增强的位置\n} finally {\n    // finally 增强的位置\n}\n```\n\n说完了增强相关的注解之后，再看看它们的参数。这些参数都是切点表达式，我们这边都写为`execution(* com.luyan.service.*.*(..))`，这表示这些增强方法会作用在`com.luyan.service`包下所有类中满足：（1）返回值类型任意；（2）方法名任意；（3）方法参数任意；的方法上。\n\n##### 打开代理开关\n下面我们需要打开自动代理开关，可以在 xml 里面配置`<aop:aspectj-autoproxy/>`，也可以在配置类上加`@EnableAspectJAutoProxy`注解。\n\n```java\n@Configuration\n@ComponentScan(\"com.luyan\")\n@EnableAspectJAutoProxy\npublic class JavaConfig {\n}\n```\n\n##### 测试\n```java\n@SpringJUnitConfig(JavaConfig.class)\npublic class SpringTest {\n    @Autowired\n    private Calculator calculator;\n\n    @Test\n    public void testAop() {\n        int res = calculator.add(1, 1);\n        System.out.println(res);\n    }\n}\n```\n\n测试代码中变量`calculator`会自动装配为代理对象，但有一个注意点：如果这个类实现了某个接口，那么需要使用接口来定义变量；没有实现接口，就直接使用自己的类名定义变量。\n\n之所以会这样，是因为 Spring 框架底层做动态代理的时候：\n\n+ 若目标类实现了接口，底层会使用 JDK 代理技术，这种情况下代理类和目标类不是一个类型，但一定实现同一个接口，因此需要使用接口来定义变量。\n+ 若目标类没实现接口，底层会使用 cglib 代理技术，这种情况下代理类是目标类的子类，因此可以直接使用原类型接收。\n\n#### 获取切点信息\n上面简单使用了 AOP 技术，但没什么实用价值。我们在做 AOP 的时候往往想要关注：\n\n1. 切点方法的相关信息：\n    1. 所在类信息；\n    2. 当前的方法名；\n    3. 当前方法的参数；\n2. 切点方法的返回值；\n3. 切点方法产生的异常信息；\n\n##### 方法相关信息\n我们在所有的增强阶段都可以获取方法的相关信息，下面以`@Before`举例：\n\n```java\n@Before(\"execution(* com.luyan.Calculator.*(..))\")\npublic void before(JoinPoint joinPoint) {\n    // 获取目标类信息 class com.luyan.Calculator\n    System.out.println(joinPoint.getTarget().getClass());\n    // 获取增强的方法名 add\n    System.out.println(joinPoint.getSignature().getName());\n    for (Object arg : joinPoint.getArgs()) {  // 获取目标方法的所有参数\n        System.out.println(arg);\n    }\n}\n```\n\n我只需要在增强代码所在的方法上加一个`JoinPoint`类型参数，就可以从这个参数里获取我们需要的信息。具体获取方式看上面的例子。\n\n##### 方法返回值\n获取方法的返回值只能在`@afterReturning`阶段，具体操作如下：\n\n```java\n@AfterReturning(value = \"execution(* com.luyan.Calculator.*(..))\", returning = \"result\")\npublic void afterReturning(int result) {\n    System.out.println(result);\n}\n```\n\n我们只需要在方法上定义一个形参用来接受目标方法的返回值，在`@AfterReturning`注解里使用`returning`属性指定将返回值赋给哪一个形参。\n\n##### 方法异常\n获取目标方法异常只能在`@AfterThrowing`阶段，具体操作如下：\n\n```java\n@AfterThrowing(value = \"execution(* com.luyan.Calculator.*(..))\", throwing = \"throwable\")\npublic void afterThrowing(Throwable throwable) {\n    System.out.println(\"Throw\" + throwable);\n}\n```\n\n与获取返回值类似，我们在方法上定义一个形参用来接受异常，并在`@AfterThrowing`注解里面使用`throwing`属性指定接受异常的形参。\n\n#### 切点表达式\n##### 语法介绍\n切点表达式能够指定增强位置，本节详细介绍一下切点表达式。下面是一个完整的例子：\n\n```java\nexecution(public int com.luyan.Calculator.add(int, int))\n```\n\n`execution()`是固定写法，下面详细介绍一下内部表达式的组成部分：\n\n1. 访问修饰符部分，对应案例的`public`；这个部分可以**省略**，省略表示匹配任意访问修饰符。\n2. 方法返回值类型部分，对应案例的`int`；这边可以使用`*`表示任意返回值类型。\n3. 目标类的全限定名部分，对应案例的`com.luyan.Calculator`；这个部分也可以**省略**，省略表示匹配任意类型。这个部分可以模糊匹配：\n    1. 命名模糊：`com.luyan.service.*tor`匹配`com.luyan.service`包下命名以`tor`结尾的所有类，命名模糊也可以在包上模糊；\n    2. 单层模糊：`com.luyan.*.Calculator`匹配`com.luyan`为根包、`Calculator`为类名、子包任意的情况，子包层数只有一层；\n    3. 多层模糊：`com..Calculator`匹配`com`为根包、`Calculator`为类名、子包任意的情况，子包层数任意；\n4. 方法名部分，对应案例的`add`；可以使用`*`模糊匹配：\n    1. 直接写一个`*`匹配所有方法；\n    2. 写`set*`匹配以`set`开头的所有方法；\n5. 方法参数类型列表，对应案例的`(int, int)`；\n    1. `()`匹配无参方法；\n    2. `(int)`匹配有一个`int`类型参数的方法；\n    3. `(*)`匹配有一个任意类型参数的方法；\n    4. `(..)`匹配任意类型参数的方法；\n    5. `b c d`三种情况可组合使用，例如`(*, int)`、`(String, ..)`、`(*, ..)`；\n\n将这六个部分整合成`1? 2 3?4(5)`形式就是一个完整的切点表达式。\n\n##### 实战练习\n1. 查询某包某类下，访问修饰符公有，返回值类型`int`的所有方法：\n\n```java\npublic int com.luyan.Calculator.*(..)\n```\n\n2. 查询某包某类中第一参数类型为`String`的所有方法：\n\n```java\n* com.luyan.Calculator.*(String, ..)\n```\n\n3. 查询全部包下，无参数的方法：\n\n```java\n* *()  // 省略访问修饰符、返回值类型任意、省略类全限定名、方法名任意、无参\n```\n\n4. 查询`com`包下，以`int`参数类型结尾的所有方法：\n\n```java\n* com..*(.., int)  // 省略了类名\n```\n\n5. 查询某包下类名以`Service`结尾，私有且返回值类型为`int`的所有无参方法：\n\n```java\nprivate int com.luyan.*Service.*()\n```\n\n##### 提取切点表达式\n很多增强方法的切点表达式是一样的，这种情况下挨个写不方便维护。于是我们想提取切点表达式，我们可以将切点表达式提取到当前类之中，也可以单独创建一个类专门存储切点表达式。\n\n```java\n@Pointcut(\"execution(* com.luyan.Calculator.*(..))\")\npublic void pc() {}\n\n@Before(\"pc()\")\npublic void before(JoinPoint joinPoint) {\n    // ...\n}\n```\n\n首先我们定义一个`public void`修饰的空方法`pc`，这个方法使用`@Pointcut`注解，注解里面写上一个切点表达式。下面需要切点表达式的地方直接改成这个方法的调用即可，就像我们这边的`@Before(\"pc()\")`。\n\n上面是将切点表达式提取到当前类中，提取到一个单独类也是一样的。定义一个类，注意这个类要使用`@Component`注解且一般位于`pointcut`包下，里面写上一样的定义方法。用的时候需要写上方法的全限定名，例如`com.luyan.pointcut.MyPointcut.pc()`。\n\n#### 环绕通知\n我们之前看过前置通知、后置通知、异常通知、finally 通知，还剩下一个环绕通知。和其他通知相比，环绕通知可以自定义位置，例如看一个例子：\n\n```java\n@Around(\"com.luyan.pointcut.MyPointcut.pc()\")\npublic Object around(ProceedingJoinPoint joinPoint) {\n    Object result = null;\n    Object[] args = joinPoint.getArgs();\n    try {\n        // 这边写操作相当于前置通知\n        result = joinPoint.proceed(args);  // 执行目标方法\n        // 这边写操作相当于后置通知\n    } catch (Throwable e) {\n        // 这边写操作相当于异常通知\n        throw new RuntimeException(e);  // 把异常抛给调用者\n    } finally {\n        // 这边写操作相当于 finally 通知\n    }\n    return result;\n}\n```\n\n环绕通知方法使用`@Around`注解，注解里面一样写切点表达式。这个方法返回值类型是`Object`，有一个`ProceedingJoinPoint`类型的参数。\n\n+ 我们可以使用`joinPoint.proceed(args)`来调用目标方法，方法运行必要的参数通过`joinPoint.getArgs()`获取；\n+ 目标方法的返回结果作为这个代理方法的返回结果；\n+ 只要在案例中注释的部分写上对应的代码即可；\n\n#### 切面优先级\n有些目标方法上可以能需要多个通知，例如事务相关通知、日志相关通知。如果我想控制通知的优先级怎么办？我们可以在切面类上加注解`@Order(10)\0`，注解里面的值越小代表通知的优先级越高，默认值是`Integer.MAX_VALUE\0`即最小优先级。\n\n```java\n@Aspect\n@Component\n@Order(10)\npublic class LogAdvice {\n    // 切点方法\n}\n```\n\n优先级越高的通知前置通知越先执行，后置通知越后执行。如果有两个通知类似于下面的情况：\n\n```java\ntry {\n    // 前置通知\n    try {\n        // 前置通知\n        target();\n        // 后置通知\n    } catch (Throwable e) {\n        // 异常通知\n    } finally {\n        // finally 通知\n    }\n    // 后置通知\n} catch (Throwable e) {\n    // 异常通知\n} finally {\n    // finally 通知\n}\n```\n\n可以看到不同通知之间是一种层级结构的关系，优先级高的通知在外层，优先级低的通知在内层。\n\n### 事务\n本节主要讲解 Spring 对事务的支持，在此之前我们需要先看一下如何使用`JdbcTemplate\0`操作数据库。而`JdbcTemplate\0`需要一个连接池，国内比较流行的连接池是 Druid 连接池。\n\n#### Druid 连接池\n##### 导包\n```xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.2.22</version>\n</dependency>\n```\n\n##### 创建对象\n```java\nDruidDataSource dataSource = new DruidDataSource();\ndataSource.setDriverClassName(driver);\ndataSource.setUrl(url);\ndataSource.setUsername(username);\ndataSource.setPassword(password);\n```\n\n创建连接池对象的时候往往需要一些数据库相关信息，这些信息我们一般都会封装在一个`properties`文件中：\n\n```plain\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/<数据库名称>\njdbc.username=用户名\njdbc.password=连接密码\n```\n\n#### JdbcTemplate\n##### 导包\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.3.32</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>8.0.33</version>\n</dependency>\n```\n\n##### 创建对象\n```java\nJdbcTemplate jdbcTemplate = new JdbcTemplate();\njdbcTemplate.setDataSource(dataSource);  // 这边一般使用 Druid 连接池对象\n```\n\n##### 增、删、改数据\n`JdbcTemplate`里面有一个`update`方法可以实现增、删、改数据：\n\n```java\npublic int update(final String sql, Object... args)\n```\n\n使用的步骤很简单：（1）创建`JdbcTemplate`对象；（2）定义 sql 语句；（3）调用`update`方法。\n\n```java\n// 插入学生信息\nString sql = \"INSERT INTO students VALUES (NULL, ?, ?);\";\njdbcTemplate.update(sql, \"王五\", \"高三六班\");\n\n// 修改学生信息\nString sql = \"UPDATE students SET class=? WHERE id=?;\";\njdbcTemplate.update(sql, \"高三七班\", 3);\n\n// 删除学生\nString sql = \"DELETE FROM students WHERE id=?;\";\njdbcTemplate.update(sql, 3);\n```\n\n使用很简单，sql 语句里面允许使用`?`作为占位符，调用`update`方法的时候通过参数传递占位符。\n\n##### 查询简单类型\n当我们需要查询的数据是一个数字或字符串时可以使用下面的方法：\n\n```java\npublic <T> T queryForObject(String sql, Class<T> requiredType, Object... args)\n```\n\n```java\nString sql = \"SELECT COUNT(*) FROM students;\";\nlong nums = jdbcTemplate.queryForObject(sql, Long.class);\n\nString sql = \"SELECT id FROM students WHERE sname=?;\";\nint id = jdbcTemplate.queryForObject(sql, Integer.class, \"张三\");\n\nString sql = \"SELECT sname FROM students WHERE id=?;\";\nString name = jdbcTemplate.queryForObject(sql, String.class, 2);\n```\n\n如果查询的值类型与传递进去的类型不一致，会报错！\n\n##### 查询 Map\n`JdbcTemplate`提供了`queryForMap`方法用来将一条记录封装成一个`Map`：\n\n```java\npublic Map<String, Object> queryForMap(String sql, @Nullable Object... args)\n```\n\n这个方法返回若干个键值对，键是字段名，值是字段值。\n\n```java\nString sql = \"SELECT * FROM students WHERE id=?;\";\n// {id=2, sname=李四, class=高一五班}\nMap<String, Object> stu = jdbcTemplate.queryForMap(sql, 2);\n```\n\n如果查询的记录不止一条，会报错！\n\n##### 查询 List\n`JdbcTemplate`提供了`queryForList`方法将多条记录封装成`List`：\n\n```java\npublic List<Map<String, Object>> queryForList(String sql, Object... args)\n```\n\n显然这个方法会将每一条记录封装成`Map<String, Object>`，然后放进一个`List`里面：\n\n```java\nString sql = \"SELECT * FROM students;\";\nList<Map<String, Object>> students = jdbcTemplate.queryForList(sql);\n```\n\n##### 查询对象\n除此之外`JdbcTemplate`还支持返回自定义对象列表：\n\n```java\npublic <T> List<T> query(String sql, RowMapper<T> rowMapper, Object... args)\n```\n\n`RowMapper`是一个接口，里面有唯一的方法`mapRow\0`。我们需要在这个方法里面生成自定义对象：\n\n```java\nString sql = \"SELECT * FROM students WHERE class LIKE \'高一%\';\";\nList<Student> students = jdbcTemplate.query(sql, new RowMapper<Student>() {\n    @Override\n    public Student mapRow(ResultSet rs, int rowNum) throws SQLException {\n        Student user = new Student();\n        user.setId(rs.getInt(\"id\"));\n        user.setName(rs.getString(\"sname\"));\n        user.setClazz(rs.getString(\"class\"));\n        return user;\n    }\n});\n```\n\n`mapRow`方法会传进来一个结果集，我们要做的就是将结果集映射到自定义对象。\n\n我们每次查询对象都这么映射就显得很麻烦，官方提供了一个`RowMapper`的实现类`BeanPropertyRowMapper`，它能帮我们将数据库字段与实体类变量映射起来：\n\n```java\nString sql = \"SELECT id, sname AS name, class AS clazz FROM students;\";\nList<Student> students = jdbcTemplate.query(\n    sql, new BeanPropertyRowMapper<>(Student.class));\n```\n\n如果实体类与数据库字段不匹配，那么查询的时候使用`as`关键字改一下名字。\n\n#### Spring 事务\n##### 导包\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-tx</artifactId>\n  <version>5.3.32</version>\n</dependency>\n```\n\n##### 配置事务管理器\n首先我们需要将事务管理器配置到 Spring 容器中，因为这是三方类，所以在配置类中定义：\n\n```java\n@Bean\npublic TransactionManager transactionManager(DataSource dataSource) {\n    DataSourceTransactionManager tm = new DataSourceTransactionManager();\n    tm.setDataSource(dataSource);  // 这边使用 Druid 连接池即可\n    return tm;\n}\n```\n\n##### 简单使用事务\n我们下面在需要使用事务的方法上添加`@Transactional`注解即可：\n\n```java\n@Transactional\npublic void update() {\n    String sql = \"UPDATE students SET class=? WHERE id=?\";\n    jdbcTemplate.update(sql, \"初中一班\", 1);\n    int k = 1 / 0;  // 模拟出错，测试事务是否开启成功\n    jdbcTemplate.update(sql, \"初中二班\", 2);\n}\n```\n\n##### 只读事务\n`@Transactional`注解除了可以加在方法上，还可以加在类上。这种情况下该类里面所有的方法都会被加上事务，这就会产生一个问题：如果一个方法里面只会查询数据而不会修改数据，但因为类上有事务注解导致这个查询方法上面也有了事务，这就会降低查询代码的执行效率。\n\n解决方案是在只读方法上加注解`@Transactional(readOnly = true)\0`来覆盖掉类上的注解，可以发现注解里面多了一个`readOnly`参数，这表示这是只读事务，效率就会提升很多。\n\n```java\n@Component\n@Transactional\npublic class UserDao {\n\n    @Transactional(readOnly = true)\n    public void getXXX() {\n        // ...\n    }\n}\n```\n\n##### 事务超时\n有时候因为我们代码的问题，导致一个事务方法执行了很长时间，这会占用大量的资源。因此我们一般会给事务方法添加一个超时时间，即超过指定时长还没结束的事务方法将会被回滚。\n\n```java\n@Transactional(timeout = 3)  // 单位是秒\npublic void update() {\n    String sql = \"UPDATE students SET class=? WHERE id=?\";\n    jdbcTemplate.update(sql, \"py中一班\", 1);\n    try {\n        Thread.sleep(4000);\n    } catch (InterruptedException e) { }\n    jdbcTemplate.update(sql, \"java中一班\", 2);\n}\n```\n\n显然这个方法不能在三秒内结束，因此三秒后这个程序会抛出`TransactionTimedOutException`异常。但是有趣的是，如果程序卡住的位置已经没有数据库操作了，是不会抛异常的：\n\n```java\n@Transactional(timeout = 3)\npublic void update() {\n    String sql = \"UPDATE students SET class=? WHERE id=?\";\n    jdbcTemplate.update(sql, \"py中一班\", 1);\n    try {\n        Thread.sleep(4000);\n    } catch (InterruptedException e) {}\n}\n```\n\n可以看到程序在卡住之前所有的数据库操作已经做完了，这种情况下是不会抛异常的，会一直等待下去直到运行结束或出现其它异常。\n\n##### 异常指定\n我们使用`@Transactional`直接添加事务之后，如果一个方法执行期间抛出`RuntimeException`则会执行回滚操作，否则会执行提交操作。我们知道，`Exception`里面除了`RuntimeException`还有`IOException`与`SQLException`。也就是说如果代码运行期间抛出这两个异常，事务也会被提交，这显然是不合理的，我们可以使用`rollbackFor`属性指定回滚的异常：\n\n```java\n// 指定为 Exception 表示所有异常都会回滚\n@Transactional(rollbackFor = Exception.class)\npublic void update() {\n    // 数据库操作\n}\n```\n\n除此之外，还可以使用`noRollbackFor`属性指定遇到什么异常不回滚。\n\n##### 隔离级别设置\n数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：\n\n+ 读未提交（Read Uncommited）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用；\n+ 读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读；\n+ 可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改，可以避免脏读和不可重复读，但仍有幻读的问题；\n+ 串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。\n\n下面解释一下什么叫脏读、不可重复读、幻读：\n\n+ 脏读：事务内读取到其它事务未被提交的数据，这显然是不合理的；\n+ 不可重复读：一次事务内读取到其它事务已经提交的修改数据，导致两次读取结果不同；\n+ 幻读：一次事务内读取到其它事务已经提交的插入数据，导致两次读取结果不同；\n\n在 Spring 事务内可以使用`@Transactional`注解的`isolation`属性来指定隔离级别：\n\n```java\n// 设置为第二级别\n@Transactional(isolation = Isolation.READ_COMMITTED)\npublic void update() {\n    // 数据库操作\n}\n```\n\n隔离级别默认是第三级，我们常用的是第二级，因为第二级并发效率较高。\n\n##### 传播行为\n事务传播行为是指在一个事务方法内部调用另一个事务方法（下面我们简称为父事务与子事务），这个子事务是继承父事务还是开新事务。我们可以在子事务方法上加注解来指定传播行为，一般常用的传播行为有两个：\n\n+ `Propagation.REQUIRED`**默认值**，如果父方法有事务就使用父方法的事务，否则就开新事务；\n+ `Propagation.REQUIRES_NEW`无论父方法是否有事务，都新开事务；\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void update() {\n    // 数据库操作\n}\n```\n\n常见的应用：Service 层有一个方法调用两个 Dao 层的方法，并且想让这两个方法要么都成功，要么都失败。就可以让这两个 Dao 层方法与 Service 层的方法共用一个事务，这样不论谁报错，整体都会回滚。\n\n但是要注意，如果父方法与子方法在一个类里定义，是不能共享事务的。也就是说，父事务方法与子事务方法不能在同一个类里定义。\n\n\n\n\n\n\n'),
       (12, 12, 'MyBatis 是一款用于持久层的、轻量级的半自动化 ORM 框架，封装了所有 jdbc 操作以及设置查询参数和获取结果集的操作，支持自定义 sql、存储过程和高级映射。\n\n### 快速入门\n#### 导包\nMyBatis 需要导两个包，一个是连接数据库的`mysql-connector-java`，一个是`mybatis`：\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.33</version>\n</dependency>\n\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.15</version>\n</dependency>\n```\n\n#### 使用\n使用 MyBatis 操作数据库主要有 4 个步骤：\n\n+ 定义数据库操作的接口；\n+ 编写 mapper 文件；\n+ 编写 MyBatis 核心配置文件；\n+ 编写代码操作数据库；\n\n##### 定义操作接口\n我们会定义接口用来表示需要那些数据库操作。接口里面定义一些操作数据库的方法声明，包括需要什么参数、返回什么类型数据等。\n\n```java\npublic interface StudentMapper {\n    // 目前只定义了一个方法，按照 id 查询学生\n    Student queryById(int id);\n}\n```\n\n##### 编写 mapper 文件\n光有接口不行，每一个操作最终都是需要翻译成 sql 语句的。因此就出现了 mapper 文件，一个 mapper 文件与一个接口对应，我们一般将 mapper 文件放到`resources/mappers/`目录下。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<!-- namespace 里面填写与之对应的接口全限定名 -->\n<mapper namespace=\"com.luyan.mappers.StudentMapper\">\n    <!-- id 对应着接口内的一个方法 -->\n    <select id=\"queryById\" resultType=\"com.luyan.bean.Student\">\n        SELECT id, sname AS name, class AS clazz FROM students WHERE id=#{id}\n    </select>\n</mapper>\n```\n\n根据数据库操作类型，mapper 文件中可以定义`insert、delete、update、select`操作标签，上面案例使用`select`标签表示查询数据信息。关于操作标签有以下注意事项：\n\n+ 每个操作标签都有`id`属性用来与接口内方法绑定，即一个方法对应一个标签。标签的主要职责就是提供 sql 语句，因此我们不能在接口内定义重载方法，否则标签无法明确与谁绑定；\n+ 对于`select`标签我们可以使用`resultType`属性来指定返回值类型，MyBatis 会自动根据字段名称将记录映射为实体类；\n    - 对于表字段名和类变量名不一致的情况，sql 语句使用`as`关键字改成一样的名称；\n+ 其它非选择语句虽然没有指定返回值类型，但都会返回一个整数表示受影响的记录条数；\n+ 在 sql 语句中可以使用`#{key}`的方式获取接口方法的形参，具体 key 怎么写后面看；\n\n##### 核心配置文件\n目前数据库操作有哪些、每个操作需要什么参数、返回什么数据等信息都通过接口定义好了，对于每一个操作 sql 语句这么写也通过 mapper 文件定义好了。但是连接数据库总得需要一些连接信息吧？若定义多个 mapper 文件，哪些 mapper 文件是有效的？这些信息由 MyBatis 核心配置文件指定：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- environments 里面放若干个环境，使用 default 指定使用哪一个环境的配置 -->\n    <environments default=\"development\">\n        <!-- environment 标签配置具体环境，使用 id 作为不同环境的唯一标识 -->\n        <environment id=\"development\">\n            <!-- MyBatis 默认的事务管理器 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 配置数据源信息 -->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/demo\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"mysql2425@\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <mappers>\n        <!-- 使用 mapper 标签注册定义的 mapper 文件 -->\n        <mapper resource=\"mappers/StudentMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n之所以分环境，是因为项目中生产与开发条件下连接的数据库信息是不一样的。\n\n##### 编码\n编写代码有固定的套路，主要看下面的例子：\n\n```java\n// 1. 读取 mybatis 核心配置文件\nInputStream ips = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\n// 2. 创建 SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips);\n\n// 3. 开启 SqlSession，每次业务都开启一个，用完就释放\nSqlSession sqlSession = sqlSessionFactory.openSession();\n\n// 4. 创建接口的代理对象并使用\nStudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\nStudent student = mapper.queryById(2);\nSystem.out.println(student);\n\n// 5. 提交事务 & 释放资源\nsqlSession.commit();\nsqlSession.close();\n```\n\n### 参数传递\n#### 取值\n我们在 mapper 文件的操作标签中可以使用`#{}`来获取传递的参数，除此之外还可以使用`${}`来获取参数，那么两者有什么区别？\n\n使用`#{}`获取参数相当于使用占位符构造 sql 语句，看下面的例子：\n\n```java\nSELECT * FROM students WHERE id = #{id}\n\n=====>\n\nString sql = \"SELECT * FROM students WHERE id = ?\";\nselect(sql, id);  // 使用占位符，并在代码里注入参数\n```\n\n使用`${}`获取参数相当于直接使用字符串拼接，例如：\n\n```java\nSELECT * FROM students WHERE id = #{id}\n\n=====>\n\nString sql = \"SELECT * FROM students WHERE id = \" + id;\nselect(sql);  // 这边 sql 语句是直接进行字符串拼接的\n```\n\n很显然使用`#{}`可以有效防止 sql 注入攻击，因此当两者都可以使用的时候我们倾向于使用`#{}`。\n\n那什么情况下只能使用`${}`呢？答：当参数不是表示数据的时候。例如我可能根据 id 查询学生，也有可能根据姓名查询学生，这种情况下数据表字段是变量，此时就不能使用`#{}`。\n\n```java\nSELECT * FROM students WHERE ${key} = #{value}\n```\n\n这个例子就是查询的字段及其值都由参数指定。\n\n#### 单简单类型传参\n接口方法定义为：\n\n```java\nStudent queryById(int id);\n```\n\n对应的 mapper 标签定义为：\n\n```xml\n<select id=\"queryById\" resultType=\"com.luyan.bean.Student\">\n    SELECT id, sname name, class clazz FROM students WHERE id=#{xx}\n</select>\n```\n\n参数只有一个简单类型，此时在 xml 里面使用插值表达式获取参数的时候 key 随意。就像这边`#{xx}`，key 值不需要与接口方法的参数一致，但推荐一致。\n\n#### 多简单类型传参\n接口方法定义为：\n\n```java\nStudent queryByNameClass(String name, String clazz);\n```\n\n这种情况下 mapper 有三种写法：\n\n1. 使用`arg0...`根据下标获取参数：\n\n```xml\n<select id=\"queryByNameClass\" resultType=\"com.luyan.bean.Student\">\n    SELECT id, sname name, class clazz FROM students \n      WHERE sname=#{arg0} and class=#{arg1}\n</select>\n```\n\n2. 使用`param1...`根据下标获取参数：\n\n```xml\n<select id=\"queryByNameClass\" resultType=\"com.luyan.bean.Student\">\n    SELECT id, sname name, class clazz FROM students \n      WHERE sname=#{param1} and class=#{param2}\n</select>\n```\n\n3. 使用`@Param`注解给参数指定 key 名：\n\n```java\n// 给两个参数分别指定 key 值为 a 与 b\nStudent queryByNameClass(@Param(\"a\") String name, @Param(\"b\") String clazz);\n```\n\n```xml\n<select id=\"queryByNameClass\" resultType=\"com.luyan.bean.Student\">\n    SELECT id, sname name, class clazz FROM students \n      WHERE sname=#{a} and class=#{b}\n</select>\n```\n\n此时 xml 里面根据设定的 key 获取参数，而且这么使用之后`arg0、param1`之类的就失效了。\n\n我们当然推荐使用第三种方式，并且推荐起的名字与参数名一致。\n\n#### 单对象传参\n接口方法定义为：\n\n```java\nint addOne(Student student);\n```\n\n对应的 mapper 标签定义为：\n\n```xml\n<insert id=\"addOne\">\n    INSERT INTO students (sname, class) VALUES (#{name}, #{clazz})\n</insert>\n```\n\n这种情况直接将实体类对象传到方法里，xml 取值的时候 key 值直接指定为实体类的属性名。\n\n#### Map 传参\n接口方法定义为：\n\n```java\nint addOneMap(Map<String, Object> data);\n```\n\n方法调用代码为：\n\n```java\nHashMap<String, Object> studentMap = new HashMap<>();\nstudentMap.put(\"name\", \"赵六\");\nstudentMap.put(\"class\", \"小学六年级\");\nmapper.addOneMap(studentMap);\n```\n\n对应的 mapper 标签定义为：\n\n```xml\n<insert id=\"addOneMap\">\n    INSERT INTO students (sname, class) VALUES (#{name}, #{class})\n</insert>\n```\n\n显然 xml 获取参数的 key 就是 Map 的键。\n\n### 返回值\n#### 返回值别名\n我们之前说过在 mapper 里面使用`select`标签可以通过`resultType\0`属性指定返回值类型，之前我们使用类的全限定名来指定这个类型。下面我们详细说一下返回值类型的三种写法。\n\n```xml\n<select id=\"queryByNameClass\" resultType=\"com.luyan.bean.Student\">\n    ...\n</select>\n```\n\n##### 全限定符\n这个很简单，不论是自定义类还是 Java 给我们提供的类都可以使用这种方式，例如`com.luyan.bean.Student`、`java.lang.String`等。\n\n##### MyBatis 默认别名\n对于一些常用的系统类型，我们每次都写全限定符很麻烦。MyBatis 给这些常用系统类型都提供了别名：\n\n1. 基本数据类型的别名就是在前面加一个`_`：`byte -> _byte`、`int -> _int`、`double -> _double`、`boolean -> _boolean`……\n2. 包装类型的别名就是首字母小写：`Short -> short`、`Long -> long`、`Float -> float`、`Integer -> integer | int`……\n3. 其它一些常见类型基本都是改成全小写形式：\n\n| **类型** | **别名** |\n| :---: | :---: |\n| Date | date |\n| Object | object |\n| Map | map |\n| HashMap | hashmap |\n| List | list |\n| ArrayList | arraylist |\n| Collection | collection |\n| Iterator | iterator |\n\n\n事实上这些别名都是不区分大小写的，但我们默认还是按照规范来。\n\n##### 自定义别名\n除了这些默认定义的别名，MyBatis 还支持我们自定义别名。此时我们需要在 MyBatis 核心配置文件里面通过`typeAliases`标签进行配置，但是注意核心配置文件里面的标签是有顺序关系的，具体如下：\n\n+ configuration（配置)\n    - properties（属性）\n    - settings（设置）\n    - typeAliases（类型别名）\n    - typeHandlers（类型处理器）\n    - objectFactory（对象工厂）\n    - plugins（插件）\n    - environments（环境配置）\n        * environment（环境变量）\n            + transactionManager（事务管理器）\n            + dataSource（数据源）\n    - databaseldProvider（数据库厂商标识）\n    - mappers（映射器）\n\n###### 单个定义\n做如下配置即可为某个类起一个别名，自定义的别名也是忽略大小写的。\n\n```xml\n<typeAliases>\n    <typeAlias type=\"com.luyan.bean.Student\" alias=\"Student\"/>\n</typeAliases>\n```\n\n这种方式起别名当类比较多的时候比较麻烦。\n\n###### 批量定义\n除了挨个为类起别名，MyBatis 还支持批量为某个包及其子包下的所有类起别名，默认的起别名规则就是类名的首字母小写（其实起的别名不区分大小写）。\n\n```xml\n<typeAliases>\n    <package name=\"com.luyan.bean\"/>\n</typeAliases>\n```\n\n例子中包`com.luyan.bean`及其子包下的所有类都会被起一个别名。\n\n在批量起别名的基础上，如果我们想给一个类指定别名，可以使用`@Alias\0`注解：\n\n```java\n@Alias(\"stu\")  // 将当前类起别名为 stu\npublic class Student {\n    ...\n}\n```\n\n**注意：**`@Alias`注解一定是配合批量起别名的。\n\n#### 属性映射\n我们在 mapper 的`select`标签里面，可以通过`resultType\0`属性设置返回值类型。我们知道 Java 推荐驼峰命名，而数据库推荐下划线命名，因此数据表字段与实体类属性名经常会不一致。名称不一致 MyBatis 就无法将查询的记录映射成实体类，下面有三种解决方案。\n\n##### 数据库查询别名\n我们在写 sql 语句的时候为查询到字段起别名即可：\n\n```xml\n<select id=\"queryByNameClass\" resultType=\"com.luyan.bean.Student\">\n    SELECT id, sname name, class clazz FROM students\n</select>\n```\n\n查询 sql 里面的`AS`关键字可以省略，所以直接写形如`class clazz`即可。\n\n##### 开启驼峰映射\n大部分情况下，即使数据表字段名与实体类属性名不一致，但基本结构是相似的，例如`stuName`与`stu_name`的关系。MyBatis 可以支持配置将数据库读取出来的下划线命名映射到实体类时使用驼峰命名，我们只需要在 MyBatis 核心配置文件的`settings`标签中添加以下配置：\n\n```xml\n<settings>\n    <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n</settings>\n```\n\n**注意：**这个配置是拿到查询结果之后，找实体类属性的时候会使用驼峰式命名寻找，并不是直接返回驼峰式的命名。之所以关注这个是因为`3.3`返回 Map 的时候，即使开启了这个开关，返回的字段名也还是下划线形式的。\n\n##### 自定义映射规则\n对于一些深层次的映射或者数据表字段名与实体类属性名差异较大的情况，上面的两种方式就没办法处理了。MyBatis 支持我们自定义映射规则，具体操作如下：\n\n```xml\n<!--  id 是这个 resultMap 的唯一标识\n      type 用来指定这个映射作用在哪一个类里面，这边是给学生类起别名了 -->\n<resultMap id=\"studentMap\" type=\"student\">\n    <!-- id 标签用来指定数据库主键的映射，result 标签指定其它属性的映射 -->\n    <id column=\"id\" property=\"id\"/>\n    <result column=\"sname\" property=\"name\"/>\n    <result column=\"class\" property=\"clazz\"/>\n</resultMap>\n\n<!-- resultMap 属性用来指定使用哪一个映射，这个属性和 resultType 二选一 -->\n<select id=\"queryById\" resultMap=\"studentMap\">\n    SELECT * FROM students WHERE id=#{id}\n</select>\n```\n\n#### 返回 Map\n有时候查询的数据并没有对应的实体类，例如我想查询某字段的最大值、最小值、平均值等信息。我们为了这个需求设计一个实体类不太合理，此时我们就可以将返回值类型设为`Map`。\n\n接口方法定义如下：\n\n```java\nMap<String, Object> queryMapById(int id);\n```\n\n对应的 mapper 如下：\n\n```xml\n<select id=\"queryMapById\" resultType=\"map\">\n    ...\n</select>\n```\n\n这边的返回值类型我们使用的是 MyBatis 提供的默认别名`map`，Map 中 key 由查询的字段名组成，value 就是查询的值。\n\n#### 返回 List\n很多时候我们需要查询的结果是一个集合，那么这种情况下返回值类型怎么写呢？\n\n答：直接写集合的泛型类型即可，看下面两个例子：\n\n```java\nList<Student> queryAll();\nList<String> queryAllNames();\n```\n\n与之对应的 mapper 如下：\n\n```xml\n<!-- 要的是 List<Student>，但我们返回类型只写 student -->\n<select id=\"queryAll\" resultType=\"student\">\n    SELECT * FROM students\n</select>\n\n<!-- 要的是 List<String>，但我们返回类型只写 string -->\n<select id=\"queryAllNames\" resultType=\"string\">\n    SELECT stu_name FROM students\n</select>\n```\n\n其中`string`是 MyBatis 的默认别名，`student`是我们自定义的别名。\n\n#### 自增长主键回显\n日常开发中，我们往往会使用自增长的整数作为数据表的主键。那么就会有这样的使用场景：我想要插入一条数据到数据库中，并且插入完成我想获取到新记录的 id。\n\nmapper 文件定义的插入标签如下：\n\n```xml\n<insert id=\"addOne\" useGeneratedKeys=\"true\" keyColumn=\"stu_id\" keyProperty=\"stuId\">\n    INSERT INTO students (stu_name, stu_class) VALUES (#{stuName}, #{stuClass})\n</insert>\n```\n\n这边新出现三个属性：\n\n+ `useGeneratedKeys`表示是否使用自增长主键；\n+ `keyColumn`指定数据库中自增长主键的字段名；\n+ `keyProperty`指定获取到主键值放到实体类的哪一个变量中；\n\n对应的接口方法与测试代码如下：\n\n```java\n// 接口方法\nint addOne(Student student);\n\n// 测试代码\nStudent s = new Student(\"哇哈哈\", \"小学五年级\");\nint rows = mapper.addOne(s);  // 传学生对象进去\nSystem.out.println(s);  // 插入成功后，对象 s 的 stuId 属性会将被赋值为主键值\nSystem.out.println(rows);  // rows 是受影响记录条数\n```\n\n#### 非自增长主键维护\n项目中一般会使用 UUID 作为非自增长主键，假设我们有一张`teachers`表，表里就两个字段：\n\n+ `t_id`主键，字符串类型；\n+ `t_name`表示教师姓名，字符串类型；\n\n##### 传统写法\n因为主键不是自增长的了，所以主键现在需要我们自己去维护，如下：\n\n```java\n// 接口方法\nint addOne(Teacher teacher);\n\n// 测试代码，需要我们自己生成主键\nString tId = UUID.randomUUID().toString().replace(\"-\", \"\");\nTeacher teacher = new Teacher(tId, \"张老师\");\nmapper.addOne(teacher);\n```\n\n对应的 mapper 如下：\n\n```xml\n<insert id=\"addOne\">\n    INSERT INTO teachers (t_id, t_name) VALUES (#{tId}, #{tName})\n</insert>\n```\n\n一般字符串类型的主键我们会选择使用 UUID，代码很常规没什么好说的。\n\n##### MyBatis 维护\n我们主键的生成可以交给 MyBatis，具体操作如下：\n\n```java\n// 测试代码，这边不需要给实体类赋主键值\nTeacher teacher = new Teacher();\nteacher.settName(\"王老师\");\nmapper.addOne(teacher);\nSystem.out.println(teacher.gettId());  // 此时对象的 tId 属性已经被赋值\n```\n\n对应的 mapper 如下：\n\n```xml\n<insert id=\"addOne\">\n    <selectKey order=\"BEFORE\" resultType=\"string\" keyProperty=\"tId\">\n        SELECT REPLACE(UUID(), \"-\", \"\")\n    </selectKey>\n    INSERT INTO teachers (t_id, t_name) VALUES (#{tId}, #{tName})\n</insert>\n```\n\n这边主要需要关注一下`selectKey`标签，这个标签内部也写着 sql 语句。主要的属性有：\n\n+ `order`用来指定`selectKey`内部 sql 语句的执行时机：\n    - `BEFORE`表示执行在主 sql 语句之前；\n    - `AFTER`表示执行在主 sql 语句之后；\n+ `resultType`用来指定内部 sql 语句的返回值类型；\n+ `keyProperty`用来指定将内部 sql 语句的返回值赋给哪一个变量；\n\n因此本例的解读：在执行插入 sql 语句之前先执行`selectKey`内部的 sql 语句生成一个字符串赋值给传进来对象的`tId`属性。\n\n#### Lombok\n我们每定义一个实体类就要去写对应的`getter/setter`与`toString`，还是比较麻烦。我们可以使用`Lombok`简化书写，主要分为以下几个步骤。\n\n##### 安装插件\n如右图，我们在 IDEA 里面安装`Lombok`插件。\n\n![](/upload/covers/282bd52f77d44233b7298e64a1452e0d.png)\n\n##### 导包\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.30</version>\n</dependency>\n```\n\n##### 使用`@Data`注解\n```java\n@Data\npublic class Teacher {\n    private String tId;\n    private String tName;\n}\n```\n\n直接使用`@Data`注解修饰一个类，`Lombok`会帮我们添加对应的`getter/setter`和`toString`。\n\n更多关于 Lombok 的使用看以下笔记：\n\n[5. 常用三方库](https://space-jiangsu.yuque.com/bcsfg9/ia5lzr/isn6ix9dwqfpsw31#LIHSc)\n\n### 多表查询\n日常开发中我们时常会遇到多表查询的需求，例如客户与订单的关系，一个客户有多个订单，一个订单只属于一个客户。客户与订单的详细信息分别存储在`customer`与`order`表中，我们想要在查询客户的时候把这个客户的所有订单信息都带上，或者查询订单的时候把这个订单所属的客户带上。这些都是多表查询的案例，下面我们将通过这个例子进行学习。\n\n#### 实体类设计\n显然我们需要设计两个实体类，分别是`Customer`与`Order`。\n\n为了体现一个订单属于一个客户，我们在`Order`类中定义一个`Customer`类型的变量用来表示这个订单所属的客户：\n\n```java\n@Data\npublic class Order {\n    private int orderId;\n    private String orderName;\n    private int customerId;  // 数据库字段全要有，即使下面有了专门的客户字段\n\n    private Customer customer;  // 存储该订单的所属用户\n}\n```\n\n为了体现一个客户有多个订单，我们在`Customer`类中定义一个`List<Order>`类型的变量用来表示这个客户拥有的多个订单：\n\n```java\n@Data\npublic class Customer {\n    private int customerId;\n    private String customerName;\n\n    private List<Order> orders;  // 存储该用户的所有订单\n}\n```\n\n有一个小注意点，我们查询的时候不要“螺旋赋值”。举个例子，我们查询订单的时候需要把对应的客户也查到，但是这个客户里面的订单集合赋值为`null`即可；相应的我们查询客户的时候需要查找这个客户对应的所有订单，这些订单的所属客户也赋值为`null`就行了。\n\n#### 对一关系查询\n我们想要按照 id 查询一个订单，并将这个订单的所属客户查出来。对应接口定义如下：\n\n```java\npublic interface OrderMapper {\n    Order queryById(int id);\n}\n```\n\n与之对应的 mapper 文件：\n\n```xml\n<resultMap id=\"orderMap\" type=\"order\">\n    <id column=\"oid\" property=\"orderId\"/>\n    <result column=\"oname\" property=\"orderName\"/>\n    <result column=\"cid\" property=\"customerId\"/>\n    <association property=\"customer\" javaType=\"customer\">\n        <id column=\"cid\" property=\"customerId\"/>\n        <result column=\"cname\" property=\"customerName\"/>\n    </association>\n</resultMap>\n\n<select id=\"queryById\" resultMap=\"orderMap\">\n    SELECT * FROM t_order tor JOIN t_customer tcr ON tor.cid = tcr.cid \n        WHERE tor.oid = #{id}\n</select>\n```\n\n因为数据表与实体类命名不统一，所以我们使用`resultMap`进行自定义映射。当存在层级映射（对象里面还有对象）的时候，我们使用`association`标签给内层对象映射，这个标签有两个属性：\n\n+ `property`表示内层对象的名字；\n+ `javaType`表示内层对象的类型；\n\n标签内部也是使用`id/result`标签进行属性映射。\n\n#### 对多关系查询\n我们想要查询所有存在订单的用户，并将这些用户的订单都查询出来。对应接口定义如下：\n\n```java\npublic interface CustomerMapper {\n    List<Customer> queryAll();\n}\n```\n\n与之对应的 mapper 文件：\n\n```xml\n<resultMap id=\"customerMap\" type=\"customer\">\n    <id column=\"cid\" property=\"customerId\"/>\n    <result column=\"cname\" property=\"customerName\"/>\n    <collection property=\"orders\" ofType=\"order\">\n        <id column=\"oid\" property=\"orderId\"/>\n        <result column=\"oname\" property=\"orderName\"/>\n        <result column=\"cid\" property=\"customerId\"/>\n    </collection>\n</resultMap>\n\n<select id=\"queryAll\" resultMap=\"customerMap\">\n    SELECT * FROM t_customer tcr JOIN t_order tor ON tcr.cid = tor.cid\n</select>\n```\n\n集合的层级映射我们使用`collection`标签，这个标签有两个属性：\n\n+ `property`表示内层集合的名称；\n+ `ofType`表示内层集合的泛型类型；\n\n标签内部仍然是使用`id/result`标签进行属性映射。\n\n#### 优化\n我们前面说过数据表字段名与实体类属性名是差不多的，只不过一个下划线命名，一个驼峰命名。为此我们可以在 MyBatis 核心配置文件里配置驼峰映射，但存在嵌套映射的情况下会出现以下情形：\n\n+ 如果`resultMap`标签内只有`id`与`result`标签（单层映射），那么`result`标签在满足映射条件的情况下是可以不写的，MyBatis 会帮我们自动映射。映射条件指的是：\n    1. 数据表字段名与实体类属性名一致；\n    2. 开启了驼峰映射，且两者确实满足驼峰映射；\n+ 如果`resultMap`标签内部配置了`association`或`collection`标签（多层映射），那么 MyBatis 就不会帮我们自动映射了，开启驼峰映射也没用。\n\n此时如果想让 MyBatis 帮我们映射，而不用我们自己写映射标签怎么办呢？\n\n可以在核心配置文件里配置如下：\n\n```xml\n<setting name=\"autoMappingBehavior\" value=\"FULL\"/>\n```\n\n这样配置之后在满足映射条件的情况下，MyBatis 会帮我们自动映射，而且不论是单层还是多层都会映射。假设我们现在所有的字段都满足驼峰映射，开启配置之后我们的`resultMap`就可以定义如下：\n\n```xml\n<resultMap id=\"customerMap\" type=\"customer\">\n    <id column=\"customer_id\" property=\"customerId\"/>\n    <collection property=\"orders\" ofType=\"order\">\n        <id column=\"order_id\" property=\"orderId\"/>\n    </collection>\n</resultMap>\n```\n\n因为字段名都满足驼峰映射，所以`result`标签都省略掉了。但是注意，配置主键的`id`标签不能省略。\n\n### 动态 sql\n动态 sql 就是 sql 语句是根据条件自动生成的，而不是提前写好的。例如查询的时候，查询条件个数或内容根据前端的选择动态指定。\n\n#### if 标签\n假设我们想要查询学生信息，可以根据姓名、班级或者两者一起联合查询。我们定义的接口方法如下：\n\n```java\nList<Student> queryStudent(\n    @Param(\"name\") String name, @Param(\"clazz\") String clazz);\n```\n\n方法需要两个参数分别表示学生姓名和班级，当参数不为`null`的时候才会作为查询条件。\n\n这样的需求还是比较常见的，以往我们需要自己拼接字符串，现在可以直接定义如下 sql 语句：\n\n```xml\n<select id=\"queryStudent\" resultType=\"student\">\n    SELECT * FROM students WHERE\n        <if test=\"name != null\">\n            stu_name = #{name}\n        </if>\n        <if test=\"clazz != null\">\n            AND stu_class = #{clazz}\n        </if>\n</select>\n```\n\n这边使用`if`标签进行条件判断，只有`test`指定表达式返回`true`内部语句才会添加到 sql 语句之中，`test`里面不需要使用`#{}`之类的写法就可以直接访问方法的参数。可以看到使用`if`标签可以很简单的控制查询条件。\n\n#### where 标签\n仔细观察不难发现，上面使用`if`标签控制查询条件是有隐患的。例如：\n\n+ 当传入的两个条件均为`null`时，我们的本意是查询全部学生，而生成的 sql 语句是`SELECT * FROM students WHERE`；\n+ 当传入的`name`为`null`，而`clazz`不为`null`时，生成的 sql 语句是`SELECT * FROM students WHERE AND stu_class = #{clazz}`；\n\n在这两种情况下，生成的 sql 语句是错误的。我们可以使用`where`标签：\n\n```xml\n<select id=\"queryStudent\" resultType=\"student\">\n    SELECT * FROM students\n        <where>\n            <if test=\"name != null\">\n                stu_name = #{name}\n            </if>\n            <if test=\"clazz != null\">\n                AND stu_class = #{clazz}\n            </if>\n        </where>\n</select>\n```\n\n总结下来，`where`标签会做两件事：\n\n1. 自动添加`WHERE`关键字；当`where`标签内部没有查询条件的时候就不在 sql 语句里面加`WHERE`，否则会自己加上`WHERE`关键字。\n2. 去除开头多余的`AND|OR`关键字；对应上面问题2，避免出现`SELECT * FROM students WHERE AND stu_class = #{clazz}`这样的情况。\n\n#### set 标签\n`set`标签的用法与上面的`where`类似，只不过`set`标签作用于更新语句中。接口方法：\n\n```java\nint updateStudent(Student student);\n```\n\n使用传递的学生对象更新数据库信息，主要根据 id 更新其它各字段。如果某个字段为`null`则不用更新，如果直接使用`if`标签控制如下：\n\n```xml\n<update id=\"updateStudent\">\n    UPDATE students SET\n        <if test=\"stuName != null\">\n            stu_name = #{stuName}\n        </if>\n        <if test=\"stuClass != null\">\n            , stu_class = #{stuClass}\n        </if>\n    WHERE stu_id = #{stuId}\n</update>\n```\n\n问题与上面的`where`类似，会出现错误的 sql。此时可以使用`set`标签：\n\n```xml\n<update id=\"updateStudent\">\n    UPDATE students\n        <set>\n            <if test=\"stuName != null\">\n                stu_name = #{stuName}\n            </if>\n            <if test=\"stuClass != null\">\n                , stu_class = #{stuClass}\n            </if>\n        </set>\n    WHERE stu_id = #{stuId}\n</update>\n```\n\n总结下来，`set`标签的做事情主要有两点：\n\n1. 自动添加`SET`关键字；这个功能比较鸡肋，因为在`UPDATE`语句里面必须有`SET`。\n2. 去除开头多余的`,`；仍然是对应第一个`if`为`null`，第二个不为`null`的情况。\n\n#### trim 标签\n`trim`可以在一段 sql 前后添加某些内容，也可以删除一段 sql 前后的某些内容。它的主要属性：\n\n+ `prefix\0`添加前缀属性；\n+ `suffix\0`添加后缀属性；\n+ `prefixOverrides\0`删除前缀属性；\n+ `suffixOverrides\0`删除后缀属性；\n\n##### 实现`where`\n我们可以使用`trim`实现`where`的功能，如下：\n\n```xml\n<select id=\"queryStudent\" resultType=\"student\">\n    SELECT * FROM students\n    <trim prefix=\"WHERE\" suffixOverrides=\"AND|OR\">\n        <if test=\"name != null\">\n            stu_name = #{name} AND\n        </if>\n        <if test=\"clazz != null\">\n            stu_class = #{clazz}\n        </if>\n    </trim>\n</select>\n```\n\n这边使用的`trim`作用解读如下：\n\n+ 如果`trim`标签内部存在 sql（至少有一个`if`判断通过） 则添加前缀`WHERE`；\n+ 如果`trim`标签内部存在 sql，则删除其后缀的`AND`或`OR`；\n\n##### 实现`set`\n我们可以使用`trim`实现`set`的功能，如下：\n\n```xml\n<update id=\"updateStudent\">\n    UPDATE students\n    <trim prefix=\"SET\" prefixOverrides=\",\">\n        <if test=\"stuName != null\">\n            stu_name = #{stuName}\n        </if>\n        <if test=\"stuClass != null\">\n            , stu_class = #{stuClass}\n        </if>\n    </trim>\n    WHERE stu_id = #{stuId}\n</update>\n```\n\n这边使用的`trim`作用解读如下：\n\n+ 如果`trim`标签内部存在 sql 则添加前缀`SET`；\n+ 如果`trim`标签内部存在 sql，则删除其前缀的`,`；\n\n#### choose 标签\n`choose`标签主要用在有多个条件依次判定选择一个执行的情形，例如：我们传递一个姓名与班级，若姓名不为`null`则使用姓名查询，姓名为`null`而班级不为`null`则使用班级查询，否则查询所有学生。\n\n我们可以写出下面的 mapper：\n\n```xml\n<select id=\"queryStudentCondition\" resultType=\"student\">\n    SELECT * FROM students WHERE\n    <choose>\n        <when test=\"name != null\">\n            stu_name = #{name}\n        </when>\n        <when test=\"clazz != null\">\n            stu_class = #{clazz}\n        </when>\n        <otherwise>\n            1=1\n        </otherwise>\n    </choose>\n</select>\n```\n\n可以看到我们使用了`choose`标签，内部包含若干个`when`标签以及一个`otherwise`标签。它会从上到下依次判别每一个`when`，`test`为`true`时就使用对应的语句，若没有满足条件的`test`就使用`otherwise`指定的语句。\n\n要注意，当我们使用`choose`标签的时候，内部的若干个 sql 语句我们最多选择一个执行，所以不存在有多余的`AND|OR`的情形。\n\n#### foreach 标签\n`foreach`标签主要用于循环生成字符串，它有以下几个重要属性：\n\n+ `collection\0`指定用于循环的集合；\n+ `open`为生成的字符串指定一个前缀；\n+ `separator\0`指定每一项的分隔符；\n+ `close`为生成的字符串指定一个后缀；\n+ `item\0`指定循环过程中每一项的名称；\n\n使用`foreach`的主要场景就是批量增、删、改、查的场景。\n\n##### 批量增\n批量增加数据的 sql 可以写成：\n\n```sql\nINSERT INTO table_name (fields) VALUES (v1), (v2)...\n```\n\n定义的批量增加数据的接口方法为：\n\n```java\nint addBatch(@Param(\"students\") List<Student> students);\n```\n\n与之对应的 mapper 写成：\n\n```xml\nINSERT INTO students (stu_name, stu_class) VALUES\n    <!-- 循环生成“(value)”，每一项使用逗号分隔 -->\n    <foreach collection=\"students\" separator=\",\" item=\"student\">\n        <!-- 循环变量被指定为 student，如果是对象可以使用“.”直接获取属性 -->\n        (#{student.stuName}, #{student.stuClass})\n    </foreach>\n```\n\n有一个小注意点，这边接口方法只定义了一个参数，但我们还是还有`@Param`注解指定参数名，那是因为如果不指定在`forearch`的`collection`属性中获取不到。\n\n##### 批量删\n根据数据 id 批量删除数据的 sql 可以写成：\n\n```sql\nDELETE FROM table_name WHERE id IN (id1, id2, ...)\n```\n\n定义的批量删除数据的接口方法为：\n\n```java\nint deleteBatch(@Param(\"ids\") List<Integer> ids);\n```\n\n与之对应的 mapper 写成：\n\n```xml\n<delete id=\"deleteBatch\">\n    DELETE FROM students WHERE stu_id IN\n    <foreach collection=\"ids\" open=\"(\" separator=\",\" close=\")\" item=\"id\">\n        #{id}\n    </foreach>\n</delete>\n```\n\n这边我们使用了`open`与`close`属性来给生成的串加上`()`。\n\n##### 批量改\n批量修改数据没有对应的 sql 语法，只能通过使用多条`UPDATE`语句实现。定义的接口方法为：\n\n```java\nint updateBatch(@Param(\"students\") List<Student> students);\n```\n\n与之对应的 mapper 写成：\n\n```xml\n<update id=\"updateBatch\">\n    <foreach collection=\"students\" item=\"student\">\n        UPDATE students SET\n            stu_name = #{student.stuName}, stu_class = #{student.stuClass}\n            WHERE stu_id = #{student.stuId};\n    </foreach>\n</update>\n```\n\n可以看到我们使用`foreach`将整个`UPDATE`语句包起来了，需要注意语句后面的`;`。\n\n##### 批量查\n根据数据 id 批量查询数据的 sql 可以写成：\n\n```sql\nSELECT * FROM table_name WHERE id IN (id1, id2...)\n```\n\n定义的批量查询数据的接口方法为：\n\n```java\nList<Student> queryBatch(@Param(\"ids\") List<Integer> ids);\n```\n\n与之对应的 mapper 写成：\n\n```xml\n<select id=\"queryBatch\" resultType=\"student\">\n    SELECT * FROM students WHERE stu_id IN\n    <foreach collection=\"ids\" open=\"(\" separator=\",\" close=\")\" item=\"id\">\n        #{id}\n    </foreach>\n</select>\n```\n\n#### sql 抽取\nsql 抽取是指对于一些常用的 sql 片段，我们可以将其单独定义出来，然后在使用的地方导入进去。这本质上就是字符串的拼接，定义 sql 片段使用`sql`标签，如下：\n\n```xml\n<!-- 使用 id 属性为此片段命名 -->\n<sql id=\"selectSql\">\n    SELECT * FROM students\n</sql>\n```\n\n我们可以在需要的地方使用`include`标签引入这段 sql，如下：\n\n```xml\n<select id=\"queryById\" resultType=\"student\">\n    <include refid=\"selectSql\"/> WHERE stu_id=#{xx}\n</select>\n```\n\n在`include`标签里面使用`refid`属性指定使用哪一个 sql 片段。不同的 mapper 文件之间是隔离的，可以起相同名字的片段。\n\n### 扩展功能\n#### 按包扫描 mapper\n之前我们每创建一个新的 mapper 都需要将其配置在核心配置文件中，比较麻烦。现在我们可以按照包一次性配置，就很方便。我们只需要在核心配置文件的`mappers`标签中声明`package`标签：\n\n```xml\n<mappers>\n    <package name=\"com.luyan.mappers\"/>\n</mappers>\n```\n\n但是这么做需要几个强制约定：\n\n1. 接口类与其对应的 mapper 文件必须同名。例如`UserMapper.java`对应的 mapper 文件必须命名为`UserMapper.xml`；\n2. mapper 文件在`resources`目录下的结构必须与接口类的目录结构一致。例如接口类都定义在`com/luyan/mappers`目录下，那么对应的 mapper 文件必须定义在`resources/com/luyan/mappers`目录下；\n\n有一个小注意点，我们在创建包的时候可以使用`com.luyan.mappers`形式简写多层结构，但是在创建目录的时候若还使用这样的写法只会认为有一个目录的名字叫`com.luyan.mappers`。因此我们在创建多层目录的时候要么一层一层创建，要么使用`com/luyan/mappers`形式创建。\n\n#### 分页插件\n日常开发中分页是很常用的一个功能，往常我们需要通过在 sql 语句中使用`LIMIT`关键字限制查询的结果来达到分页的目的。现在我们可以使用 MyBatis 的分页插件来做分页。\n\n##### 导包\n首先我们需要导入分页插件的包：\n\n```xml\n<dependency>\n   <groupId>com.github.pagehelper</groupId>\n   <artifactId>pagehelper</artifactId>\n   <version>6.1.0</version>\n</dependency>\n```\n\n##### 注册\n导完包之后，我们需要在核心配置文件里面注册这个插件：\n\n```xml\n<plugins>\n    <plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\n        <property name=\"helperDialect\" value=\"mysql\"/>\n    </plugin>\n</plugins>\n```\n\n注意`plugins`标签的定义位置，因为 MyBatis 核心配置文件中各个标签的位置是有先后顺序的。\n\n##### 使用\n我们只需要正常调用方法，并配置一些页码信息即可：\n\n```java\n// 先设置分页的信息，即查询第几页、一页有多少条数据\nPageHelper.startPage(3, 2);\n// 正常调用查询方法\nList<Student> students = mapper.queryAll();\n```\n\n查询方法的定义、mapper 的书写与以前没有任何区别。我们不需要在 sql 语句里面写`LIMIT`关键字，这些插件都会帮我们做，但是定义的 sql 语句不能使用`;`结尾。\n\n如果我想知道查询的一些信息，例如一共有多少条记录，可以将查询的结果包装成`PageInfo`：\n\n```java\n// 将查询结果包装成 PageInfo\nPageInfo<Student> pageInfo = new PageInfo<>(students);\n\n// 获取查询的数据\nList<Student> list = pageInfo.getList();\n\n// 获取记录总条数\nlong total = pageInfo.getTotal();\n\n// 获取总页数\nint pages = pageInfo.getPages();\n\n// 获取当前页码，从 1 开始\nint pageNum = pageInfo.getPageNum();\n\n// 获取页容量\nint pageSize = pageInfo.getPageSize();\n\n// 返回是否有下一页\nboolean hasNextPage = pageInfo.isHasNextPage();\n\n// 返回是否有上一页\nboolean hasPreviousPage = pageInfo.isHasPreviousPage();\n```\n\n对于使用有几个小注意点：\n\n1. 在`PageHelper.startPage(3, 2);`与`PageInfo<Student> pageInfo = new PageInfo<>(students);`之间只能有一条查询语句。不然不知道为哪一个查询分页。\n2. 使用插件之后返回的数据类型是`class com.github.pagehelper.Page`，它是`ArrayList`的子类，因此使用`List<>`接收完全没有问题。\n\n#### 逆向工程\n所谓逆向功能就是将 MyBatis 从半自动 ORM 框架迈进到全自动 ORM 框架，简而言之就是对于单表操作使用 IDEA 插件生成增删改查代码，节省我们精力。\n\n1. 安装 IDEA 插件`MyBatisX`：\n\n![](/upload/covers/e259c54808aa4394bfa238c148d941eb.png)\n\n2. 使用 IDEA 自带的数据库组件连接数据库：\n\n![](/upload/covers/6f0b82e40e724af888a460daa24e6d0e.png)\n\n3. 选中需要生成的表右键点击`MybatisX-Generator`：\n\n![](/upload/covers/0d97156ad5bb49768123388723c9ad82.png)\n\n点击`finish`之后，插件会帮我们根据表生成实体类、数据接口、mapper 文件。生成这些文件之后我们一般会选择需要的部分粘贴复制进行使用，所以逆向工程说白了就是让插件生成一些单表操作的代码。\n\n'),
       (13, 13, '### 简介\nSpring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现，是一个典型的教科书式的 MVC 构架，不像 Struts 等其它框架都是变种或者不是完全基于 MVC 系统的框架。\n\n### 流程\n#### 导言\n我们首先使用一个例子进行引入，我们下面将对比原始 Servlet 与 SpringMVC。\n\n+ 直接使用 Servlet 处理请求很麻烦，我们不仅需要写逻辑代码，还需要关注请求参数的获取、Response 封装等内容。\n+ 使用 SpringMVC 之后，我们只需要关注业务逻辑，其它事情 SpringMVC 帮我们做。\n\n同样是登录功能，在 SpringMVC 里面只需要写一个登录方法，需要的参数通过形参定义：\n\n```java\nString login(String username, String password) {\n    // 业务逻辑\n}\n```\n\n这类方法在 SpringMVC 里面被称为 Handler，Handler 所需的参数由 SpringMVC 负责从 Request 里面解析出来；如果有返回值我们也只需要返回数据本身，由 SpringMVC 负责将数据封装成 Response 再给到用户。因此我们只需要关注业务逻辑本身，而不需要关注其它一些繁琐的事情。\n\n#### 细节\n首先我们介绍一下 SpringMVC 里面的几个核心对象：\n\n+ `DispatcherServlet`是 SpringMVC 的核心 Servlet 对象，它统领全局；\n+ `HandlerMapping`负责维护请求路径与 Handler 之间的映射；\n+ `HandlerAdapter`负责解析 Request 与封装 Response，是框架与 Handler 之间的桥梁；\n\nSpringMVC 执行的流程图如下：\n\n![](/upload/covers/38f8dc9980a74cb1878e0305b02fa184.png)\n\n下面使用文字简要描述一下流程，我们对照图的流程编号进行讲解：\n\n+ 流程`1`：用户发起请求；\n+ 流程`2、3`：DispatcherServlet 向 HandlerMapping 查询请求路径对应的 Handler；\n+ 流程`4`：DispatcherServlet 将 Handler 告知 HandlerAdapter，由 HandlerAdapter 解析 Request 并调用 Handler；\n+ 流程`5、6`：Handler 处理请求并将结果返回 HandlerAdapter；\n+ 流程`7`：HandlerAdapter 封装处理结果并返回给 DispatcherServlet；\n+ 流程`8、9、10`：可选流程，需要渲染界面的时候走这一步；\n+ 流程`11`：返回最终的响应给用户；\n\n### 快速入门\n首先我们需要创建一个项目，注意这次创建的项目得是 web 项目。因此创建完项目之后，我们根据之前的方法右键项目点击`JBLJavaToWeb`。\n\n#### 导包\n我们主要需要导以下三个包：\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>5.3.32</version>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-webmvc</artifactId>\n  <version>5.3.32</version>\n</dependency>\n\n<!-- 6.0 之前的 Spring 配合这个包 -->\n<dependency>\n  <groupId>javax.servlet</groupId>\n  <artifactId>javax.servlet-api</artifactId>\n  <version>4.0.0</version>\n</dependency>\n\n<!-- 6.0 之后的 Spring 配合这个包 -->\n<dependency>\n  <groupId>jakarta.servlet</groupId>\n  <artifactId>jakarta.servlet-api</artifactId>\n  <version>6.0.0</version>\n</dependency>\n```\n\n#### 创建 Handler\nSpringMVC 里面处理请求的方法称为 Handler，我们创建如下类：\n\n```java\npackage com.luyan.controller;\n\n@Controller  // 需要将对象交给 Ioc 容器\npublic class HelloController {\n    \n    @RequestMapping(\"springmvc/hello\")  // 将 Handler 与请求路径绑定\n    @ResponseBody  // 这个注解表示将这个方法的返回值直接当做响应体，不做视图解析\n    public String hello() {\n        return \"Hello World!\";\n    }\n    \n}\n```\n\n#### 创建配置类\n我们知道 SpringMVC 要想工作光有 Handler 不够，还需要`HandlerMapping`与`HandlerAdapter`对象。因此我们需要将这两个对象配到配置类中：\n\n```java\n@Configuration\n@ComponentScan(\"com.luyan.controller\")  // 扫描 Handler\npublic class SpringMvcConfig {\n    @Bean\n    public RequestMappingHandlerMapping handlerMapping() {\n        return new RequestMappingHandlerMapping();\n    }\n\n    @Bean\n    public RequestMappingHandlerAdapter handlerAdapter() {\n        return new RequestMappingHandlerAdapter();\n    }\n}\n```\n\n#### 初始化 & 运行\n现在定义好了配置类，但容器怎么创建、谁来创建？\n\n答：这些事情交给 SpringMVC 即可，我们只需要定义类继承`AbstractAnnotationConfigDispatcherServletInitializer\0`并实现抽象方法：\n\n```java\npublic class SpringMvcInitializer \n        extends AbstractAnnotationConfigDispatcherServletInitializer {\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    // 加在配置类\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[]{ SpringMvcConfig.class };\n    }\n\n    // 表示使用 SpringMVC 处理所有以“/”开头的路径，即所有请求都需要处理\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n}\n```\n\n定义好之后创建 Tomcat 容器运行即可。\n\n### 路径设置\n我们在上一节已经使用`@RequestMapping`注解对请求路径与 Handler 进行绑定，这一节详细看看。\n\n#### 精准路径\n我们可以在方法上使用`@RequestMapping(路径)`注解将此方法与指定的路径绑定：\n\n```java\n@RequestMapping(\"/user/login\")\npublic String login() {\n    return null;\n}\n```\n\n除此之外还可以传递多个路径进去表示将这个方法与多个路径绑定：\n\n```java\n@RequestMapping({\"/user/login\", \"/user/login2\"})\npublic String login() {\n    return null;\n}\n```\n\n#### 模糊路径\n除了精确匹配，还可以使用模糊路径匹配。具体来说就是`*`可以匹配一层任意字符串，`**`可以匹配任意层任意字符串。例如，`/user/*`可以匹配`/user/、/user/a`但不能匹配`/user、/user/a/b`；而`/user/**`可以匹配`/user`及其所有以其开头的路径。注意，`/user`与`/user/`是不一样的。\n\n```java\n@RequestMapping(\"/user/*\")\npublic String login() {\n    return null;\n}\n\n@RequestMapping(\"/user/**\")\npublic String login2() {\n    return null;\n}\n```\n\n这个例子中两个路径是有重合的，产生冲突的时候会优先选择范围更小的方法匹配。\n\n#### 类注解\n`@RequestMapping`注解除了可以放在方法上，还可以放在类上。放在类上表示匹配的基路径，实际匹配的路径是`类上路径 + 方法上路径`：\n\n```java\n@Controller\n@RequestMapping(\"/user\")  // 这边指定的是下面方法的基路径\npublic class HelloController {\n\n    // 相当于 /user/login\n    @RequestMapping(\"login\")\n    public String login1() {\n        return \"login1\";\n    }\n\n    // RequestMapping 后面可以省略路径，此时相当于 /user/\n    @RequestMapping\n    public String login2() {\n        return \"login2\";\n    }\n\n    // 相当于 /user/*\n    @RequestMapping(\"*\")\n    @ResponseBody\n    public String login3() {\n        return \"login3\";\n    }\n\n    // 相当于 /user/**\n    @RequestMapping(\"**\")\n    @ResponseBody\n    public String login4() {\n        return \"login4\";\n    }\n}\n```\n\n#### 指定请求方式\n我们知道请求方式分很多种，例如`GET、POST、PUT、DELETE`等。默认情况下，使用`@RequestMapping`注解可以使用任何方法访问。如果我们想要限制访问方式，可以使用`method\0`参数指定，例如：\n\n```java\n// 只允许 GET 方式访问\n@RequestMapping(value = \"login\", method = RequestMethod.GET)\npublic String login1() {\n    return \"login1\";\n}\n\n// 只允许 GET 与 POST 方式访问\n@RequestMapping(value = \"login\", method = {RequestMethod.GET, RequestMethod.POST})\npublic String login2() {\n    return \"login2\";\n}\n```\n\n`method`参数既可以传递一种方式，也可以传递多种访问方式。如果使用错误的访问方式，会返回`405`报错。\n\n#### 其它注解\n除了可以使用`method`参数指定访问方式，每种访问方式还有专门的注解：\n\n```java\n// GET 方式访问 /login\n@GetMapping(value = \"login\")\npublic String login1() {\n    return \"login1\";\n}\n\n// POST 方式访问 /login\n@PostMapping(\"login\")\npublic String login2() {\n    return \"login2\";\n}\n```\n\n同一个请求路径只能绑定一个方法，绑定多个会报错。注意，同一个请求路径但访问方式不同我们认为这是两种路径。\n\n### 数据获取\n我们在做业务逻辑的时候往往需要获取一些数据才行，比如获取请求参数、Request 对象、Session 对象等。本节主要讨论这些对象的获取。\n\n#### param 参数获取\nparam 参数通过网址进行携带，一些比较简短的信息会通过这种方式传递，例如`/data?a=OK&b=1`；\n\n##### 直接接收\n我们在定义 Handler 方法的时候只需要在形参列表里面定义与传递参数同名的形参即可拿到数据，假设我们将通过网址传递名为`name`与`age`的参数，可以使用下面的方式接收：\n\n```java\n@GetMapping(\"/data\")\n@ResponseBody\n// 接收传过来的 name 与 age 参数\npublic String data(String name, int age) {\n    System.out.println(name + age);\n    return String.format(\"name: %s, age: %d\", name, age);\n}\n```\n\n对于这种接收方式有以下注意点：\n\n+ 我们定义的形参名必须与传递的参数同名，否则接收不到；\n+ 通过 param 方式传递的参数都会被当做字符串，`HandlerAdapter`会根据我们定义的形参类型进行强转，如果强转失败会报错；\n+ 如果定义的形参没有对应的参数与之匹配，那么会赋默认值`null`，此时如果我们定义的形参类型是非包装类型（如`int、double`等）会报错，因为无法将`null`强转成非包装类型；\n\n##### 注解指定\n除了直接接收参数，SpringMVC 还支持我们对参数做一些限制。例如我们可以设置某参数是否必须、参数与形参名不同但需要对应、参数不存在给形参一个指定默认值等。\n\n我们可以使用`@RequestParam\0`注解来实现上述功能：\n\n```java\n@GetMapping(\"/data\")\n@ResponseBody\npublic String data(@RequestParam String name, int age) {\n    System.out.println(name + age);\n    return String.format(\"name: %s, age: %d\", name, age);\n}\n```\n\n这边我们在形参`name`之前使用`@RequestParam`注解修饰，使用这个注解修饰的形参都是必须的参数，如果不传会报`400`错误。\n\n除此之外，我们还可以给`@RequestParam`注解的`value`或`name`属性赋值来指定当前形参与哪一个参数对应：\n\n```java\n@GetMapping(\"/data\")\n@ResponseBody\npublic String data(@RequestParam(\"username\") String name, int age) {\n    System.out.println(name + age);\n    return String.format(\"name: %s, age: %d\", name, age);\n}\n```\n\n这边我们将形参`name`与参数`username`对应，并且因为使用了`@RequestParam`注解修饰，所以参数`username`是必须的。\n\n再有我们还可以通过`@RequestParam`注解给某形参设置一个默认值：\n\n```java\n@GetMapping(\"/data\")\n@ResponseBody\npublic String data(String name, \n            @RequestParam(required = false, defaultValue = \"-1\") int age) {\n    System.out.println(name + age);\n    return String.format(\"name: %s, age: %d\", name, age);\n}\n```\n\n首先我们将`@RequestParam`注解的`required`属性设置为`false`表示这个参数不是必须的，其次我们再通过`defaultValue`属性指定这个参数的默认值。需要注意的是，不管默认值是什么类型，我们给`defaultValue`属性赋值的时候只能赋字符串。\n\n##### 多对一接收\n所谓多对一接收，就是类似于`/data?hbs=a&hbs=b`这种形式。这边参数`hbs`出现多次，我们想要将多个值放到一个列表之中：\n\n```java\n@GetMapping(\"/data\")\n@ResponseBody\npublic String data(@RequestParam List<String> hbs) {\n    System.out.println(hbs);\n    return String.format(\"%s\", hbs);\n}\n```\n\n我们定义形参的时候直接定义`List`类型就可以了，但是这种情况下必须使用`@RequestParam`注解修饰，否则会报错。\n\n##### 实体类接收\n很多时候我们需要将参数封装成一个实体类，例如我们想将数据封装成`User`对象可以：\n\n```java\n@GetMapping(\"/data\")\n@ResponseBody\npublic String data(User user) {\n    System.out.println(user);\n    return String.format(\"%s\", user);\n}\n```\n\n可以看到，直接在形参列表里面定义`User`类型参数即可。框架会帮我们将数据通过`setter`注入到实体类之中，但这有几个注意点：\n\n+ 实体类的属性名需要与参数名一致，否则无法知道将参数注入到哪一个属性之中；\n+ 不能使用`@RequestParam`注解修饰实体类参数，一旦修饰了就会认为形参`user`需要通过参数传递，但实际我们只会传递用户名、密码之类的信息；\n\n##### 动态路径\n实际开发中动态路径也是很常见的参数传递形式，例如`/user/username/password`，这边的`username`与`password`是动态改变的。这种形式的路径参数获取也很简单：\n\n```java\n@GetMapping(\"/data/{username}/{password}\")\n@ResponseBody\npublic String data(@PathVariable String username, \n                   @PathVariable(\"password\") String pwd) {\n    System.out.println(username + \" \" + pwd);\n    return String.format(\"%s %s\", username, pwd);\n}\n```\n\n我们首先在路径映射中使用`{路径名}`形式为这一段路径起一个名字，然后在形参列表里面定义一个同名的参数，并使用`@PathVariable`注解修饰这个参数表示该参数接收的是路径参数而不是 param 参数。当然我们也可以给`@PathVariable`注解的`value`属性传一个值表示当前形参与哪一个路径参数绑定。\n\n#### json 参数获取\njson 是前后端通信最常用的数据格式，本节详细探讨一下 json 数据的接收。主要有以下注意点：\n\n+ 因为 json 数据是封装到请求体里面的，所以请求方式必须是 POST；\n+ 我们必须定义与之对应的实体类来接收 json 数据；\n\n```java\n@PostMapping(\"/user\")  // 必须使用 POST 方式\n@ResponseBody\npublic String data(@RequestBody User user) {\n    System.out.println(user);\n    return user.toString();\n}\n```\n\n注意我们用来接收 json 数据的实体类对象形参必须使用`@RequestBody`注解修饰，否则会认为这个实体类是接收 param 参数的。\n\n除了以上注意点，我们还需做些工作。因为 Java 原生不支持 json 格式数据，所以我们需要做两件事：\n\n1. 引入解析 json 数据的依赖`jackson`；\n\n```xml\n<!-- 引入 jackson 依赖 -->\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n  <version>2.16.1</version>\n</dependency>\n```\n\n2. 为`HandlerAdapter`配置 json 解析器；\n\n```java\n@EnableWebMvc  // 在配置类上加 @EnableWebMvc 注解\n@Configuration\n@ComponentScan(\"com.luyan.controller\")\npublic class SpringMvcConfig {\n    @Bean\n    public RequestMappingHandlerMapping handlerMapping() {\n        return new RequestMappingHandlerMapping();\n    }\n\n    @Bean\n    public RequestMappingHandlerAdapter handlerAdapter() {\n        return new RequestMappingHandlerAdapter();\n    }\n}\n```\n\n做完这些之后，`HandlerAdapter`会将 json 字段自动映射到实体类的属性之中。\n\n实际上`@EnableWebMvc`注解非常强大，使用这个注解会自动在容器里面添加`HandlerAdapter`与`HandlerMapping`对象，因此我们的配置类直接变成：\n\n```java\n@EnableWebMvc\n@Configuration\n@ComponentScan(\"com.luyan.controller\")\npublic class SpringMvcConfig {\n    \n}\n```\n\n#### Cookie 获取\n很多时候我们需要获取 Cookie，可以通过以下方式设置与获取 Cookie：\n\n```java\n@Controller\n@ResponseBody  // 将 @ResponseBody 注解放到类上，相当于在下面所有方法上加这个注解\npublic class HelloController {\n    @GetMapping(\"save\")\n    // 方法直接声明 Response 对象，方便后面存储 Cookie\n    public String saveCookie(HttpServletResponse response) {\n        response.addCookie(new Cookie(\"username\", \"root\"));\n        response.addCookie(new Cookie(\"password\", \"123\"));\n        return \"save done!\";\n    }\n\n    @GetMapping(\"get\")\n    public String getCookie(@CookieValue String username, \n                            @CookieValue(\"password\") String pwd) {\n        System.out.println(username + pwd);\n        return String.format(\"%s, %s\", username, pwd);\n    }\n}\n```\n\n获取 Cookie 的时候需要在形参列表里声明与 Cookie name 同名的形参，然后使用`@CookieValue`注解表示该形参接收 Cookie 值。默认情况下形参名就是 Cookie 的 name，如果不一致需要指定`@CookieValue`注解的`value`属性。\n\n#### 请求头获取\n请求头的获取也非常简单，我们一样声明形参，然后使用`@RequestHeader`注解修饰该形参即可获取对应的 Header：\n\n```java\n@GetMapping(\"/header\")\npublic String getHeader(@RequestHeader(\"Host\") String host, \n                        @RequestHeader(\"User-Agent\") String ua) {\n    System.out.println(host + ua);\n    return String.format(\"%s %s\", host, ua);\n}\n```\n\n这个例子中我们获取`Host`与`User-Agent`两个请求头。\n\n#### 原生对象获取\n能获取的原生对象有很多，我们主要探讨重要的几个。\n\n##### 请求响应相关\n比较常用的原生对象有`Request、Response、Session`这三个，我们只需要在形参列表声明这几种类型的变量即可获取：\n\n```java\n@GetMapping(\"/data\")\npublic void data(HttpServletRequest request,\n                 HttpServletResponse response,\n                 HttpSession session) {\n    // 操作\n}\n```\n\n##### ServletContext\nWeb 开发中还有一个很重要的对象`ServletContext`，它是最大的上下文对象。获取项目的实际目录等操作都需要借助这个对象，我们有两种方式获取这个对象：\n\n1. 借助`Request`或`Session`对象获取：\n\n```java\n@GetMapping(\"/data\")\npublic void data(HttpServletRequest request, HttpSession session) {\n    // 借助 Request 对象获取\n    ServletContext servletContext = request.getServletContext();\n\n    // 借助 Session 对象获取\n    ServletContext servletContext = session.getServletContext();\n}\n```\n\n2. 直接使用 IoC 容器的自动装配功能：\n\n```java\n@Controller\n@ResponseBody\npublic class HelloController {\n    @Autowired\n    private ServletContext servletContext;\n}\n```\n\nSpringMVC 启动的时候会将`ServletContext`对象放到 IoC 容器之中，我们自动装配即可。\n\n##### 共享域\n共享域就是一个存储数据的公共区域，比较重要的共享域有以下几种：\n\n+ `Request`一次请求内有效，一般用于请求转发的场景；\n+ `Session`一次会话内有效，一般存储用户信息；\n+ `ServletContext`整个项目运行期间有效，一般用来存储一些全局配置；\n\n原始的使用方法都很简单，只需要调用对应域的`setAttribute\0`与`getAttribute\0`方法即可，这几个域的两个方法签名如下：\n\n```java\nvoid setAttribute(String var1, Object var2);\nObject getAttribute(String var1);\n```\n\n除了原始的操作方法，SpringMVC 对`Request`共享域的操作有四种新写法：\n\n```java\n// 模拟要存的 key 与 value\nString key = \"\";\nObject value = new Object();\n\n@GetMapping(\"/data1\")\n// 方式一：形参定义一个 Map 类型数据，并在里面添加数据\npublic void data1(Map map) {\n    map.put(key, value);\n}\n\n@GetMapping(\"/data2\")\n// 方式二：形参定义一个 Model 类型数据，并在里面添加数据\npublic void data2(Model model) {\n    model.addAttribute(key, value);\n}\n\n@GetMapping(\"/data3\")\n// 方式三：形参定义一个 ModelMap 类型数据，并在里面添加数据\npublic void data3(ModelMap modelMap) {\n    modelMap.addAttribute(key, value);\n}\n\n@GetMapping(\"/data4\")\n// 方式四：创建 ModelAndView 对象并返回\npublic ModelAndView data4() {\n    ModelAndView modelAndView = new ModelAndView();\n    modelAndView.addObject(key, value);\n    modelAndView.setViewName(\"视图名称\");\n    return modelAndView;\n}\n```\n\n这四种方式都可以往`Request`域中设置数据，值得注意的是第四种方式，这种方式一定要`modelAndView.setViewName(\"视图名称\")`即设置视图名称。也就是说使用这种方式无法返回数据，只能够返回视图。\n\n### 数据返回\n#### 返回视图页面\n在混合开发模式下，我们获取数据之后，往往要将数据渲染成 HTML 界面。常见的有 JSP 技术，本节我们就谈谈如何在 SpringMVC 里面通过 JSP 技术返回一个界面。\n\n##### 导包\n```xml\n<dependency>\n  <groupId>jakarta.servlet.jsp.jstl</groupId>\n  <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>\n  <version>3.0.0</version>\n</dependency>\n```\n\n##### 配置\n让配置类实现`WebMvcConfigurer`接口并重写`configureViewResolvers`方法，重写这个方法是为了指定视图界面的前后缀。\n\n```java\n@EnableWebMvc\n@Configuration\n@ComponentScan(\"com.luyan.controller\")\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        // 寻找视图文件的时候默认拼接上这边设定的前后缀\n        registry.jsp(\"WEB-INF/pages/\", \".jsp\");\n    }\n}\n```\n\n例如我们想要渲染`index`界面，经过拼接 SpringMVC 会去寻找`WEB-INF/pages/index.jsp`界面。\n\n##### 创建 JSP 界面\n我们在`webapp/WEB-INF/pages`目录下创建`index.jsp`文件：\n\n```xml\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    ${name} 你好！\n</body>\n</html>\n```\n\n界面很简单，就是输出一句话。这边使用`${name}`获取`Request`域中键为`name`的值进行展示。\n\n有一个小细节，我们是在`webapp/WEB-INF`下面创建的 jsp 文件而不是直接在`webapp`目录下。这么做是因为直接在`webapp`目录下创建的文件能够直接被外部访问，而`webapp/WEB-INF`目录下的文件不能被外部直接访问。显然 jsp 文件不应该直接被外部访问，因此我们如此创建。\n\n##### Handler\n接下来我们定义 Handler：\n\n```java\n@GetMapping(\"/index\")\npublic String index(HttpServletRequest request) {\n    // 因为 jsp 需要，这边往 Request 域放内容\n    request.setAttribute(\"name\", \"Tom\");  \n    return \"index\";  // 返回视图文件名\n}\n```\n\n注意这边我们不能使用`@ResponseBody\0`修饰方法，因为一旦使用这个注解就意味着将返回值直接作为响应体内容。实际上，我们这边的返回值表示的是视图文件的名字。\n\n#### 转发 & 重定向\n##### 转发\n转发只能转给项目内的资源，不能转给外站资源，SpringMVC 使用下面的方式实现转发：\n\n```java\n@GetMapping(\"forward\")\npublic String forward(Map map) {\n    map.put(\"info\", \"Content\");\n    // 返回一个以 “forward:” 开头的路径\n    return \"forward:/index\";\n}\n```\n\n关于转发有几个注意点：\n\n1. Handler 需要返回一个字符串，且该字符串需要以`forward:`开头；\n2. Handler 方法不能使用`@ResponseBody`修饰，否则会将返回值当做响应体；\n3. 转发前后的`Request`对象是同一个，因此可以通过`Request`域进行信息传递；\n\n##### 重定向\n重定向与转发不同，本质上重定向是两次请求，而转发只有一次请求。因此重定向不会共享`Request`对象，SpringMVC 实现重定向也很简单：\n\n```java\n@GetMapping(\"redirect\")\npublic String redirect() {\n    // 返回以“redirect:”开头的路径字符串\n    return \"redirect:/index\";\n}\n```\n\n关于重定向有以下注意点：\n\n1. Handler 需要返回一个字符串，且该字符串需要以`redirect:`开头；\n2. Handler 方法不能使用`@ResponseBody`修饰，否则会将返回值当做响应体；\n3. 可以重定向到外站资源，例如我想重定向到百度可以返回`\"redirect:https://www.baidu.com\"`；\n\n##### 细节\n对于原始使用`Request`与`Response`对象实现的转发重定向，我们假设项目的根目录是`/demo`且我们定义了`/demo/index`路径，有以下注意事项：\n\n+ 因为转发只能转给内部资源，因此转发的路径不能携带项目的根目录。例如我们可以使用`/index`直接访问资源，不能使用`/demo/index`；\n+ 重定向即可以转到站内资源，也可以转到站外资源。\n    - 如果转到站内资源我们可以省略域名、端口号之类的信息，但路径需要写全。例如我们可以写`/demo/index`而不能写`/index`；\n    - 如果转到外站资源域名、端口号（80 除外）之类的就不能省略。例如`https://www.baidu.com`就是合法的路径；\n\n在 SpringMVC 中，针对重定向到内部资源做了优化，我们可以省略项目根路径。也就是说**在 SpringMVC 里面重定向的路径写法与转发的路径写法一致**。\n\n#### 返回 JSON\n对于前后端分离的项目我们的 Handler 一般都会返回 json 数据，SpringMVC 里面返回 json 数据也很简单，下面一步步分解看看。\n\n##### 环境准备\n与获取 json 数据一样，我们想返回 json 数据也需要对应的包与支持，简单说就是两个步骤：\n\n1. 导入 jackson 包；\n2. 配置类上加`@EnableWebMvc`注解；\n\n##### 使用\n我们想要返回 json 格式的数据，首先需要与之对应的实体类。然后在 Handler 中返回这个实体类对象即可，`HandlerAdapter`会帮我们将对象转成 json 并返回：\n\n```java\n@GetMapping(\"/user\")\n@ResponseBody\npublic User user() {\n    User user = new User(\"Tom\", 18);\n    return user;  // 直接创建对象并返回即可\n}\n```\n\n有一点需要注意，我们需要在 Handler 上添加`@ResponseBody`注解。使用这个注解仍然是表示将返回的内容直接作为响应体，而不会去找视图解析器。\n\n##### 优化\n在前后端分离的项目中，我们大多数的 Handler 都是直接返回一个 json。因此每一个 Handler 上面写一个`@ResponseBody`注解就显得很麻烦了。我们可以直接把`@ResponseBody`注解加到类上，这样就相当于给所有方法都加了这个注解：\n\n```java\n@Controller\n@ResponseBody\npublic class DemoController {\n    @GetMapping(\"/user\")\n    public User user() {\n        User user = new User(\"Tom\", 18);\n        return user;\n    }\n}\n```\n\n为此 SpringMVC 还给我提供了简化写法，直接加一个`@RestController`注解即可：\n\n```java\n@RestController\npublic class DemoController {\n    @GetMapping(\"/user\")\n    public User user() {\n        User user = new User(\"Tom\", 18);\n        return user;\n    }\n}\n```\n\n相当于`@Controller + @ResponseBody = @RestController`。\n\n#### 静态资源\n访问静态资源也是开发过程中很常用的功能，以往我们直接在`webapp`目录下存放静态资源即可被外部访问。例如我们项目中存在`webapp/images/demo.jpg`文件，以往我们可以直接通过路径`/images/demo.jpg`访问这个文件。但是在 SpringMVC 中路径`/images/demo.jpg`会被交给`HandlerMapping`寻找对应的 Handler，显然是找不到的，因此在 SpringMVC 之中直接访问静态资源会`404`。\n\n如果想访问静态资源，我们需要对配置文件做如下配置：\n\n```java\n@EnableWebMvc\n@Configuration\n@ComponentScan(\"com.luyan.controller\")\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n}\n```\n\n配置类实现`WebMvcConfigurer`接口的`configureDefaultServletHandling`方法，并在里面开启静态资源映射。\n\n### RESTFUL\nREST 即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000 年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。\n\n#### 设计规范\n设计规范总结来说就是两点：\n\n1. 每一个 URI 都应该是一个名词，说白了就是请求路径应该是名词形式而非动词；\n2. 我们应该使用正确的请求方式来表示对服务器资源的不同操作；\n\n对于一些常见的操作和对应的请求方式见下表：\n\n| **操作** | **请求方式** |\n| :---: | :---: |\n| 查询数据 | GET |\n| 保存数据 | POST |\n| 删除数据 | DELETE |\n| 更新数据 | PUT |\n\n\n我们不妨以用户操作对比一下传统路径与 RESTFUL 路径：\n\n| **操作** | **传统风格（动词命名）** | **RESTFUL 风格（名词命名）** |\n| :---: | :---: | :---: |\n| 保存用户 | `/user/save` | `/user` - POST |\n| 根据 id 删除用户 | `/user/delete?id=1` | `/user/1` - DELETE |\n| 更新用户 | `/user/update` | `/user` - PUT |\n| 根据 id 查询用户 | `/user/query?id=1` | `/user/1` - GET |\n\n\n重点是使用名词作为请求路径，对于不同操作但路径相同的情况通过请求方式区分。\n\n#### 设计样例\n本节我们使用一个例子阐述一下 RESTFUL 路径设计思路，在此之前我们看一下几个传参原则：\n\n1. 对于 POST 与 PUT 请求方式，它支持路径参数、param 参数、请求体参数这三种，但我们推荐单纯在请求体里使用 json 传递参数；\n2. 对于 GET 与 DELETE 请求方式，它仅支持路径参数与 param 参数两种，我们推荐按需使用：\n    1. 当要传递的是唯一标识时使用路径参数；\n    2. 当要传递的是模糊条件使用 param 参数；\n\n假设我们要基于用户表做一些操作，看看下面的 api 设计：\n\n| **操作** | **请求方式与接口** | **请求参数** |\n| --- | --- | --- |\n| 分页查询 | `GET`/user | page=1&size=10 |\n| 用户添加 | `POST`/user | 请求体 json |\n| 根据 id 查询用户 | `GET`/user/1 | 路径参数 |\n| 用户更新 | `PUT`/user | 请求体 json |\n| 根据 id 删除用户 | `DELETE`/user/1 | 路径参数 |\n| 模糊匹配 | `GET`/user/search | keyword=关键字&... |\n\n\n+ 所有的 POST 与 PUT 操作都是使用请求体 json 传递参数；\n+ 当我们需要传递的参数是 id 等唯一标识时使用的是路径参数，例如`/user/1`；\n+ 当我们需要传递的参数是一种模糊条件时使用 param 参数，例如`/user?page=1&size=10`；\n+ 同一请求方式下，路径命名重复可以使用动词命名（走投无路），例如`/user/search`；\n+ 若查询操作中需要传递的参数比较敏感也可以使用 POST 请求方式；\n\n### 全局异常处理\n以往我们会使用`try...catch`捕获异常，现在 SpringMVC 提供了一套全局异常处理机制给我们。下面我们看看具体的操作步骤。\n\n首先，业务逻辑部分该咋写咋写，不需要去捕获异常：\n\n```java\n@RestController\npublic class HelloController {\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        int i = 1 / 0;  // 不需要去捕获异常\n        return \"ok\";\n    }\n\n    @GetMapping(\"/null\")\n    public String hello2() {\n        String s = null;\n        char c = s.charAt(1);  // 不需要去捕获异常\n        return s;\n    }\n}\n```\n\n接着，定义一个全局异常捕获类：\n\n```java\n@RestControllerAdvice\npublic class GlobalErrorHandler {\n\n    // 使用 @ExceptionHandler 注解指定该方法处理什么异常\n    @ExceptionHandler(NullPointerException.class)\n    public String nullPointerHandler(NullPointerException e) {\n        System.out.println(e.getMessage());\n        return e.getMessage();\n    }\n\n    @ExceptionHandler(Exception.class)\n    public String exceptionHandler(Exception e) {\n        return e.getMessage();\n    }\n}\n```\n\n关于这个异常捕获类有几点说明：\n\n1. 这个类需要用`@ControllerAdvice\0`或`@RestControllerAdvice\0`注解修饰，这两个注解的区别就是`@RestControllerAdvice`注解暗含一个`@ResponseBody`；\n2. 被这两个注解修饰之后里面的方法都会变成 Handler，也就是说可以返回数据、视图等。因为我们这边就是想返回一个字符串回去，因此使用`@RestControllerAdvice`修饰类；\n3. 每一个方法需要使用`@ExceptionHandler`注解指定该方法能够处理的异常，有多个异常需要同一个方法处理时可以使用形如`{Exception1.class, Exception2.class}`这种形式；\n4. 我们可以在方法形参里面定义该异常对象，便于我们处理该异常；\n5. 发生异常时会优先寻找对应的 Handler，找不到逐层寻找其父异常对应的 Handler；\n\n### 拦截器\n拦截器的功能与之前的过滤器有些类似，但不完全相同。Web 开发中的过滤器是请求到达一个 Servlet 之前被拦住做某些操作，例如编码设置、登录校验、权限鉴定等。这显然在 SpringMVC 中是不实用的，因为 SpringMVC 中只有一个核心 Servlet，所有请求都经过这个 Servlet 的转发。\n\n这种情况下，我们想要的是在请求到达 Handler 之前进行拦截。SpringMVC 也给我们提供相关技术，称为拦截器，这边拦截器可以在三个地方做拦截：\n\n1. Handler 处理前；\n2. Handler 处理后；\n3. 整个请求结束返回给用户前；\n\n下面我们看下使用拦截器的整个流程。\n\n#### 定义拦截器\n定义拦截器的具体代码如下：\n\n```java\n// 自定义拦截器需实现 HandlerInterceptor 接口\npublic class MyInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request,\n                             HttpServletResponse response,\n                             Object handler) throws Exception {\n        System.out.println(\"Handler 前处理\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request,\n                           HttpServletResponse response,\n                           Object handler,\n                           ModelAndView modelAndView) throws Exception {\n        System.out.println(\"Handler 后处理\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request,\n                                HttpServletResponse response,\n                                Object handler, Exception ex) throws Exception {\n        System.out.println(\"请求结束处理\");\n    }\n}\n```\n\n接口中有三个方法，分别是：\n\n+ `preHandle`表示 Handler 执行前，只有该方法返回`true`才能继续往后执行（包括执行 Handler 与触发后续拦截器），我们一般在这做登录校验等工作；\n+ `postHandle`表示 Handler 执行后，我们一般在这个阶段做敏感词汇过滤；\n+ `afterCompletion`表示整个请求结束返回给用户之前；\n\n#### 注册拦截器\n拦截器定义好之后，我们还需要在配置文件中注册这个拦截器：\n\n```java\n@EnableWebMvc\n@Configuration\n@ComponentScan(\"com.luyan\")\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 为所有请求注册拦截器（静态资源不拦截）\n        registry.addInterceptor(new MyInterceptor());\n    }\n}\n```\n\n我们的 IoC 配置类需要实现`WebMvcConfigurer`接口，并实现`addInterceptors`方法，最后在方法中注册拦截器。\n\n目前配置完毕之后，所有的请求都会被拦截。中间想要做什么操作，也可以通过提供的`Request`与`Response`对象进行操作，例如登录校验失败跳转到登录界面。\n\n#### 更多拦截规则\n上面我们展示了如何拦截所有的请求，在某些时候我们想要拦截的只是部分请求怎么办？我们可以使用如下写法实现拦截部分：\n\n```java\n// 拦截全部\nregistry.addInterceptor(new MyInterceptor());\n\n// 链式调用 addPathPatterns 方法之后只拦截 /hello\nregistry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/hello\");\n\n// 链式调用 addInterceptor 方法之后，在前面拦截规则基础上取消拦截 /hello\nregistry.addInterceptor(new MyInterceptor()).excludePathPatterns(\"/hello\");\n```\n\n我们可以将`addPathPatterns`与`excludePathPatterns`配合使用实现灵活拦截。\n\n除此之外，拦截规格也支持模糊匹配，`*`表示拦截一层任意路径，`**`表示拦截任意层任意路径。\n\n#### 拦截时机\n我们可以同时注册多个拦截器，它们的运行时机是如何的？例如我们注册如下拦截器：\n\n```java\nregistry.addInterceptor(new MyInterceptor1());\nregistry.addInterceptor(new MyInterceptor2());\n```\n\n多个拦截器之间是包裹关系，最核心部分就是被拦截的 Handler，本例中先后如下：\n\n```plain\nMyInterceptor1.preHandle\nMyInterceptor2.preHandle\n\n核心 Handler 操作\n\nMyInterceptor2.postHandle\nMyInterceptor1.postHandle\n\nMyInterceptor2.afterCompletion\nMyInterceptor1.afterCompletion\n```\n\n简单说多个拦截器方法的执行顺序为：核心操作前按注册顺序执行，核心操作后按注册顺序逆序执行。\n\n### 参数校验\n参数校验就是针对前端传过来的数据，判断其是否满足一定约束。例如年龄不能是负数，姓名不能是空串等。以前这些内容都需要我们自己做，现在我们可以使用参数校验注解快速实现。\n\n#### 导包\n这些注解在 Java 只是一种标准，我们需要导入其实现者的包：\n\n```xml\n<dependency>\n  <groupId>org.hibernate.validator</groupId>\n  <artifactId>hibernate-validator</artifactId>\n  <version>6.0.0.Final</version>\n</dependency>\n\n<!-- SpringBoot 中添加下面的依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n\n#### 注解\n我们开发过程中比较常见的注解有：\n\n| **注解** | **验证的数据类型** | **说明** |\n| :---: | :---: | :---: |\n| `@AssertFalse` | Boolean,boolean | 验证注解的元素值是 false |\n| `@AssertTrue` | Boolean,boolean | 验证注解的元素值是 true |\n| `@NotNull` | 任意类型 | 验证注解的元素值不是 null |\n| `@Null` | 任意类型 | 验证注解的元素值是 null |\n| `@Min(value)` | BigDecimal，BigInteger, byte,short, int, long，等任何Number或CharSequence（存储的是数字）子类型 | 验证注解的元素值 ≥value |\n| `@Max(value)` | 和@Min要求一样 | 验证注解的元素值 ≤value |\n| `@DecimalMin(value)` | 和@Min要求一样 | 验证注解的元素值 ≥value |\n| `@DecimalMax(value)` | 和@Min要求一样 | 验证注解的元素值 ≤value |\n| `@Digits(integer, fraction)` | 和@Min要求一样 | 验证注解的元素值的整数位数和小数位数上限 |\n| `@Size(min, max)` | 字符串、Collection、Map、数组等 | 验证注解的元素大小在 [min, max] 范围内，如字符串长度、集合大小 |\n| `@Past` | java.util.Date,java.util.Calendar;Joda Time类库的日期类型 | 验证注解的元素值比当前时间早 |\n| `@Future` | 与@Past要求一样 | 验证注解的元素值比当前时间晚 |\n| `@NotBlank` | CharSequence子类型 | 验证去除首尾空白字符之后串长度 >0 |\n| `@Length(min, max)` | CharSequence子类型 | 验证注解的串长度在 [min, max] 范围内 |\n| `@NotEmpty` | CharSequence子类型、Collection、Map、数组 | 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） |\n| `@Range(min, max)` | BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型 | 验证注解的元素值在 [min, max] 范围内 |\n| `@Email` | CharSequence子类型（如String） | 验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式 |\n| `@Pattern(regexp)` | String，任何CharSequence的子类型 | 验证注解的元素值与指定的正则表达式匹配 |\n| `@Valid` | 任何非原子类型 | 指定递归验证关联的对象，如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证 |\n\n\n开发过程中比较常用的注解单独拿出来列表：\n\n| **注解** | **验证的数据类型** | **说明** |\n| :---: | :---: | :---: |\n| `@NotNull` | 任意类型 | 验证注解的元素值不是 null |\n| `@Min(value)` | BigDecimal，BigInteger, byte,short, int, long，等任何Number或CharSequence（存储的是数字）子类型 |  验证注解的元素值 ≥value |\n| `@Max(value)` | 和@Min要求一样 | 验证注解的元素值 ≤value |\n| `@NotBlank` | CharSequence子类型 | 验证去除首尾空白字符之后串长度 >0 |\n| `@Length(min, max)` | CharSequence子类型 | 验证注解的串长度在 [min, max] 范围内 |\n| `@Email` | CharSequence子类型（如String） | 验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式 |\n\n\n#### 使用\n参数校验使用起来也非常简单：\n\n1. 我们需要在实体类对应的属性上加对应的校验注解：\n\n```java\n@Data\npublic class User {\n    @NotBlank(message = \"姓名不能为空\")\n    private String name;\n    @Min(1)\n    private int age;\n}\n```\n\n我们这边只对姓名校验非空，年龄最小 1 岁。\n\n2. 在 Handler 对应参数前面加上`@Validated\0`注解：\n\n```java\n@RestController\npublic class HelloController {\n    @PostMapping(\"/user\")\n    public Object user(@RequestBody @Validated User user) {\n        System.out.println(\"user = \" + user);\n        return user;\n    }\n}\n```\n\n这边我们使用`@Validated`注解修饰形参`user`，框架会帮我们校验各字段是否合法。如果校验不通过默认情况下会报错。\n\n#### 异常处理\n##### 手动处理\n如果我们不希望校验失败就报错，而是希望校验失败我们返回一个 json 数据，里面包含错误信息可以：\n\n```java\n@RestController\npublic class HelloController {\n\n    @PostMapping(\"/user\")\n    public Object user(@RequestBody @Validated User user, BindingResult result) {\n        if (result.hasErrors()) {\n            System.out.println(result.getAllErrors());\n            Map<String, Object> map = new HashMap<>();\n            map.put(\"code\", 400);\n            map.put(\"msg\", \"参数校验失败\");\n            return map;\n        }\n        System.out.println(\"user = \" + user);\n        return user;\n    }\n}\n```\n\n我们**挨着**校验对象`user`定义了一个`BindingResult`类型的形参`result`，校验情况可以通过`result`获取。但注意，`BindingResult`对象必须与被校验对象定义在一起，中间不能声明其它形参。\n\n##### 全局异常处理\n实际使用中，我们会让其抛异常然后通过全局异常处理来返回指定类型的数据。\n\n```java\n@RestControllerAdvice\npublic class GlobalErrorHandler {\n    // 全局捕获参数校验失败异常，并返回校验失败信息\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public R<Object> argumentNotValidExceptionHandler(\n      MethodArgumentNotValidException e) {\n        List<ObjectError> allErrors = e.getBindingResult().getAllErrors();\n        String result = allErrors.stream().map(\n                DefaultMessageSourceResolvable::getDefaultMessage\n        ).collect(Collectors.joining(\";\"));\n        return R.error(result);\n    }\n}\n```\n\n'),
       (14, 14, '### 概念\n什么是 SSM 整合？下面将从微观和宏观两个角度进行理解。\n\n从微观上讲就是将学习的 Spring、SpringMVC、Mybatis 框架应用到项目中：\n\n+ SpringMVC 框架负责控制层；\n+ Spring 框架负责整体和业务层的声明式事务管理；\n+ MyBatis 框架负责数据库访问层；\n\n从宏观上讲就是 Spring 接管一切（将框架核心组件交给 Spring 容器进行管理），代码更加简洁：\n\n+ SpringMVC 管理表述层、SpringMVC 相关组件；\n+ Spring 管理业务层、持久层、以及数据库相关（DataSource，MyBatis）的组件；\n+ 使用 loC 的方式管理一切所需组件；\n\n### 整合 4 问\n#### SSM 整合需要几个容器\n答：**两个**。本质上说，整合就是将三层架构和框架核心 API 组件交给 SpringloC 容器管理。一个容器可能就够了，但是我们常见的操作是创建两个 loC 容器（web 容器和 root 容器），组件分类管理有以下好处和目的：\n\n1. 分离关注点：通过初始化两个容器，可以将各个层次的关注点进行分离。这种分离使得各个层次的组件能够更好地聚焦于各自的责任和功能；\n2. 解耦合：各个层次组件分离装配不同的 loC 容器，这样可以进行解耦。这种解耦合使得各个模块可以独立操作和测试，提高了代码的可维护性和可测试性；\n3. 灵活配置：通过使用两个容器，可以为每个容器提供各自的配置，以满足不同层次和组件的特定需求。每个配文件也更加清晰和灵活；\n\n总的来说，初始化两个容器在 SSM 整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构。\n\n#### 各容器装哪些组件\n![](/upload/covers/f2aa794d71954ba988836f66476b52ae.png)\n\n两个容器具体装哪些组件可以总结如下表：\n\n| **容器** | **盛放组件** |\n| :---: | :---: |\n| web 容器 | controller 层相关组件（SpringMVC 相关组件） |\n| root 容器 | 业务和持久层相关组件（aop、tx、mybatis 等组件） |\n\n\n**注意**：web 容器是 root 容器的子容器。之所以这样设计是因为我们在 controller 层经常会需要拿到 service 层的对象，因此将它们设计为父子关系，这样子容器就可以获取到父容器里的组件。而父容器是拿不到子容器里面的组件的，不过这也没有关系，因为后面的层一般也不需要 controller 层的对象。\n\n#### Spring 配置类需要多少个\n答：一般推荐写 3 个配置类，即每一层都写一个配置类。\n\n![](/upload/covers/75534fa97c6642b3a8883c8584b7c979.png)\n\n配置类与容器的关系总结下表：\n\n| **配置类** | **对应内容** | **对应容器** |\n| :---: | :---: | :---: |\n| WebJavaConfig | controller 层：springmvc 相关 | web 容器 |\n| ServiceJavaConfig | service 层：业务逻辑、aop、tx 相关 | root 容器 |\n| MapperJavaConfig | mapper 层：datasource、mybatis 相关 | root 容器 |\n\n\n#### 如何指定各配置类\n我们只需要在 SpringMVC 初始化类对应位置进行设置即可：\n\n```java\n// SpringMVC 初始化类\npublic class SpringMvcInitializer \n        extends AbstractAnnotationConfigDispatcherServletInitializer {\n    // 在这指定 root 容器配置类\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    // 在这指定 web 容器配置类\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[]{ SpringMvcConfig.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n}\n```\n\n我们在上述对应位置指定配置类之后，SpringMVC 会帮我们创建容器并设置父子关系。\n\n### 整合 SpringMVC\n整合 SpringMVC 的项目需要是 web 项目，因此模块创建好之后右键点击`JBLJavaToWeb`。\n\n#### 导包\n##### 必须包\n```xml\n<!-- Spring -->\n<dependency> \n  <groupId>org.springframework</groupId>  \n  <artifactId>spring-context</artifactId>  \n  <version>5.3.33</version> \n</dependency>  \n\n<!-- SpringMVC -->\n<dependency> \n  <groupId>org.springframework</groupId>  \n  <artifactId>spring-webmvc</artifactId>  \n  <version>5.3.33</version> \n</dependency>  \n\n<!-- SpringMVC 核心 Servlet -->\n<dependency> \n  <groupId>javax.servlet</groupId>  \n  <artifactId>javax.servlet-api</artifactId>  \n  <version>4.0.1</version> \n</dependency>\n```\n\n##### 选配包\n```xml\n<!-- JSON 依赖 -->\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>  \n  <artifactId>jackson-databind</artifactId>  \n  <version>2.17.0</version> \n</dependency>\n\n<!-- 参数校验 -->\n<dependency>\n  <groupId>org.hibernate.validator</groupId>\n  <artifactId>hibernate-validator</artifactId>\n  <version>8.0.1.Final</version>\n</dependency>\n\n<!-- jsp -->\n<dependency>\n  <groupId>jakarta.servlet.jsp.jstl</groupId>\n  <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>\n  <version>3.0.0</version>\n</dependency>\n```\n\n#### 配置类\n接下来我们创建 SpringMVC 对应的配置类：\n\n```java\n@EnableWebMvc  // 配置 json、HandlerMapping、HandlerAdapter\n@Configuration\n@ComponentScan(\"com.luyan.controller\")\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        // 添加视图前后缀\n        registry.jsp(\"/WEB-INFO/views/\", \".jsp\");\n    }\n\n    @Override\n    public void configureDefaultServletHandling(\n            DefaultServletHandlerConfigurer configurer) {\n        // 配置静态资源\n        configurer.enable();\n    }\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 配置拦截器\n    }\n}\n```\n\n#### 测试\n##### 初始化类\n创建类继承`AbstractAnnotationConfigDispatcherServletInitializer`：\n\n```java\npublic class ProjectInit extends AbstractAnnotationConfigDispatcherServletInitializer {\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[0];\n    }\n\n    @Override\n    // SpringMVC 配置类放在这\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[]{SpringMvcConfig.class};\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n}\n```\n\n##### Handler\n创建一个 Handler 测试功能：\n\n```java\n@RestController\npublic class UserController {\n    @GetMapping(\"/hello\")\n    public String hello(String username) {\n        return \"Hello, \" + username;\n    }\n}\n```\n\n### 整合 aop 与 tx\n#### 导包\n##### 必选包\n```xml\n<!-- aop -->\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-aspects</artifactId>\n  <version>5.3.33</version>\n</dependency>\n\n<!-- 事务 -->\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-tx</artifactId>\n  <version>5.3.33</version>\n</dependency>\n\n<!-- 事务管理器 -->\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.3.33</version>\n</dependency>\n```\n\n##### 选配包\n```xml\n<!-- @Resource 注解需要 -->\n<dependency>\n  <groupId>javax.annotation</groupId>\n  <artifactId>javax.annotation-api</artifactId>\n  <version>1.3.2</version>\n</dependency>\n\n<!-- 测试整合包 -->\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-test</artifactId>\n  <version>5.3.33</version>\n</dependency>\n\n<!-- junit -->\n<dependency>\n  <groupId>org.junit.jupiter</groupId>\n  <artifactId>junit-jupiter-api</artifactId>\n  <version>5.10.2</version>\n  <scope>test</scope>\n</dependency>\n```\n\n#### 配置类\n```java\n@Configuration\n@EnableAspectJAutoProxy  // 允许自动代理\n@EnableTransactionManagement  // 允许事务管理\npublic class ServiceJavaConfig {\n    @Bean\n    public TransactionManager transactionManager(DataSource dataSource) {\n        DataSourceTransactionManager manager = \n            new DataSourceTransactionManager();\n        manager.setDataSource(dataSource);\n        return manager;\n    }\n}\n```\n\nSpring 事务需要我们配置一个事务管理器到容器中，事务管理器需要的连接池通过参数注入获得。因为连接池我们会在后面配置，因此目前会注入失败。\n\n### 整合 MyBatis\n#### 导包\n```xml\n<!-- 数据库 -->\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>8.0.33</version>\n</dependency>\n\n<!-- druid 连接池 -->\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.2.22</version>\n</dependency>\n\n<!-- MyBatis -->\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.5.15</version>\n</dependency>\n\n<!-- 整合包 -->\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>2.1.2</version>\n</dependency>\n```\n\n#### 整合方式一\n使用方面，接口与 mapper 文件正常创建使用即可。\n\n##### 核心配置文件\nmybatis 核心配置文件也一样创建，但是里面不需要配置`environments\0`与`mappers\0`标签，其它诸如起别名、驼峰映射等功能还是在核心配置文件里面写：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n        <package name=\"com.luyan.domain\"/>\n    </typeAliases>\n</configuration>\n```\n\n##### 配置类（错误）\n接下来我们主要需要将用到的对象配到容器之中：\n\n```java\n@Configuration\n@PropertySource(\"classpath:jdbc.properties\")\npublic class MapperConfig {\n    @Value(\"url\")\n    private String url;\n    @Value(\"driver\")\n    private String driver;\n    @Value(\"username\")\n    private String username;\n    @Value(\"password\")\n    private String password;\n\n    @Bean\n    // 不使用 mybatis 自带的连接池，使用 druid 连接池\n    public DataSource dataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(url);\n        dataSource.setDriverClassName(driver);\n        dataSource.setUsername(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    }\n\n    @Bean\n    // 配置 SqlSessionFactory，使用的是标准工厂\n    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {\n        SqlSessionFactoryBean sqlSessionFactoryBean \n            = new SqlSessionFactoryBean();\n        // 注入连接池\n        sqlSessionFactoryBean.setDataSource(dataSource);\n        // 设置核心配置文件路径\n        ClassPathResource resource = new ClassPathResource(\"mybatis-config.xml\");\n        sqlSessionFactoryBean.setConfigLocation(resource);\n        return sqlSessionFactoryBean;\n    }\n\n    @Bean\n    // 配置所有的 mapper 接口\n    public MapperScannerConfigurer mapperScannerConfigurer() {\n        MapperScannerConfigurer mapperScannerConfigurer \n            = new MapperScannerConfigurer();\n        // 设置基路径\n        mapperScannerConfigurer.setBasePackage(\"com.luyan.mappers\");\n        return mapperScannerConfigurer;\n    }\n}\n```\n\n使用这种方式配置 mapper，接口与映射文件的目录结构应该是一致的。即若接口放到`java/com/luyan/mappers`目录下，则映射文件放到`resources/com/luyan/mappers`下。\n\n##### 配置类（正确）\n上述写法实际上有一个 bug：mybatis 对象会优先于`@Value`注解配置，因此会出现连接池配置失败的情况。解决方案就是将连接池的配置放到一个新的配置文件中：\n\n```java\n@Configuration\n@PropertySource(\"classpath:jdbc.properties\")\npublic class DataSourceConfig {\n    @Value(\"${jdbc.url}\")\n    private String url;\n    @Value(\"${jdbc.driver}\")\n    private String driver;\n    @Value(\"${jdbc.username}\")\n    private String username;\n    @Value(\"${jdbc.password}\")\n    private String password;\n\n    @Bean\n    public DataSource dataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(url);\n        dataSource.setDriverClassName(driver);\n        dataSource.setUsername(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    }\n}\n```\n\n```java\n@Configuration\npublic class MapperConfig {\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {\n        SqlSessionFactoryBean sqlSessionFactoryBean = \n            new SqlSessionFactoryBean();\n        sqlSessionFactoryBean.setDataSource(dataSource);\n        ClassPathResource resource = new ClassPathResource(\"mybatis-config.xml\");\n        sqlSessionFactoryBean.setConfigLocation(resource);\n        return sqlSessionFactoryBean;\n    }\n\n    @Bean\n    public MapperScannerConfigurer mapperScannerConfigurer() {\n        MapperScannerConfigurer mapperScannerConfigurer = \n            new MapperScannerConfigurer();\n        mapperScannerConfigurer.setBasePackage(\"com.luyan.mapper\");\n        return mapperScannerConfigurer;\n    }\n}\n```\n\n#### 整合方式二\n方式二相较于方式一就是完全不需要核心配置文件`mybatis-config.xml`，所有的配置都直接写在代码里面，我们只需要修改创建`SqlSessionFactoryBean`的代码：\n\n```java\n@Bean\npublic SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {\n    SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();\n    factoryBean.setDataSource(dataSource);\n\n    // 配置 settings 标签内的内容\n    org.apache.ibatis.session.Configuration configuration\n            = new org.apache.ibatis.session.Configuration();\n    configuration.setMapUnderscoreToCamelCase(true);\n    configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL);\n    factoryBean.setConfiguration(configuration);\n\n    // 配置别名\n    factoryBean.setTypeAliasesPackage(\"com.luyan.domain\");\n\n    // 配置插件\n    PageInterceptor pageInterceptor = new PageInterceptor();\n    Properties properties = new Properties();\n    properties.setProperty(\"helperDialect\", \"mysql\");\n    pageInterceptor.setProperties(properties);\n    factoryBean.addPlugins(pageInterceptor);\n    \n    return factoryBean;\n}\n```\n\n与上面代码相对应的核心配置文件如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <settings>\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n        <setting name=\"autoMappingBehavior\" value=\"FULL\"/>\n    </settings>\n    \n    <typeAliases>\n        <package name=\"com.luyan.domain\"/>\n    </typeAliases>\n\n    <plugins>\n        <plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\n            <property name=\"helperDialect\" value=\"mysql\"/>\n        </plugin>\n    </plugins>\n</configuration>\n```\n\n使用这种方式就完全不需要配置文件了，我们推荐使用这种方式配置。\n\n### 开发建议\n#### 跨域请求\n现在都是前后端分离开发，前端项目直接访问我们的后端是会被拦截的。此时需要我们在 Controller 上配置`@CrossOrigin\0`注解来解除跨域请求问题。\n\n#### 统一返回\n实际开发中返回的数据可能多种多样，但我们一般会对数据做一层封装达到统一返回格式的目的：\n\n```java\n@Data\npublic class Result<T> {\n    private Integer code;\n    private String message;\n    private T data;  // 存储响应数据\n\n    private Result() {}\n    private static <T> Result<T> build(T data) {\n        Result<T> result = new Result<>();\n        result.setData(data);\n        return result;\n    }\n\n    public static <T> Result<T> build(T data, Integer code, String message) {\n        Result<T> result = build(data);\n        result.setCode(code);\n        result.setMessage(message);\n        return result;\n    }\n\n    public static <T> Result<T> build(T data, ResultCodeEnum resultCodeEnum) {\n        Result<T> result = build(data);\n        result.setCode(resultCodeEnum.getCode());\n        result.setMessage(resultCodeEnum.getMessage());\n        return result;\n    }\n\n    public static <T> Result<T> ok(T data) {\n        return build(data, ResultCodeEnum.SUCCESS);\n    }\n}\n```\n\n与之配合的枚举类`ResultCodeEnum`如下：\n\n```java\n@Getter\n@AllArgsConstructor\npublic enum ResultCodeEnum {\n    SUCCESS(200, \"success\"),\n    ACCOUNT_ERROR(501, \"account validate error\"),\n    NO_LOGIN(503, \"noLogin\"),\n    USERNAME_USED(504, \"username used\");\n\n    private Integer code;\n    private String message;\n}\n```\n\n使用的代码也非常简单：\n\n```java\n// 如果请求成功，直接调用\nreturn Result.ok(data);\n\n// 如果请求失败，则选择对应的理由，如登录校验失败\nreturn Result.build(data, ResultCodeEnum.NO_LOGIN);\n```\n\n#### JWT & Token\n##### Token\n令牌（Token）：在计算机领域，令牌是一种代表某种访问权限或身份认证信息的令牌。它可以是一串随机生成的字符或数字，用于验证用户的身份或授权用户对特定资源的访问。\n\n##### JWT 工作流程\nJWT（JSON Web Token）是具体可以生成、校验、解析 Token 的技术，其工作流程如下：\n\n+ 用户提供其凭据（通常是用户名和密码）进行身份验证；\n+ 服务器对这些凭据进行验证，并在验证成功后创建一个 JWT；\n+ 服务器将 JWT 发送给客户端，客户端在后续的请求中将 JWT 附加在请求头或参数中；\n+ 服务器接收到请求后，验证 JWT 的签名和有效性，并根据 JWT 中的声明进行身份验证和授权操作；\n\n##### JWT 数据组成\nJWT 由`头部、载荷、签名`三部分组成，中间使用`.`连接，即`header.payload.signature`。\n\nJWT 可以携带很多信息，一般情况下需要携带：\n\n+ 有效时间：保证 Token 的时效性；\n+ 签名密钥：防止 Token 被他人解析、修改；\n+ 用户信息：方便我们知道是哪一个用户访问；\n\n##### 使用\n###### 导包\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.12.5</version>\n</dependency>\n```\n\n###### 配置\n在`application.yaml`中配置相关参数：\n\n```yaml\njwt:\n  token:\n    signature: bHV5YW4gMTk5OC4xMi4wOQpMTyAwMy4wOCBWRQpsaXVtaWFveGlhIDE5OTguMDUuMjE=\n    expiration: 120 # token 有效时长，单位分钟\n```\n\n`signature`是加密签名，长度不得小于 512 字节。\n\n###### 封装工具类\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"jwt.token\")\npublic class JwtHelper {\n\n    private String signature;\n    private long expiration;\n\n    private SecretKey getSecretKey() {\n        byte[] keyBytes = signature.getBytes(StandardCharsets.UTF_8);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n\n    /**\n     * 根据用户 id 创建 Token\n     * @param userId\n     * @return\n     */\n    public String createToken(Long userId) {\n        return Jwts.builder()\n                .subject(\"LMX-SECOND-HAND-USER\")\n                .expiration(new Date(System.currentTimeMillis() + expiration * 60 * 1000))\n                .claim(\"userId\", userId)\n                .signWith(getSecretKey(), Jwts.SIG.HS512)\n                .compressWith(Jwts.ZIP.GZIP)\n                .compact();\n    }\n\n    /**\n     * 从 Token 里获取用户 id\n     * @param token\n     * @return\n     */\n    public Long getUserId(String token) {\n        if (!StringUtils.hasText(token)) return null;\n        Claims claims = Jwts.parser()\n                .verifyWith(getSecretKey())\n                .build()\n                .parseSignedClaims(token)\n                .getPayload();\n        return claims.get(\"userId\", Long.class);\n    }\n\n    /**\n     * 校验 Token 是否过期\n     * @param token\n     * @return\n     */\n    public boolean isExpiration(String token) {\n        if (!StringUtils.hasText(token)) return true;\n        Claims claims = Jwts.parser()\n                .verifyWith(getSecretKey())\n                .build()\n                .parseSignedClaims(token)\n                .getPayload();\n        return claims.getExpiration().before(new Date());\n    }\n}\n\n```\n\n###### 测试\n```java\nString token = jwtHelper.createToken(99L);\nSystem.out.println(token);\nLong userId = jwtHelper.getUserId(token);\nSystem.out.println(userId);\nSystem.out.println(jwtHelper.isExpiration(token));\n```\n\n'),
       (15, 15, '正常开发我们使用 SSM 就足够了，但使用 SSM 需要我们自己记住许多包，而且配置也很多。以前倒是没什么，但目前微服务横行，每个服务都是一个项目，每个项目都需要配置一遍实在繁琐。因此 SpringBoot 就出现了，SpringBoot 底层还是 SSM 那一套，只不过很多功能都集成进去就方便许多。\n\n### 快速入门\n#### 配置\n首先我们将模块继承指定的 SpringBoot 父工程：\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.7.18</version>\n</parent>\n```\n\n接着导 web 包（这个包里面包含了 SpringMVC 的依赖）：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n因为这个包在父工程里面做了声明，所以不需要写版本号。\n\n#### 写 Handler\n我们仍然使用 SpringMVC 那一套书写 Handler：\n\n```java\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n    @GetMapping(\"hello\")\n    public String hello() {\n        return \"Hello Boy!\";\n    }\n}\n```\n\n#### 配置启动类\nSpringBoot 的启动类就是一个包含 main 函数的类，如下：\n\n```java\n// 类上需要加 @SpringBootApplication 注解\n@SpringBootApplication\npublic class Main {\n    public static void main(String[] args) {\n        // 调用启动方法，第一个参数是当前类\n        SpringApplication.run(Main.class, args);\n    }\n}\n```\n\n运行这个 main 函数项目就启动起来了，并且会自动开启 Tomcat，十分方便。\n\n关于`@SpringBootApplication`注解有以下功能：\n\n1. 它继承于`@Configuration`注解，因此我们可以在当前类中使用`@Bean`注解定义外部组件；\n2. 它继承于`@ComponentScan\0`注解，因此它会扫描启动类当前及其子包下的所有注解；\n3. 它继承于`@EnableAutoConfiguration\0`注解，因此它会自动加载配置文件；\n\n### 统一配置管理\n#### 概念\nSpringBoot 尽管尽量减少了配置，但有些配置不能避免或需要自定义。例如数据库连接信息、Tomcat 端口号、项目访问根路径以及一些自定义的配置。在 SpringBoot 中这些配置都会放在一个统一的文件中：`resources/application.properties`或`resources/application.yml`。\n\n#### properties 格式\n我们使用`application.properties`举例子：\n\n```properties\n# Tomcat 端口号配置\nserver.port=80\n# 项目访问根路径\nserver.servlet.context-path=/root\n\n# 自定义的属性\nluyan.name=Jack\n```\n\n这些属性配置好之后再启动服务即刻生效，对于自定义属性可以直接使用`@Value(\"${key}\")`获取。\n\n#### yml 格式\n因为所有配置都要放在配置文件里面，为了避免重复，properties 文件里面使用多层命名，例如`server.port`等。当命名层次比较深的时候写的很费劲，而且也不便于阅读。因此 yml 就出现了，yml 是一种层次化的配置文件格式，文件后缀是`.yml`或`.yaml`，下面是一个例子：\n\n```yaml\nserver:\n  port: 80\n  servlet:\n    context-path: /root\n    \nluyan:\n  name: Jack\n```\n\n这边的效果与上面写的 properties 文件是一样的。\n\n对于一些简单类型的值（单个值）我们可以直接使用`@Value`注解注入到一个变量中，但 yml 文件中还可以定义集合数据，集合数据不能使用`@Value`注解注入，数据如下：\n\n```yaml\nluyan:\n  name: Jack\n  hobbies: # 下面使用 \"- 值\" 指定集合的多个值\n    - football\n    - basketball\n```\n\n对于`hobbies`属性就无法使用`@Value`注解注入，想要获取集合的值首先为数据创建一个类：\n\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"luyan\")\npublic class User {\n    private String name;\n    private List<String> hobbies;\n}\n```\n\n创建的实体类需要使用`@Component`注解修饰，不然 Spring 如何为它注入值呢。\n\n其次使用`@ConfigurationProperties`注解开启配置注入，`prefix = \"luyan\"`表示将配置中`luyan`开头的所有配置注入到实体类的属性中。\n\n#### 多配置文件\nSpringBoot 支持的配置文件后缀是`.properties、.yml、.yaml`，下面都以`.yml`举例子。\n\n我们已经知道了 SpringBoot 所有配置都在`application.yml`里面定义，这会产生两个问题：\n\n1. 配置太多显得配置文件臃肿凌乱；\n2. 需要区分环境的配置每次都要手动修改，麻烦；\n\n为了解决这两个问题，SpringBoot 支持定义子配置文件。子配置文件命名规则是`application-{key}.yml`，这边的`{key}`可随意替换。\n\n1. 对于分环境的场景，我们可以定义两个配置文件`application-test.yml`与`application-dev.yml`分别表示测试与开发环境；\n2. 对于分文件存储的情况，我们可以定义`application-jdbc.yml`与`application-mybatis.yml`分别用来存储数据库与 MyBatis 相关的配置；\n\n光是定义这些子配置文件是不会生效的，SpringBoot 仍然只会读取`application.yml`。想要让子配置文件生效我们需要在`application.yml`里面配置如下：\n\n```yaml\nspring:\n  profiles:\n    active: dev,jdbc,mybatis\n```\n\n`spring.profiles.active`\0用来指定激活的子文件，注意只需要写`key`的部分，可同时激活多个子文件。如果多个文件里面有值重复，后面的会覆盖前面的。\n\n#### 常用内置配置项\n1. `server.port\0`用来配置服务器端口号，默认值`8080`；\n2. `server.servlet.context-path\0`用来配置项目的访问根目录，默认值`/`；\n3. `server.servlet.encoding.charset\0`用来配置请求与响应时的字符编码，默认值`UTF-8`；\n4. `server.servlet.encoding.enabled\0`用来配置是否开启字符编码设置，默认值`true`；\n5. `spring.mvc.view.prefix\0`用来配置视图解析器的前缀，默认值空串；\n6. `spring.mvc.view.suffix\0`用来配置视图解析器的后缀，默认值空串；\n7. `spring.web.resources.static-locations\0`用来配置静态资源地址，默认值如下：\n    1. `classpath:/META-INF/resources/`\n    2. `classpath:/resources/`\n    3. `classpath:/static/`\n    4. `classpath:/public/`\n\n上面的配置前几个比较简单，最后一个静态资源路径需要说一下。静态资源目录就是存储图片、CSS、JS等文件的目录。默认有 4 个，上面的目录都是位于`resources`目录下。\n\n例如我们有`resources/static/a.jpg`文件，在所有配置都默认的情况下，访问的路径是`localhost:8080/a.jpg`，也就是说文件前面的静态资源目录是不需要加的。\n\n#### 拦截器配置\n在 SpringMVC 里面拦截器是经常需要用到的功能，那在 SpringBoot 里面该如何配置拦截器？\n\n答：与以前一样，只需要创建一个配置文件，实现`WebMvcConfigurer`接口如下：\n\n```java\n@EnableWebMvc\n@Configuration\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 为所有请求注册拦截器（静态资源不拦截）\n        registry.addInterceptor(new MyInterceptor());\n    }\n}\n```\n\n实际上到此就结束了，不需要做额外的配置。总结下来就两步：\n\n1. 创建自定义拦截器；\n2. 在配置类中添加拦截器；\n\n还是那句话，SpringBoot 会自动扫描启动类所在包及其子包下的所有注解，因此这个配置类也会被扫描到，于是配置类里面添加的拦截器也会自动生效。\n\n### 整合 Druid 连接池\n#### 导包\n```xml\n<!-- 继承父类的版本 -->\n<!-- JdbcTemplate、事务等 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n<!-- druid 连接池 -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.2.22</version>\n</dependency>\n\n<!-- mysql 连接器 -->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.33</version>\n</dependency>\n```\n\n#### 配置\n连接池基本信息的配置如下：\n\n```yaml\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource  # 使用 druid 连接池\n    username: root\n    password: mysql2425@\n    url: jdbc:mysql://localhost:3306/demo\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n#### 使用\n```java\npublic class UserController {\n    @Autowired  // 直接自动装配\n    private JdbcTemplate jdbcTemplate;\n\n    public List<User> all() {\n        String sql = \"select * from users;\";\n        List<User> users = jdbcTemplate.query(sql, \n                new BeanPropertyRowMapper<>(User.class));\n        return users;\n    }\n}\n```\n\n### 整合 MyBatis\n#### 导包\n需要新导入的是 MyBatis 包，其它诸如 Druid 连接池、mysql 连接器等都在上一节导过了：\n\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.3.2</version>\n</dependency>\n```\n\n#### 配置\n```yaml\nmybatis:\n  mapper-locations: classpath:/mappers/*.xml\n  type-aliases-package: com.luyan.pojo\n  configuration:\n    map-underscore-to-camel-case: true\n    auto-mapping-behavior: full\n```\n\n着重需要配置的有如下内容：\n\n+ `mybatis.mapper-locations`配置 mapper 文件路径；\n    - 默认值是`classpath*:/mapper/**/*.xml`，也就是`resources/mapper/`目录下面的所有 xml 文件都可以读取；\n+ `mybatis.type-aliases-package`配置别名包；\n+ `mybatis.configuration.map-underscore-to-camel-case`配置驼峰映射；\n    - 默认值是`true`；\n+ `mybatis.configuration.auto-mapping-behavior`配置自动映射；\n    - 默认值是`AutoMappingBehavior.PARTIAL`；\n\n#### 使用\n1. 正常创建 mapper 接口与 mapper 文件：\n\n```java\npublic interface UserMapper {\n    List<User> queryAll();\n}\n```\n\n```xml\n<select id=\"queryAll\" resultType=\"user\">\n    select * from users\n</select>\n```\n\n2. 在启动类上添加`@MapperScan`注解用来配置 mapper 接口位置：\n\n```java\n@MapperScan(\"com.luyan.mappers\")\n@SpringBootApplication\npublic class Main {\n    public static void main(String[] args) {\n        SpringApplication.run(Main.class, args);\n    }\n}\n```\n\n3. 使用接口：\n\n```java\npublic class UserController {\n    @Autowired\n    private UserMapper userMapper;\n\n    public List<User> all() {\n        List<User> users = userMapper.queryAll();\n        return users;\n    }\n}\n```\n\n### 整合 tx 与 aop\n#### tx\n事务所需的包仍然是包含在`spring-boot-starter-jdbc\0`里面，上面已经说过。\n\n与之前在 Spring 里面使用事务不同，SpringBoot 不需要往容器中手动添加事务管理器，直接使用事务相关注解即可。\n\n```java\n@Transactional  // 直接使用事务注解\npublic int deleteById() {\n    int rows = userMapper.delete(2);\n    int i = 1 / 0;\n    return rows;\n}\n```\n\n其它使用都是一样，总结下来在 SpringBoot 中使用事务非常简单：1、导包；2、使用。\n\n#### aop\n在 SpringBoot 里面开启 AOP 非常简单，只需要导包写切面即可。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n切面代码如下：\n\n```java\n@Aspect\n@Component\npublic class LogAdvice {\n    @Before(\"execution(* com..service.*.*())\")\n    public void log(JoinPoint joinPoint) {\n        System.out.println(joinPoint.getSignature().getName());\n    }\n}\n```\n\n### 打包运行\n传统 JavaWeb 项目打包成 war 包，然后放到`tomcat > webapps`目录下。但 Springboot 项目自带 tomcat，因此打包出来是一个 jar 包。\n\n#### 打包\n##### 安装插件\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <version>2.7.18</version>\n        </plugin>\n    </plugins>\n</build>\n```\n\n这边的`build`标签与`dependencies\0`标签同级。\n\n##### package\n![](/upload/covers/2d409940948b49a29051811b0785698c.png)\n\n如右图，打开 IDEA 的 Maven 面板并双击生命周期里的`package`即可。\n\n#### 运行\n将 jar 包复制到合适的地方，并在控制台使用指令运行：\n\n```xml\njava -jar fileName.jar\n```\n\n我们使用控制台命令执行 jar 包的时候还可以指定参数，这些参数就是在`application.yml`里面定义的系统参数，例如端口号、激活的配置文件等。注意在命令中添加参数会覆盖配置文件里面的参数，也就是说以命令里面的参数为准。\n\n```xml\njava -jar -Dserver.port=8888 -Dspring.profiles.active=dev,test fileName.jar\n```\n\n可以看到定义参数主要使用`-D`指定。\n\n'),
       (16, 16, 'MyBatis-Plus 是对 MyBatis 的二次封装，可以让我们少写 sql 语句。\n\n### 快速入门\n#### 导包\n```xml\n<!-- mybatis-plus -->\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.5.6</version>\n</dependency>\n\n<!-- SpringBoot3 分模块项目实测需要这个依赖 -->\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n    <version>3.0.4</version>\n</dependency>\n\n<!-- jdbc -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n<!-- Druid 连接池 -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.2.22</version>\n</dependency>\n\n<!-- mysql 连接器 -->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.33</version>\n</dependency>\n\n<!-- Lombok -->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n</dependency>\n\n<!-- 测试包 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n</dependency>\n```\n\n#### 配置\n我们需要连接数据库，所以我们需要配置 Druid 连接池。配置如下：\n\n```yaml\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    url: jdbc:mysql://localhost:3306/demo\n    username: root\n    password: mysql2425@\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n#### 定义接口\n和 MyBatis 一样，我们需要定义 mapper 接口。但不同的是，单表操作完全不需要我们操心，我们只需要继承`BaseMapper`接口，这个接口里面有单表操作的默认实现，如下：\n\n```java\npublic interface UserMapper extends BaseMapper<User> { }\n```\n\n继承`BaseMapper`有两个注意点：\n\n1. 多表操作需要自己写 sql 语句；\n2. 继承时指定的泛型名会默认作为操作的表名（忽略大小写）；\n\n#### 启动类\nSpringBoot 项目需要书写启动类：\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.luyan.mappers\")\npublic class Main {\n    public static void main(String[] args) {\n        SpringApplication.run(Main.class, args);\n    }\n}\n```\n\n#### 测试\n因为主要学习 MyBatis-Plus，因此直接使用测试类进行测试：\n\n```java\n@SpringBootTest  // SpringBoot 测试类注解\npublic class MybatisPlusTest {\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void test() {\n        // 使用继承来的 selectList 方法获取所有数据\n        List<User> users = userMapper.selectList(null);\n        System.out.println(users);\n    }\n}\n```\n\n### Mapper CRUD\n本节主要介绍一下 mapper 层提供的 CRUD 方法，即`BaseMapper`提供的数据库操作。\n\n#### 增\n插入数据只有一个方法，如下：\n\n```java\nint insert(T entity);\n```\n\n使用起来也非常简单，只需要创建一个实体类，直接调用`insert`方法即可：\n\n```java\nUser user = new User();\nuser.setId(6);\nuser.setAge(20);\nuser.setName(\"六六\");\nint rows = userMapper.insert(user);  // 添加数据\n```\n\n#### 删\n正常使用的比较多的有 4 个方法，如下：\n\n```java\n// 根据 id 删除记录\nint deleteById(Serializable id);\n\n// 根据 id 批量删除记录\nint deleteBatchIds(Collection<?> idList);\n\n// 根据条件删除记录，会使用 key=value 作为条件\nint deleteByMap(Map<String, Object> columnMap);\n\n// 根据条件删除记录，Wrapper 是条件封装类\nint delete(Wrapper<T> queryWrapper);\n```\n\n上面方法中最后一个条件删除方法，里面的`Wrapper`类型是条件类型，我们后面统一说。\n\n```java\nint rows = userMapper.deleteById(1);  // 删一个\n\nint rows = userMapper.deleteBatchIds(List.of(1, 2));  // 删一批\n\nMap<String, Object> map = new HashMap<>();\nmap.put(\"age\", 19);\nmap.put(\"name\", \"赵六\");\n// 最后的删除条件会变成 age=19 AND name=\"赵六\"\nint rows = userMapper.deleteByMap(map);\n```\n\n#### 改\n更新数据我们常用的是以下 2 个：\n\n```java\n// 根据 id 更新数据\nint updateById(T entity);\n\n// 根据条件更新数据\nint update(T entity, Wrapper<T> updateWrapper);\n```\n\n要更新的数据显然都存在`entity`里面，实体类里面为`null`的字段不参与更新，因此设计实体类时字段类型都使用包装类型。`updateById`方法会使用 id 作为更新条件，`update`方法会使用指定条件参数作为条件。\n\n```java\nUser user = new User();\nuser.setId(3);\nuser.setName(\"KK\");\nint rows = userMapper.updateById(user);  // 根据 id 更新姓名\n\nUser user = new User();\nuser.setAge(22);\n// 无条件即更新所有记录\nint rows = userMapper.update(user1, null);\n```\n\n#### 查\n```java\n// 根据 id 查询\nT selectById(Serializable id);\n\n// 根据条件查询一条记录\nT selectOne(Wrapper<T> queryWrapper);\n\n// 根据 id 批量查询\nList<T> selectBatchIds(Collection<? extends Serializable> idList);\n\n// 根据条件查询记录\nList<T> selectList(Wrapper<T> queryWrapper);\n\n// 将 key=value 作为条件查询记录\nList<T> selectByMap(Map<String, Object> columnMap);\n\n// 根据条件查询，将结果保存在 List<Map<String, Object>> 中\nList<Map<String, Object>> selectMaps(Wrapper<T> queryWrapper);\n\n// 根据条件查询，返回由所有记录第一个字段构成的列表\n<E> List<E> selectObjs(Wrapper<T> queryWrapper);\n\n// 分页查询\n<P extends IPage<T>> P selectPage(P page, Wrapper<T> queryWrapper);\n<P extends IPage<Map<String, Object>>> P selectMapsPage(P page, Wrapper<T> queryWrapper);\n\n// 根据条件查询记录条数\nLong selectCount(Wrapper<T> queryWrapper);\n```\n\n这些方法都是比较容易理解的，简单使用样例如下：\n\n```java\nUser user = userMapper.selectById(4);\n\nList<Integer> ids = userMapper.selectObjs(null);\n\nList<Map<String, Object>> users = userMapper.selectMaps(null);\n```\n\n### Service CRUD\n一般而言，数据库操作是放在 mapper 层的，但 MyBatis-Plus 居然提供了 service 层操作数据库的方法。之所以有这样的需求，是因为在很多简单的数据库操作中，service 层只是走个过场，方法里面也只是调用 mapper 层。这浪费了效率，因此出现了 service 层操作数据库的操作。\n\n#### 创建 Service\n我们想在 Service 层调用对应的数据库操作方法，首先这个 Service 肯定需要实现某接口，就和 Mapper 层操作数据库一样。\n\n```java\n// 定义 Service 实现 IService 接口\npublic interface UserService extends IService<User> { }\n```\n\n这边和上面 Mapper 层似乎差不多，但`IService`接口里面有很多方法没有实现。但是 MyBatis-Plus 提供了`ServiceImpl\0`类，这个类继承于`IService`接口并实现了所有抽象方法，因此我们一般直接继承这个类：\n\n```java\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> { }\n```\n\n`ServiceImpl`类有两个泛型（按照顺序记为`M、T`）：\n\n+ `M`需要满足`M extends BaseMapper<T>\0`，也就是说这边`M`是 Mapper 层的操作接口；\n+ `T`层就是实体类；\n\n在日常使用中，我们一般会使用接口来接受对象，因此我们更多使用如下方式定义 Service：\n\n```java\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> \n    implements UserService {  // 额外实现我们自定义的接口方便功能扩展\n}\n```\n\n于是在需要的地方可以直接注入：\n\n```java\n@Autowired\nprivate UserService userService;  // 使用接口类型声明变量\n```\n\n#### 增\n```java\n// 插入一条记录\nboolean save(T entity);\n\n// 插入（批量）\nboolean saveBatch(Collection<T> entityList);\n\n// 插入（批量）\nboolean saveBatch(Collection<T> entityList, int batchSize);\n```\n\n`save`方法很简单，不多解释。我们知道数据库`insert`语句可以一次插入多条数据，但这边的`saveBatch`方法实际上会生成多条`insert`语句，即挨条插入数据。`batchSize`参数表示插多少条数据就刷新一下，如果不传这个参数默认是 1000 条。\n\n```java\nUser user = new User(\"Jack\", 89);\n// 插入一条数据\nboolean success = userService.save(user);\n\nUser user1 = new User(\"P1\", 19);\nUser user2 = new User(\"P2\", 19);\nList<User> list1 = List.of(user1, user2);\n// 批量插入，每插入 1000 条就刷新一次数据库\nboolean success = userService.saveBatch(list1);\n\nUser user3 = new User(7, \"P3\", 19);\nUser user4 = new User(8, \"P4\", 19);\nUser user5 = new User(9, \"P5\", 19);\nUser user6 = new User(10, \"P6\", 19);\nList<User> list2 = List.of(user3, user4, user5, user6);\n// 批量插入，每插入 2 条就刷新一次数据库\nboolean success = userService.saveBatch(list2, 2);\n```\n\n因为批量添加数据是多次使用`insert`语句，所以效率不是很高，如果想要高效的批量的插入可以自己实现。实现方式我们之前学过，在 mapper xml 文件里面使用`foreach`标签定义插入语句。\n\n#### 删\n```java\n// 根据 id 删除\nboolean removeById(Serializable id);\n\n// 根据 id 批量删除\nboolean removeByIds(Collection<? extends Serializable> idList);\n\n// 条件删除，条件是 key=value\nboolean removeByMap(Map<String, Object> columnMap);\n\n// 根据 queryWrapper 设置的条件，删除记录\nboolean remove(Wrapper<T> queryWrapper);\n```\n\n这些方法都很容易理解，使用如下：\n\n```java\n// 根据 id 删除数据\nboolean success = userService.removeById(1);\n\nList<Integer> ids = List.of(2, 3);\n// 根据 id 批量删除数据\nboolean success = userService.removeByIds(ids);\n\nMap<String, Object> map = new HashMap<>();\nmap.put(\"uid\", 10);\n// 根据条件删除数据，key=value\nboolean success = userService.removeByMap(map);\n```\n\n#### 改\n```java\n// 根据 id 修改\nboolean updateById(T entity);\n\n// 根据 id 批量更新\nboolean updateBatchById(Collection<T> entityList);\n\n// 根据 id 批量更新，batchSize 指定刷新数据阈值\nboolean updateBatchById(Collection<T> entityList, int batchSize);\n\n// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset\nboolean update(Wrapper<T> updateWrapper);\n\n// 根据 whereWrapper 条件，更新记录\nboolean update(T updateEntity, Wrapper<T> whereWrapper);\n```\n\n大体使用如下：\n\n```java\nUser user1 = new User(1, \"P3\", 22);\n// 根据 id 修改数据\nboolean success = userService.updateById(user1);\n\nUser user2 = new User(2, \"P4\", 22);\nUser user3 = new User(3, \"P5\", 22);\nList<User> list = List.of(user2, user3);\n// 根据 id 批量修改数据\nboolean success = userService.updateBatchById(list);\n```\n\n#### 查\n##### 查一条数据\n```java\n// 根据 id 查询一条记录\nT getById(Serializable id);\n\n// 根据 Wrapper，查询一条记录\nT getOne(Wrapper<T> queryWrapper);\n\n// 根据 Wrapper 查询一条记录，throwEx 控制有多条数据是否抛异常\nT getOne(Wrapper<T> queryWrapper, boolean throwEx);\n\n// 根据 Wrapper，查询一条记录，使用 Map 装数据\nMap<String, Object> getMap(Wrapper<T> queryWrapper);\n\n// 根据 Wrapper，查询一条记录\n<V> V getObj(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);\n```\n\n这些方法还是见名知义的，除去`Wrapper`作为参数的，使用案例如下：\n\n```java\n// 根据 id 获取数据，返回实体类对象\nUser user = userService.getById(4);\n```\n\n##### 查多条数据\n```java\n// 查询所有\nList<T> list();\n\n// 根据条件查询列表\nList<T> list(Wrapper<T> queryWrapper);\n\n// 根据 id 批量查询\nCollection<T> listByIds(Collection<? extends Serializable> idList);\n\n// 根据条件查询，key=value\nCollection<T> listByMap(Map<String, Object> columnMap);\n\n// 查询所有列表\nList<Map<String, Object>> listMaps();\n\n// 查询列表\nList<Map<String, Object>> listMaps(Wrapper<T> queryWrapper);\n\n// 查询全部记录，返回第一个字段数据组成的 List\nList<Object> listObjs();\n\n// 查询全部记录\n<V> List<V> listObjs(Function<? super Object, V> mapper);\n\n// 根据 Wrapper 条件，查询全部记录\nList<Object> listObjs(Wrapper<T> queryWrapper);\n\n// 根据 Wrapper 条件，查询全部记录\n<V> List<V> listObjs(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);\n```\n\n简单使用如下：\n\n```java\n// 获取所有数据，返回实体类的集合\nList<User> list1 = userService.list();\n\n// 根据 id 批量获取数据，返回实体类的集合\nList<User> list2 = userService.listByIds(List.of(4, 7));\n\nMap<String, Object> map = new HashMap();\nmap.put(\"age\", 19);\n// 根据 Map 条件获取数据，返回实体类集合\nList<User> list3 = userService.listByMap(map);\n\n// 获取所有数据，返回 Map 集合\nList<Map<String, Object>> list4 = userService.listMaps();\n\n// 获取所有数据，返回数据第一个字段构成的集合\nList<Object> list5 = userService.listObjs();\n```\n\n##### 统计查询\n```java\n// 查询总记录数\nlong count();\n\n// 根据 Wrapper 条件，查询总记录数\nlong count(Wrapper<T> queryWrapper);\n```\n\n简单使用如下：\n\n```java\n// 获取所有记录条数\nlong nums = userService.count();\n```\n\n#### 增改\n所谓“增改”指的是数据存在就修改，不存在就新增。具体有如下方法：\n\n```java\n// id 存在就更新数据，否则插入数据\nboolean saveOrUpdate(T entity);\n\n// 批量修改插入，是否存在仍然看 id\nboolean saveOrUpdateBatch(Collection<T> entityList);\n\n// 批量修改插入，是否存在仍然看 id\nboolean saveOrUpdateBatch(Collection<T> entityList, int batchSize);\n```\n\n批量插入方法也是挨条记录操作，对每条记录，如果 id 存在就是更新，否则就是插入。`batchSize`参数的含义与插入一样，如果不传默认是 1000。\n\n```java\nUser user1 = new User(\"小黑\", 22);\nUser user2 = new User(1, \"王麻薯\", 22);\nList<User> list = List.of(user1, user2);\n// 根据 id 判断记录是否存在，存在就修改数据，否则插入数据\nboolean success = userService.saveOrUpdateBatch(list);\n```\n\n### 分页查询\n现在开发中分页查询是很常见的操作，MyBatis-Plus 分页操作非常简单。\n\n#### 添加插件\n我们只需要在启动类里面使用`@Bean`注解添加插件即可：\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.luyan.mappers\")\npublic class Main {\n    public static void main(String[] args) {\n        SpringApplication.run(Main.class, args);\n    }\n\n    @Bean  \n    // 返回的实际上是插件的集合\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        // 添加分页插件\n        interceptor.addInnerInterceptor(\n            new PaginationInnerInterceptor(DbType.MYSQL)\n        );\n        return interceptor;\n    }\n}\n```\n\n#### Mapper 分页\n##### 方法\n```java\n// 获取分页数据，将记录封装成实体类\n<P extends IPage<T>> P selectPage(P page, Wrapper<T> queryWrapper);\n\n// 获取分页数据，将记录封装成 Map\n<P extends IPage<Map<String, Object>>> P selectMapsPage(P page, Wrapper<T> queryWrapper);\n```\n\n##### 使用\n```java\n// 定义 Page 对象时传的两个参数分别是“当前页”与“页容量”\nPage<User> page = new Page<>(2, 3);\nuserMapper.selectPage(page, null);  // 无条件查询所有\n\nSystem.out.println(\"当前页：\" + page.getCurrent());\nSystem.out.println(\"页容量：\" + page.getSize());\nSystem.out.println(\"记录总数：\" + page.getTotal());\nSystem.out.println(\"总页数：\" + page.getPages());\nSystem.out.println(\"是否有前一页：\" + page.hasPrevious());\nSystem.out.println(\"是否有下一页：\" + page.hasNext());\nSystem.out.println(page.getRecords());  // 记录集合\n```\n\n#### Service 分页\n##### 方法\n```java\n// 无条件分页查询，封装成实体类\nIPage<T> page(IPage<T> page);\n\n// 条件分页查询，封装成实体类\nIPage<T> page(IPage<T> page, Wrapper<T> queryWrapper);\n\n// 无条件分页查询，封装成 Map\nIPage<Map<String, Object>> pageMaps(IPage<T> page);\n\n// 条件分页查询，封装成 Map\nIPage<Map<String, Object>> pageMaps(IPage<T> page, Wrapper<T> queryWrapper);\n```\n\n##### 使用\n```java\nPage<User> page = new Page<>(2, 3);\nuserService.page(page);  // 与 Mapper 层相比除了方法不一样，其它都是一样的\nSystem.out.println(\"当前页：\" + page.getCurrent());\nSystem.out.println(\"页容量：\" + page.getSize());\nSystem.out.println(\"记录总数：\" + page.getTotal());\nSystem.out.println(\"总页数：\" + page.getPages());\nSystem.out.println(\"是否有前一页：\" + page.hasPrevious());\nSystem.out.println(\"是否有下一页：\" + page.hasNext());\nSystem.out.println(page.getRecords());\n```\n\n#### 自定义方法分页\n将分页插件应用到自定义方法上比较简单，只需要在定义方法的时候：\n\n+ 方法第一个参数是`IPage`类型；\n+ 方法返回值类型是`IPage`；\n\n下面我们用一个例子看一下：\n\n1. `UserMapper`接口定义如下：\n\n```java\npublic interface UserMapper extends BaseMapper<User> {\n    // 自定义方法，返回值类型与第一个参数类型都必须是 IPage\n    IPage<User> queryByAge(IPage<User> page, @Param(\"age\") Integer age);\n}\n```\n\n2. 对应的`UserMapper.xml`文件如下：\n\n```xml\n<!-- 返回值类型是 IPage 的泛型类型 -->\n<select id=\"queryByAge\" resultType=\"user\">\n    SELECT * FROM user WHERE age=#{age}\n</select>\n```\n\n3. 实体类别名配置一下：、\n\n```yaml\nmybatis-plus:\n  type-aliases-package: com.luyan.pojo\n```\n\n因为我们将 mapper 文件存在`resources/mapper`目录下，这是扫描的默认值，所以不需要特意配置。\n\n4. 最后测试代码如下：\n\n```java\nPage<User> page = new Page<>(1, 3);\nuserMapper.queryByAge(page, 19);  // 使用上没什么区别\nSystem.out.println(\"当前页：\" + page.getCurrent());\nSystem.out.println(\"页容量：\" + page.getSize());\nSystem.out.println(\"记录总数：\" + page.getTotal());\nSystem.out.println(\"总页数：\" + page.getPages());\nSystem.out.println(\"是否有前一页：\" + page.hasPrevious());\nSystem.out.println(\"是否有下一页：\" + page.hasNext());\nSystem.out.println(page.getRecords());\n```\n\n### 条件构造器\n使用 MyBatis-Plus 条件构造器可以构造灵活、高效的查询条件。\n\n#### 继承结构\n![](/upload/covers/5fa9c211d6b744af8d2fc99ed8ac0d98.png)\n\n+ `Wrapper`：条件构造抽象类，最顶端父类\n    - `AbstractWrapper`\n        * `UpdateWrapper`：修改条件封装\n        * `QueryWrapper`：查询/删除/修改条件封装\n        * `AbstractLambdaWrapper`：是 Lambda 语法\n            + `**LambdaUpdateWrapper**`：Lambda 修改条件封装\n            + `**LambdaQueryWrapper**`：Lambda 查询/删除/修改条件封装\n\n这些条件构造器中我更推荐使用 Lambda 语法的。\n\n#### QueryWrapper\n##### like\n`like`方法对应数据库语句`column LIKE \'%val%\'`：\n\n```java\nlike(R column, Object val)  // 两个参数分别表示列名和数据库的值\nlike(boolean condition, R column, Object val)  // 多一个条件判断参数\n```\n\n例：查询姓名里面有“王”字的所有用户\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\nwrapper.like(\"name\", \"王\");  // name LIKE \'%王%\'\nList<User> users = userMapper.selectList(wrapper);\n```\n\n##### between\n`between`方法对应数据库语句`column BETWEEN val1 AND val2`：\n\n```java\nbetween(R column, Object val1, Object val2)\nbetween(boolean condition, R column, Object val1, Object val2)\n```\n\n例：查询所有年龄在 18 到 20 之间的用户\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\nwrapper.between(\"age\", 18, 20);  // age BETWEEN 18 AND 20\nList<User> users = userMapper.selectList(wrapper);\n```\n\n注意：`BETWEEN`是左右都包含，因此例子中是查询所有年龄为 18、19、20 的用户。\n\n##### 比较\n比较操作有`=,<>,>,>=,<,<=`，对应方法如下：\n\n```java\n// 等于 =\neq(R column, Object val)\neq(boolean condition, R column, Object val)\n\n// 不等于 <>\nne(R column, Object val)\nne(boolean condition, R column, Object val)\n\n// 大于 >\ngt(R column, Object val)\ngt(boolean condition, R column, Object val)\n\n// 大于等于 >=\nge(R column, Object val)\nge(boolean condition, R column, Object val)\n\n// 小于 <\nlt(R column, Object val)\nlt(boolean condition, R column, Object val)\n\n// 小于等于 <=\nle(R column, Object val)\nle(boolean condition, R column, Object val)\n```\n\n例：将所有年龄小于 18 的用户年龄改为 18\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\nwrapper.lt(\"age\", 18);\nUser user = new User();\nuser.setAge(18);\nint rows = userMapper.update(user, wrapper);\n```\n\n##### 判空\n+ `isNull`方法对应数据库语句`column IS NULL`\n+ `isNotNull`方法对应数据库语句`column IS NOT NULL`\n\n```java\nisNull(R column)\nisNull(boolean condition, R column)\n\nisNotNull(R column)\nisNotNull(boolean condition, R column)\n```\n\n例：删除所有年龄为空的用户\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\nwrapper.isNull(\"age\");  // age IS NULL\nint rows = userMapper.delete(wrapper);\n```\n\n##### 排序\n排序分为升序排序和降序排序，有以下方法：\n\n```java\n// 升序排序\norderByAsc(R... columns)\norderByAsc(boolean condition, R... columns)\n\n// 降序排序\norderByDesc(R... columns)\norderByDesc(boolean condition, R... columns)\n\n// 指定排序升降\norderBy(boolean condition, boolean isAsc, R... columns)\n```\n\n例：查询所有用户要求按年龄降序、id 升序排序\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\nwrapper.orderByDesc(\"age\")\n        .orderByAsc(\"id\");  // ORDER BY age DESC, id ASC\nList<User> users = userMapper.selectList(wrapper);\n```\n\n注意：数据库里面使用多个关键字进行排序时，只有前面的字段相同才会使用后面的字段。\n\n##### or\n如果有多个条件，默认使用`AND`连接。如果需要使用`OR`连接，可以调用以下方法：\n\n```java\nor()\nor(boolean condition)\n```\n\n注意：调用`or`方法之后，只有紧邻着的两个条件之间使用`OR`，其余的仍然是`AND`。\n\n例：查询所有年龄为空或年龄在`[18, 20]`之间且姓名包含“王”的用户\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\n\n// age IS NULL OR age BETWEEN 18 AND 20 AND name LIKE \'%王%\'\nwrapper.isNull(\"age\")\n        .or()\n        .between(\"age\", 18, 20)\n        .like(\"name\", \"王\");\nList<User> users = userMapper.selectList(wrapper);\n```\n\n##### 指定列\n默认查询会查询所有字段，可以使用如下方法指定查询的字段：\n\n```java\nselect(R... columns)\nselect(boolean condition, R... columns)\n\nselect(List<R> columns)\nselect(boolean condition, List<R> columns)\n```\n\n例：查询所有年龄不为空的学生的姓名与年龄\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\nwrapper.select(\"name\", \"age\");\nwrapper.isNotNull(\"age\");\nList<User> users = userMapper.selectList(wrapper);\n```\n\n##### 条件判断\n使用条件构造器可以很方便的构造条件，但对于一些条件我们并不想无脑添加，而是满足一定条件时才添加。上面的方法基本都有一个重载的形式，第一个参数是一个`boolean condition`，这个`condition`就是条件表达式，当其值为`true`时对应的条件才会添加。\n\n例：当前端传过来年龄不为空时才会追加一个`age > val`的条件\n\n```java\nQueryWrapper<User> wrapper = new QueryWrapper<>();\n// 只有前端传过来的 age != null 时才会限制 age 的大小\nwrapper.gt(age != null, \"age\", age);\nList<User> users = userMapper.selectList(wrapper);\n```\n\n#### UpdateWrapper\n如果想修改数据，我们当然更推荐使用`UpdateWrapper`。相比`QueryWrapper`，`UpdateWrapper`有以下优点：\n\n1. `UpdateWrapper`可以携带修改的数据，不需要额外创建实体类；\n2. `UpdateWrapper`可以把某个值设置为空，而`QueryWrapper`不能；\n\n例：把姓名为“张三”或“李四”的用户年龄设置为空\n\n```java\nUpdateWrapper<User> wrapper = new UpdateWrapper<>();\nwrapper.eq(\"name\", \"张三\")\n        .or()\n        .eq(\"name\", \"李四\")\n        .set(\"age\", null);  // 调用 set 方法存储要修改的值\nint rows = userMapper.update(wrapper);\n```\n\n#### Lambda 写法\nLambda 写法的 Wrapper 有两种：`LambdaQueryWrapper`与`LambdaUpdateWrapper`。这两者与上面介绍的`QueryWrapper`和`UpdateWrapper`的用法基本是一致的。只不过在表示列名上有所不同，普通的写法使用字符串表示列名，而这边使用 Lambda 表达式表示。\n\n例：把姓名为“张三”或“李四”的用户年龄设置为空\n\n```java\nLambdaUpdateWrapper<User> wrapper = new LambdaUpdateWrapper<>();\nwrapper.eq(User::getName, \"张三\")\n        .or()\n        .eq(User::getName, \"李四\")\n        .set(User::getAge, null);\nint rows = userMapper.update(wrapper);\n```\n\n可以看到用户上基本与`UpdateWrapper`一样，只是表示列名的地方换成 Lambda 表达式了。\n\n### 核心注解\n#### @TableName\n我们在创建 Mapper 时会继承 BaseMapper：\n\n```java\npublic interface UserMapper extends BaseMapper<User> {}\n```\n\n这样里面什么都不需要写就会拥有很多数据库操作，继承`BaseMapper`时需要通过泛型指定该 Mapper 用来操作哪张表。\n\n默认情况下泛型名（User）就是表名，当然是忽略大小写的。如果表名与实体类不同名，我们可以在实体类上使用`@TableName`注解来指定实体类对应的表名。\n\n```java\n@Data\n@TableName(\"t_user\")\npublic class User {  // 将实体类 User 与表 t_user 绑定\n    private Integer id;\n    private String name;\n    private Integer age;\n}\n```\n\n其实在开发中，数据库表一般都使用`t_`开头，而实体类命名一般会忽略这个前缀。那这种情况下每个实体类都需要使用`@TableName`注解来指定表名就有些累赘了，此时我们可以在`application.yaml`文件中配置`mybatis-plus.global-config.db-config.table-prefix`属性来指定全局表前缀：\n\n```yaml\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: t_ # 添加前缀后实体类映射表时会默认带上该前缀\n```\n\n#### @TableId\n我们知道 MyBatis-Plus 提供的诸多 CRUD 方法中有许多都是通过主键操作的，例如`selectById\0`、`updateById\0`等方法。这就产生一些问题：实体类中哪一个属性是主键？该属性对应的表字段是什么？基于这两个问题我们一一做出解答。\n\n1. 默认情况下，`selectById\0`、`updateById\0`等方法都是操作实体类中名字为`id`的属性。如果实体类没有`id`属性当然就会报错。\n2. 实体类与表字段对应的时候默认同名对应，当然我们可以开启驼峰映射。\n\n如果实体类不想定义名为`id`的属性该怎么办？答案是使用`@TableId`注解指定主键。\n\n```java\n@Data\npublic class User {\n    // 将实体类的 uid 属性与表的 id 字段绑定，且将 uid 属性作为主键存在\n    @TableId(\"id\")\n    private Integer uid;\n    private String name;\n    private Integer age;\n}\n```\n\n如果表字段也叫`uid`，那么可以直接使用`@TableId`注解而不需要指定`value`属性值。\n\n除了可以指定主键之外，`@TableId`还有一个`type\0`属性用来指定主键的生成策略。主要有两种策略：\n\n+ `IdType.AUTO\0`当主键是数字类型且使用`auto_increment`修饰时可以指定这种生成策略，即主键`+1`策略。\n+ `IdType.ASSIGN_ID\0`默认值，主键类型可以是数字也可以是字符串。这种算法叫雪花算法，算法会生成一个随机`long`数字并将其作为主键值，生成的值不会重复。\n\n```java\n@Data\npublic class User {\n    // 将User类的 id 生成策略改为自增\n    @TableId(type = IdType.AUTO)\n    private Integer id;\n    private String name;\n    private Integer age;\n}\n```\n\n如果项目中大部分实体类的主键生成策略都是`AUTO`，我们就可以在`application.yaml`里面做全局配置：\n\n```yaml\nmybatis-plus:\n  global-config:\n    db-config:\n      id-type: auto\n```\n\n#### @TableField\n我们在开发中定义实体类的时候，可能会遇到两个问题：\n\n1. 实体类的属性名与数据库表字段名不一致，例如存储班级时数据库使用`class`命名，但在 Java 里面这是关键字不能用来定义变量，我们就需要改名字；\n2. 实体类有些字段值是根据其它字段计算得来，因此数据库并没有对应的字段；\n\n而 MyBatis-Plus 会根据实体类属性名查询字段，因此字段名不对应或数据库不存在该字段的时候会报错。例如实体类有`id, name, age`属性，那么查询的时候会使用`SELECT id, name, age FROM...`语句。\n\n为了解决这个问题，我们可以使用`@TableField`注解。这个注解有两个属性：\n\n+ `value`用来指定属性对应的数据库字段名；\n+ `exist\0`boolean 类型，用来指定该属性是否存在于数据库中；\n\n```java\n@Data\npublic class User {\n    @TableId(\"id\")  // 修改对应字段名\n    private Integer uid;\n    private String name;\n    private Integer age;\n    @TableField(exist = false)  // 不存在的字段将 exist 设为 false\n    private String email;\n}\n```\n\n### 扩展\n#### 逻辑删除\n逻辑删除对应物理删除，物理删除使用`DELETE`语句将数据真的删除，而逻辑删除则在表中新增一个字段表示数据是否被删除。例如新增一个`deleted`字段，使用这个字段值表示记录是否删除。\n\nMyBatis-Plus 可以很好的支持逻辑删除，实现步骤也很简单：\n\n1. 数据库表新增一个表示逻辑删除的字段（如`deleted`）；\n2. 在实体类里面新增一个同名变量（`deleted`）；\n3. 在该字段上使用`@TableLogic\0`注解修饰即可；\n\n默认情况下，MyBatis-Plus 认为`deleted`值为`1`表示该数据已经被删除，否则值为`0`表示数据没被删。我们可以在注解里面修改：\n\n+ `value`属性表示未删除的数字表示，默认为`0`；\n+ `delval`属性表示删除的数字表示，默认为`1`；\n\n```java\n@TableLogic(value = \"0\", delval = \"1\")\nprivate Integer deleted;\n```\n\n如果所有表都需要实现逻辑删除，每个表都需要使用`@TableLogic`注解就很麻烦。所以逻辑删除的也可以全局配置，主要配置三个字段：\n\n```yaml\nglobal-config:\n  db-config:\n    logic-delete-value: 1 # 表示删除的值\n    logic-not-delete-value: 0 # 表示未删除的值\n    logic-delete-field: deleted # 表示删除的字段\n```\n\n#### 乐观锁\n在高并发的情况下，修改同一条记录可能出现数据不一致的问题。一种解决思路是在数据中添加一个表示版本的字段，每次修改数据的时候对比版本：\n\n+ 若版本一致就执行修改，并将版本号`+1`；\n+ 若版本不一致就不做修改；\n\n在 MyBatis-Plus 里面实现这种乐观锁很简单：\n\n1. 数据库添加一个表示版本的字段`version`，数字类型；\n2. 实体类里面添加一个变量用来存储版本，并使用`@Version\0`注解修饰这个变量；\n3. 在启动类里添加乐观锁插件`OptimisticLockerInnerInterceptor\0`；\n\n```java\n// 实体类里定义表示版本的字段并使用 @Version 修饰\n@Version\nprivate Integer version;\n\n// 启动类里添加乐观锁插件\n@Bean\npublic MybatisPlusInterceptor mybatisPlusInterceptor() {\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n    // 乐观锁插件\n    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());\n    return interceptor;\n}\n```\n\n测试的代码如下：\n\n```java\n// 查询同一条记录，获取的版本号是一样的\nUser user1 = userMapper.selectById(4);\nUser user2 = userMapper.selectById(4);\n\n// 两个人都想修改数据\nuser1.setAge(30);\nuser2.setAge(40);\n\n// 版本对比成功，允许修改并将数据库存的版本号 +1\nint rows = userMapper.updateById(user1);\n\n// 版本对比失败，不允许修改\nrows = userMapper.updateById(user2);\n```\n\n#### 防御删库跑路\n正常开发中基本不存在删除或修改全表的操作，因为这样的操作很危险。MyBatis-Plus 给我们提供了一个防止全表删除或更新的插件`BlockAttackInnerInterceptor`，我只需要在启动类里面配置一下就可以了：\n\n```java\n@Bean\npublic MybatisPlusInterceptor mybatisPlusInterceptor() {\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n    // 防止全表删除、更新的插件\n    interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());\n    return interceptor;\n}\n```\n\n只需要引入插件而不需要做其它任何操作就直接可以起作用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'),
       (17, 17, '### 开始\n#### 安装 Node.js\n1. 到[官网](https://nodejs.org/en)下载`Node.js`安装包并完成安装\n    - 安装完成之后到控制台使用`node -v`检查是否成功。\n2. `Windows`系统还需要配置`npm`的全局安装路径：\n    - 以管理员身份运行命令行\n    - 执行命令`npm config set prefix \"E:\\develop\\Nodejs\"`，里面的路径换成`Node.js`的安装路径\n    - 执行命令`npm config get prefix`检查是否设置成功\n3. 设置`npm`的淘宝镜像`npm config set registry [https://registry.npmmirror.com](https://registry.npmmirror.com)`\n\n#### 基于 Vite 创建项目\n在合适的位置打开终端，输入命令：\n\n```java\nnpm create vue@latest\n```\n\n第一次运行可能会提示安装某些包，控制台输入`y`即可。\n\n接下来会出现一些定制选项，根据需求选择对应的选项即可，下面是一些参考：\n\n![](/upload/covers/39992e2846754647a4faf04634ff144f.png)\n\n完成之后我们的项目就创建好了，就可以使用 vscode 打开项目了。打开项目之后使用`sudo npm i`安装必要的依赖。\n\n#### 目录结构\n+ `.vscode`推荐安装 vscode 的插件配置\n+ `node_modules`安装的依赖\n+ `public`静态资源\n+ `src`源代码，我们的工作成果所在地\n+ `.gitignore`git 的忽略文件\n+ `env.d.ts`支持 ts 导入`.txt`等常见文件的配置\n+ `index.html`入口文件\n+ 包管理文件\n    - `package-lock.json`\n    - `package.json`\n+ ts 配置文件\n    - `tsconfig.app.json`\n    - `tsconfig.json`\n    - `tsconfig.node.json`\n+ `vite.config.ts`项目的配置文件\n\n#### 基本文件的解读\n##### index.html\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <link rel=\"icon\" href=\"/favicon.ico\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <script type=\"module\" src=\"/src/main.ts\"></script>\n  </body>\n</html>\n```\n\n界面代码很简洁，但是实际运行起来很精美。这里面比较重要的是：\n\n```html\n<div id=\"app\"></div>\n<script type=\"module\" src=\"/src/main.ts\"></script>\n```\n\n上面的 div 就是界面内容的渲染地，下面的 script 导入了`/src/main.ts`文件。\n\n##### src/main.ts\n```typescript\nimport \'./assets/main.css\'\n\nimport { createApp } from \'vue\'\nimport App from \'./App.vue\'\n\ncreateApp(App).mount(\'#app\')\n```\n\n`import \'./assets/main.css\'`就是导入一个样式表，不太重要。\n\n接下来我们着重理解一下：\n\n```typescript\nimport { createApp } from \'vue\'\nimport App from \'./App.vue\'\n\ncreateApp(App).mount(\'#app\')\n```\n\n我们把整个项目理解成种花，`createApp`表示花盆，`App`是组件表示花的根；那么`createApp(App)`就表示将“根”放到花盆里面，`.mount(\'#app\')`表示将花盆放置到`index.html`的`#app`元素内。在`src/components`目录下放着很多自定义的组件，这些组件可以理解成花的枝枝叶叶。\n\n所以实际上这么写完之后，运行起来会展示`index.html`，页面的`#app`里面会展示`App`这个组件，我们可以在这个组件里面导入更多其它组件使页面变得丰富。\n\n### 核心语法\n#### 新旧 Vue\n##### Vue2 Demo\n首先我们在`/src/components`目录下创建一个组件`Person.vue`：\n\n```vue\n<template>\n    <h2>{{ name }}</h2>\n    <h2>{{ age }}</h2>\n    <button @click=\"changeName\">点击修改姓名</button>\n    <button @click=\"changeAge\">点击修改年龄</button>\n    <button @click=\"showTel\">点击显示电话</button>\n</template>\n\n<script lang=\"ts\">\n    export default {\n        data() {\n            return {  // 数据要定义在 data 函数的返回值里\n                name: \"张三\",\n                age: 18,\n                tel: 18888888888\n            }\n        },\n        methods: {  // 函数定义在 methods 属性里\n            changeName() {\n                // 读取数据域定义的字段，需要加 this.\n                this.name = \"李四\";\n            },\n            changeAge() {\n                // 字段是响应式的，修改变量的值，界面上也会更改\n                this.age += 1;\n            },\n            showTel() {\n                alert(this.tel)\n            }\n        }\n    }\n</script>\n```\n\n一个组件里面可以写三类标签，分别是：\n\n+ `template`用于书写 HTML 框架\n+ `script`用于写交互的内容\n+ `style`用于指定样式\n\n接着我们在`App.vue`里面引用这个组件：\n\n```vue\n<template>\n    <!-- 因为下面注册过这个组件，所以可以直接使用 -->\n    <Person />\n</template>\n\n<script lang=\"ts\">\n    // 导入 Person 组件，import 后面只是起的一个名字，可随意\n    import Person from \"./components/Person.vue\"\n\n    export default {\n        // 将 Person 组件注册到 components 属性里面，才可以使用这个标签\n        components: {Person}\n    }\n</script>\n```\n\n##### Vue3 Demo\n我们将`Person.vue`代码修改如下：\n\n```vue\n<template>\n    <h2>{{ name }}</h2>\n    <h2>{{ age }}</h2>\n    <button @click=\"changeName\">点击修改姓名</button>\n    <button @click=\"changeAge\">点击修改年龄</button>\n    <button @click=\"showTel\">点击显示电话</button>\n</template>\n\n<script lang=\"ts\">\n    export default {\n        setup() {\n            // 定义数据\n            let name = \"张三\";\n            let age = 18;\n            let tel = 18888888888;\n\n            // 定义方法\n            function changeName() {\n                name = \"李四\";\n            }\n\n            function changeAge() {\n                age += 1;\n            }\n\n            function showTel() {\n                alert(tel)\n            }\n\n            return {name, age, changeName, changeAge, showTel}\n        }\n    }\n</script>\n```\n\nVue3 里面并没有把数据与函数分隔，它们都统一定义在`setup`函数里面。\n\n`setup`的返回值是一个对象，用来指定需要暴露出去的变量或函数，此外`setup`弱化了`this`，因此定义的函数访问变量均**不能**使用`this.`。\n\n`App.vue`可以不改，但是如果使用 Vue3 的推荐写法应该：\n\n```vue\n<template>\n    <Person />\n</template>\n\n<script setup lang=\"ts\">\n    // setup 里面导入的内容都会默认交出去\n    import Person from \"./components/Person.vue\"\n</script>\n```\n\n**注意：**像例子中一样直接定义的变量（`let age = 18`）均不是响应式的，即修改变量的值，在界面上并不会改变。\n\n##### Vue2 与 Vue3 混合\n`setup`初始化的时候很早，甚至早于`beforeCreate`。因此`setup`要早于`data`和`methods`加载，于是出现了以下问题：\n\n1. `setup`能否与`data/methods`共存？\n    - 答：能。`setup`是 Vue3 的推荐写法，`data/methods`是 Vue2 的写法，在 Vue3 里面两者均支持，也能同时出现。模板渲染的时候两种方式也都能拿到数据。\n2. `data/methods`里面是否可以引用`setup`里面定义的数据或函数？\n    - 答：可以，因为在计算`data/methods`的时候`setup`已经加载完毕，里面的数据当然可以拿到。但是使用`data/methods`获取数据需要使用`this.`。\n3. `setup`里面能否引用`data/methods`里的数据或函数？\n    - 答：不能，因为计算`setup`的时候，`data/methods`还没有计算，当然取不到内容。\n\n#### setup 语法糖\n我们在 Vue3 里面基本不推荐`data/methods`的写法，都是推荐将变量、函数定义在`setup`里面。但是`setup`函数里面需要将暴露出去的变量函数等通过返回值返回，这个比较麻烦。于是出现了`setup`语法糖，下面两种写法是等价的：\n\n```vue\n<script lang=\"ts\">\n    export default {\n        setup() {\n            // 定义数据\n            let age = 18;\n            // 定义方法\n            function changeAge() {\n                age += 1;\n            }\n            return {age, changeAge}\n        }\n    }\n</script>\n```\n\n```vue\n<script setup lang=\"ts\">\n    // 定义数据\n    let age = 18;\n    // 定义方法\n    function changeAge() {\n        age += 1;\n    }\n</script>\n```\n\n就是在`script`标签里面加一个`setup`就可以了，标签里面的所有内容相当于写在原来的`setup`函数里面且都会暴露出去。\n\n这样书写确实非常方便，但是语法糖里面不能再写`export`了。一般来说这不是什么问题，但在某些情况下我们会需要修改组件的名字，因为默认情况下什么都不做组件会与文件同名。于是有下面的写法：\n\n```vue\n<script lang=\"ts\">\n    export default {\n        name: \"Person_new\"\n    }\n</script>\n\n<script setup lang=\"ts\">\n    let name = \"张三\";\n    // 其它内容\n</script>\n```\n\n我们新开一个`script`标签，export 出去一个 name 用于指定组件的名字。\n\n一般便于在 Chrome 的 Vue 插件里面查看。\n\n这样写还是比较麻烦的，需要写两个`script`标签，而其中一个`script`标签仅仅用于修改组件名称。我们可以通过使用一个插件简化书写：\n\n1. 使用`npm i vite-plugin-vue-setup-extend -D`命令安装插件\n2. 在`vite.comfig.ts`里面配置这个插件：\n    1. 导入插件`import VueSetupExtend from \'vite-plugin-vue-setup-extend\'`\n    2. 在`plugins`里面追加调用`VueSetupExtend()`\n3. 在`script`标签使用`name`属性指定组件名`<script setup lang=\"ts\" name=\"PersonSuper\">`\n\n#### 响应式数据\n上面我们说过在`setup`里面定义的数据都不是响应式的，对它们做修改之后界面上展示的是不变的。接下来我们介绍响应式数据应该怎么定义和操作。\n\n##### 基本数据类型\nVue3 里面将基本数据类型转为响应式需要借助`ref`，看一个例子：\n\n```vue\n<template>\n    <h2>{{ count }}</h2>\n    <button @click=\"addCount\">点击修改数字</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref} from \'vue\'  // 导入 ref\n\n    let count = ref(0)  // 将基本数据类型使用 ref 包裹起来就变成响应式数据了\n    function addCount() {\n        count.value += 1;\n    }\n</script>\n```\n\n实际上`ref`是一个函数，它返回一个`RefImpl`对象，我们传进去的值会存在对象的`value`属性里。因此在 js 代码中我们想要修改这个值，需要使用`xxx.value = yyy`的写法。但是在模板的插值表达式里面不需要额外的调用`.value`，因为表达式会自己调用。\n\n##### 对象类型\n对象类型的数据要是想转为响应式，有两种方式分别是`ref`和`reactive`。这边说的对象，只要不是基本数据类型都是对象类型，例如数组、函数、原生对象等等。\n\n###### reactive\n和`ref`类似，我们只需要将对象使用`reactive`函数包裹起来就可以了。\n\n```vue\n<template>\n    <h2>{{ car.name }}, {{ car.price }}</h2>\n    <button @click=\"addPrice\">点击修改价格</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {reactive} from \'vue\'\n\n    let car = reactive({name: \"奔驰\", price: 100})\n    function addPrice() {\n        car.price += 10\n    }\n</script>\n```\n\n`reactive`函数会返回一个`Proxy`对象，和`ref`不一样的是我们获取对象属性的时候不需要`.value`之类的，还像原来那样获取。包括获取数组元素的时候仍然使用类似于`cars[0]`这样的写法，不需要添加任何多余的部分。\n\n###### ref\n`ref`除了可以创建响应式基本数据，还可以创建响应式对象。\n\n```vue\n<template>\n    <h2 v-for=\"car in cars\" :key=\"car.name\">{{ car.name }}, {{ car.price }}</h2>\n    <button @click=\"addPrice\">点击修改第一辆车价格</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref} from \'vue\'\n\n    let cars = ref([\n        {name: \"奔驰\", price: 100},\n        {name: \"宝马\", price: 50},\n        {name: \"奥迪\", price: 80}\n    ])\n    function addPrice() {\n        cars.value[0].price += 10\n    }\n</script>\n```\n\n如果使用`ref`创建响应式对象，我们在 js 代码里面操作这个对象的时候仍然是需要先`.value`的。当然在插值表达式里面是不需要的，表达式仍然会帮我们自动计算。\n\n事实上`ref`是借助于`reactive`实现响应式对象的，它会先使用`reactive`函数包裹对象生成`Proxy`对象，然后将这个对象赋值给`RefImpl`的`value`属性。\n\n我们这个例子里面简要写了一个循环渲染，使用`v-for`来对一个数组进行循环遍历，注意循环的时候需要给标签加一个`key`属性作为当前标签的唯一标识。一般我们会使用`:key`，这个全称`v-bind:key`，这样写的话后面的值会当做 js 表达式解析，不然的话只会当做普通字符串。\n\n##### ref 踩坑\n假设有一个变量`let count = ref(0)`，我们一般使用`count.value = 9`的写法来修改这个变量。那如果我写出下面的代码会怎么样？\n\n```vue\ncount = 9  // 这种写法 count 会变成普通变量，不是响应式的\n\n// 看上去没有问题，实际上界面数据仍然和原来的 ref 绑定，所以这样写也不是响应式的\ncount = ref(9)  \n```\n\n总结：不论使用`ref`包裹基本数据类型还是对象，修改变量的时候我们都应该修改`.value`而不是变量本身。只要修改的是`.value`，那么不论包裹的类型都是响应式的。\n\n比较麻烦的是每次我们都需要自己写`.value`，我们可以在插件里面配置，让编译器自动追加`.value`，看下图配置：\n\n![](/upload/covers/a1f251a3ec9b4c1f92eb9f4c13b55fa8.png)\n\n##### reactive 踩坑\n和`ref`相似，修改`reactive`包裹的对象时应该修改对象内部的东西，而不是这个对象的引用。\n\n```java\nlet cars = reactive([...])\ncars[1] = {...}  // 合理，修改数组的元素\n\nlet car = reactive({...})\ncar.name = \'...\'  // 合理，修改对象的属性\n\nlet car = reactive({...})\ncar = {...}  // 错误，car 变量引用被修改了\ncar = reactive({...})  // 错误，car 变量引用被修改了\n```\n\n很多时候，我们确实需要修改整个对象。比如某个变量有一个初值，后面服务请求获取到数据再覆盖掉这个值，此时不可能挨个属性赋值，太麻烦，我们可以：\n\n```vue\nlet car = reactive({...})\ncar = Object.assign(car, {...})\n```\n\n`Object.assign`函数可以有任意多参数，它可以把后面所有对象的属性都添加到第一个对象里，如果有同名属性会覆盖，后面对象的同名属性覆盖前面对象的。\n\n##### 使用建议\n基本数据类型响应式：只能使用`ref`；\n\n对象类型响应式：\n\n+ 对象层级较浅，`ref`和`reactive`均可\n+ 对象层级较深，推荐使用`reactive`\n\n#### toRefs/toRef\n##### toRefs\n`toRefs`主要用于解构赋值时，让解构出来的变量也具备响应式。首先如果我们直接解构：\n\n```java\nlet person = reactive({name: \"张三\", age: 19, score: 100})\nlet {name, age, score} = person\n/** 第二行代码就相当于：\n    name = person.name\n    ...\n*/\n```\n\n很显然解构出来的变量只是普通变量，并不是响应式的。想要让解构变量是响应式的可以：\n\n```vue\nimport {reactive, toRefs} from \'vue\'\nlet person = reactive({name: \"张三\", age: 19, score: 100})\nlet {name, age, score} = toRefs(person)\n```\n\n使用`toRefs`将对象包裹起来，这样解构出来的变量直接就是`RefImpl`，并且解构的变量与原来对象的属性是同一的。也就是说，`name`和`person.name`的变化是互通，要变一起变。\n\n##### toRef\n`toRef`功能和`toRefs`类似，不过`toRefs`能将对象所有属性全部解构出来，而`toRef`只能解构一个属性。当然解构出来的变量也原来的对象属性也是同一，因此也是响应式的。\n\n```vue\n<template>\n    <h2>{{ person.name }}</h2>\n    <button @click=\"change\">修改人员信息</button>\n</template>\n\n<script setup lang=\"ts\">\nimport {reactive, toRef} from \'vue\'\n\n    let person = reactive({name: \"张三\"})\n    let name = toRef(person, \"name\")  // 指定要解构的属性\n    function change() {\n        name.value = \"李四\"  // 模板里面会变，因为 name 与 person.name 同一变化\n    }\n</script>\n```\n\n#### 计算属性\n很多时候我们定义的变量不是直接赋值的，而是依据某些其它变量的值计算得来的。看例子：\n\n```vue\n<template>\n    姓：<input v-model=\"firstName\" /> <br>\n    名：<input v-model=\"lastName\" /> <br>\n    全名：{{ fullName }}\n</template>\n\n<script setup lang=\"ts\">\n    import {ref, computed} from \'vue\'\n    let firstName = ref(\"\")\n    let lastName = ref(\"\")\n    let fullName = computed(()=>{  // 传进去一个计算函数\n        return firstName.value + \"-\" + lastName.value\n    })\n</script>\n```\n\n代码不难看出，变量`firstName`与`lastName`分别与两个输入框双向绑定。变量`fullName`是一个计算属性，它的值有姓与名组合而成，它的使用很简单就是把计算的函数传到`computed`里面。这样写，姓与名每次发生变化，都会触发重新计算`fullName`。\n\n`fullName`的类型实际是`ComputedRefImpl`，而`ComputedRefImpl`的`value`属性是只读的，因此无法给`fullName.value`赋值。\n\n如果我想实现给`fullName`传一个值，然后根据值自动修改`firstName`与`lastName`可以：\n\n```vue\n<template>\n    姓：<input v-model=\"firstName\" /> <br>\n    名：<input v-model=\"lastName\" /> <br>\n    全名：{{ fullName }} <br>\n    <button @click=\"changeName\">直接给全名赋值</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref, computed} from \'vue\'\n    let firstName = ref(\"\")\n    let lastName = ref(\"\")\n    let fullName = computed({\n        get() {  // 读取值\n            return firstName.value + \"-\" + lastName.value\n        },\n        set(val) {  // 设置值\n            // 实际上也是改变与它相关的其它变量而不是直接变它自己\n            ([firstName.value, lastName.value] = val.split(\"-\"))\n        }\n    })\n    function changeName() {\n        fullName.value = \"li-si\"\n    }\n</script>\n```\n\n#### watch\n`watch`可以监视数据的变化，Vue3 中的`watch`只能监视下面 4 种数据：\n\n1. `ref`定义的数据；\n2. `reactive`定义的数据；\n3. 函数返回一个值；\n4. 包含上述内容的数组；\n\n分情况的话具体可以分为 5 种情况。\n\n##### ref 定义的基本类型数据\n使用`watch`监视`ref`定义的基本类型数据，看例子：\n\n```vue\n<template>\n  <h2>{{ sum }}</h2>\n  <button @click=\"add\">点我 sum+1</button>\n</template>\n\n<script setup lang=\"ts\">\n  // 导入 watch\n  import {ref, watch} from \'vue\'\n  let sum = ref(0)\n  function add() {\n    sum.value++\n  }\n  // 第一个参数是监视源，注意没有加 .value\n  // 第二个参数是一个回调函数，函数两个参数分别表示新值与旧值\n  watch(sum, (newVal, oldVal)=>{\n    console.log(\'sum 变化了：\', newVal, oldVal)\n  })\n</script>\n```\n\n使用还是比较简单的，那么如果满足一定条件我就想取消监视怎么办？例如当`sum ≥ 10`时停止监视，js 代码可以改为：\n\n```vue\nlet stopWatch = watch(sum, (newVal, oldVal)=>{\n    console.log(\'sum 变化了：\', newVal, oldVal)\n    if (newVal >= 10) stopWatch()\n})\n```\n\n主要用到`watch`函数的返回值，它会返回一个函数，调用这个函数就可以取消监视。\n\n##### ref 定义的对象类型数据\n大体写法和上面的类似，直接看一个例子：\n\n```vue\n<template>\n    <h2>{{ person.name }}</h2>\n    <h2>{{ person.age }}</h2>\n    <button @click=\"changeInfo\">修改信息</button>\n    <button @click=\"changeRef\">修改引用</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref, watch} from \'vue\'\n    let person = ref({name: \"张三\", age: 18})\n\n    function changeInfo() {\n        person.value.age = 20\n        person.value.name = \"李四\"\n    }\n    function changeRef() {\n        person.value = {name: \"王五\", age: 10}\n    }\n\n    watch(person, (newVal, oldVal)=>{\n        console.log(\"person 改变了\", newVal, oldVal)\n    })\n</script>\n```\n\n在这个案例里面点击“修改信息”是不会触发监听的，而“修改引用”是会触发的。因此可以看出我们这样的默认写法，**只会监听**`**ref**`**对象**`**value**`**的修改，而不会监听原对象里面各个属性的修改**。\n\n在大部分情况下，我们需要监听对象内部属性的变化，此时就需要给`watch`函数传进去第三个参数。这第三个参数是一个对象，用来配置`watch`函数的行为，主要可以配置：\n\n+ `deep`表示是否深度监听，设为`true`就可以监听对象的属性变化\n+ `immediate`表示是否立刻触发监听，设为`true`就可以立刻监听这个对象，初次`oldVal`为`undefined`\n\n```vue\nwatch(person, (newVal, oldVal)=>{\n    console.log(\"person 改变了\", newVal, oldVal)\n}, {deep: true, immediate: true})\n```\n\n我们在监听的时候会拿到两个值`newVal`和`oldVal`，分别表示改动后的新值和改动前的旧值。但是这两个值都是返回`ref`的`value`值：\n\n+ 当我们修改这个`value`值的时候，`newVal`和`oldVal`分别表示修改前后的两个对象。\n+ 当我们修改的是对象里面属性的时候（`person.value.name=\"zs\"`），`newVal`和`oldVal`指向的就是同一个对象，因此两者的内容是完全一样的。\n\n大多数时候我们并不会关注旧值是什么，因此一般只写一个参数表示新值：\n\n```vue\nwatch(person, (newVal)=>{\n    // ...\n}, {deep: true, immediate: true})\n```\n\n##### reactive 定义的对象数据\n监听`reactive`定义的对象数据的时候，只能监听对象属性的改变。\n\n```vue\n<template>\n    <h2>{{ person.name }}</h2>\n    <h2>{{ person.age }}</h2>\n    <button @click=\"changeInfo\">修改信息</button>\n    <button @click=\"changeRef\">修改引用</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {reactive, watch} from \'vue\'\n    let person = reactive({name: \"张三\", age: 18})\n\n    function changeInfo() {  // 直接修改属性\n        person.age = 20\n        person.name = \"李四\"\n    }\n    function changeRef() {\n        // 通过 Object.assign 批量添加/修改属性\n        person = Object.assign(person, {name: \"王五\", age: 10})\n    }\n\n    watch(person, (newVal, oldVal)=>{\n        console.log(\"person 改变了\", newVal, oldVal)\n    }, {immediate: true})\n</script>\n```\n\n例子中两种修改方式都没有改变变量`person`的引用，都是在修改`person`指向对象的内容。监听`reactive`定义的对象默认是开启深度监视的（监听属性变化），且深度监视是关不掉的。即使你在配置里面传入`deep: false`也是无效的。因为不涉及修改对象的引用，所以`newVal`和`oldVal`也是同一个对象。不论使用`ref`还是`reactive`，我们都不能直接给变量赋值：\n\n```java\nlet person = ref({...})\nlet person = reactive({...})\n\n// 这种写法错误，第一这样 person 不是响应式，第二监听不了\nperson = {...}\n```\n\n##### 监视属性\n上面都是监视整个对象，如果我们想要监视的是响应式对象里面（`ref`和`reactive`）的某个属性怎么做？这个需要区分该属性是基本类型还是对象类型：\n\n###### 基本类型\n```vue\n<template>\n  <h2>{{ person.name }}</h2>\n  <button @click=\"changeName\">修改姓名</button>\n</template>\n\n<script setup lang=\"ts\">\n  import {reactive, watch} from \'vue\'\n  let person = reactive({name: \"张三\", cars: {c1: \"奔驰\", c2: \"宝马\"}})\n\n  function changeName() {\n    person.name = \"李四\"\n  }\n\n  watch(()=>person.name, (newVal)=>{\n    console.log(\"姓名发生了变化：\", newVal)\n  })\n</script>\n```\n\n主要看监视器部分，我们第一个参数也就是监视源并没有直接写`person.name`，因为`person.name`是基本数据类型，不能被监视。能监视的类型里面有一种是返回一个值的函数，因此我们将这个属性包装成一个值（简写成箭头函数）。\n\n###### 对象\n上面使用`reactive`举例子，现在使用`ref`举例子：\n\n```vue\n<template>\n  <h2>{{ person.name }}</h2>\n  <h2>{{ person.cars.c1 }}、{{ person.cars.c2 }}</h2>\n  <button @click=\"changeCar1\">修改第一台车</button>\n  <button @click=\"changeCars\">修改车列表</button>\n</template>\n\n<script setup lang=\"ts\">\n  import {ref, watch} from \'vue\'\n  let person = ref({name: \"张三\", cars: {c1: \"奔驰\", c2: \"宝马\"}})\n  function changeCar1() {\n    person.value.cars.c1 = \"奥迪\"\n  }\n  function changeCars() {\n    person.value.cars = {c1: \"雅迪\", c2: \"爱玛\"}\n  }\n\n  watch(person.value.cars, (newVal)=>{\n    console.log(\"姓名发生了变化：\", newVal, person.value.cars)\n  })\n</script>\n```\n\n监视的时候监视源直接写`person.value.cars`，这样是可以的，因为一个响应式对象里面某个属性如果也是一个对象，那么这个属性也是响应式的，简单说`person.value.cars`也是响应式的。\n\n和监视一个响应式对象一样，这样写有一个问题，我们只能监视对象内部属性的修改，若是直接改变这个对象是无法监视的，也就是说`person.value.cars = {...}`是监视不到的。\n\n如果想要监视对象本身，可以改为函数式监视：\n\n```vue\nwatch(()=>person.value.cars, (newVal)=>{\n  console.log(\"姓名发生了变化：\", newVal, person.value.cars)\n})\n```\n\n改为函数式监视之后有监视不到内部属性的变化了，此时可以再开启深度监视：\n\n```vue\nwatch(()=>person.value.cars, (newVal)=>{\n  console.log(\"姓名发生了变化：\", newVal, person.value.cars)\n}, {deep: true})\n```\n\n所以不论监视的属性是基本数据类型还是对象，都建议使用函数式监视。\n\n##### 监视数组\n数组就比较简单了，把能监视的对象放到一个数组里面统一监视。依然使用上面的例子，假设我们现在想要监视姓名和第一辆车应该怎么做？\n\n```vue\n<template>\n  <h2>{{ person.name }}</h2>\n  <h2>{{ person.cars.c1 }}、{{ person.cars.c2 }}</h2>\n  <button @click=\"changeName\">修改姓名</button>\n  <button @click=\"changeCar1\">修改第一台车</button>\n  <button @click=\"changeCars\">修改车列表</button>\n</template>\n\n<script setup lang=\"ts\">\n  import {reactive, watch} from \'vue\'\n  let person = reactive({name: \"张三\", cars: {c1: \"奔驰\", c2: \"宝马\"}})\n  function changeName() {\n    person.name = \"李四\"\n  }\n  function changeCar1() {\n    person.cars.c1 = \"奥迪\"\n  }\n  function changeCars() {\n    person.cars = {c1: \"雅迪\", c2: \"爱玛\"}\n  }\n\n  watch([()=>person.name, ()=>person.cars.c1], (newVal, oldVal)=>{\n    console.log(\"发生了变化：\", newVal, oldVal)\n  })\n</script>\n```\n\n数组元素必须是可监听对象，因此对于基本数据类型还是使用函数式监听。例子里面三个函数都能触发监听，尤其是第三个函数直接修改`cars`也能被监听`c1`的监听器捕获到。\n\n#### watchEffect\n`watchEffect`也是监视，不过与`watch`不同。`watch`监视的时候需要传递监视源，而`watchEffect`不需要，它会根据回调函数内部使用的变量自动推断有哪些监视源。一般用于“遇到特定条件就做特定的事情”这样的场景之中。\n\n```vue\n<template>\n    <h2>{{ sum }}</h2>\n    <button @click=\"add\">点我 sum+1</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref, watchEffect} from \'vue\'\n    let sum = ref(0)\n    function add() {\n        ++sum.value\n    }\n    watchEffect(()=>{\n        if (sum.value > 10) {\n            console.log(\"sum 超标了：\", sum.value)\n        }\n    })\n</script>\n```\n\n这个例子会在变量`sum > 10`的时候进行输出打印，我们使用`watchEffect`简化了写法，不需要传递监视源。对于这个例子并没有太高的优越性，如果需要监视的变量有很多，那么不传监视源的优越性就体现出来了。\n\n#### 标签 ref\n##### 获取 DOM\n开发中还有一个很常用的功能就是获取某个 DOM 节点，一种常见的方式是使用 id 获取。但这有一个问题，Vue 组件里面可以包含若干个其它组件，如果两个组件中包含一样的 id，那么你获取的时候就会出现问题。Vue 给出的解决方案是对标签使用`ref`属性，然后在 js 里面定义一个同名变量就可以：\n\n```vue\n<template>\n    <h2 ref=\"title2\">我是 h2</h2>\n    <button @click=\"show\">点我输出h2对象</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref} from \'vue\'\n    // 这边定义的变量就是上面的 h2 DOM 节点\n    let title2 = ref()\n    function show() {\n        console.log(title2.value)\n    }\n</script>\n```\n\n##### 样式闭合\n视频还看到了一个小知识点，这边就提一下。正常在组件`style`标签里面写样式，多个组件组合在一起的时候会出现样式污染，因此我们把样式写在`<style scoped></style>`标签里。加上`scoped`之后样式就会限制本组件内部，因此我们以后写样式几乎必加这个`scoped`。\n\n##### 组件标签使用 ref\n组件在页面里面也是标签的形式，如果我们给组价加上`ref`属性会怎么样？\n\n```vue\n<template>\n    <Person ref=\"people\" />\n    <button @click=\"showPeople\">点我展示组件</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref} from \"vue\"\n    import Person from \"./components/Person.vue\"\n\n    let people = ref()\n    function showPeople() {\n        console.log(people.value)\n    }\n</script>\n```\n\n我们这边定义的`people`就是`Person`组件对象，既然是组件对象，那么`Person`组件里面定义的变量或函数能访问到吗？\n\n默认情况下父组件是无法访问子组件变量或函数的，想要访问需要在子组件里面将对应的变量或函数暴露出来。我们看`Person`组件：\n\n```vue\n<script setup lang=\"ts\">\n    import {ref, defineExpose} from \'vue\'\n    let title2 = ref()\n    function show() {\n        console.log(title2.value)\n    }\n    defineExpose({title2, show})\n</script>\n```\n\n这边使用`defineExpose`将能被父组件调用的变量或函数暴露出去，这样我们就可以在父组件使用：\n\n```vue\nlet people = ref()\nfunction showPeople() {\n    console.log(people.value)\n    console.log(people.value.title2)\n    people.value.show()\n}\n```\n\n这边的`people`与子组件的`ref`对应，我们拿到子组件引用之后，可以访问子组件暴露出来的变量或函数。\n\n#### 接口\n有时候我们想给一个对象制定规范，比如里面有哪些属性，这些属性分别是什么类型，如果不满足这些规范编译器会给出提示。这时候就需要使用 TS 里面的接口了，一般情况下我们会按照下列方式创建接口：\n\n1. 在`src`目录下创建目录`types`\n2. 在`types`目录下创建一个 TS 文件，为方便一般起名叫`index.ts`。\n    - 起名叫`index.ts`，别人导入的时候直接导入`@/types`\n    - 起其它名字例如`other.ts`，导入时需要`@/types/other`\n    - 在 Vue 里面`@`表示`src`\n3. 在 TS 文件里面编写接口，我们以`PersonInter`举例：\n\n```java\n// export 之后别人才能 import，定义接口关键字是 interface\nexport interface PersonInter {\n    id: string,  // 属性名: 值类型\n    name: string,\n    age: number,\n    score?: number  // ?: 表示这个属性可有可无\n}\n```\n\n接口创建好之后，别人想要使用这个规范，可以：\n\n```vue\n<script setup lang=\"ts\">\n    // 导入的时候需要在接口前面写 type 关键字\n    import {type PersonInter} from \'@/types\'\n\n    // 变量后面写上冒号，再跟上接口约束\n    let person: PersonInter = {id: \"abc\", name: \"张三\", age: 19}\n</script>\n```\n\n我们现在会定义满足接口约束的变量，如果我想定义一个满足接口约束的数组应该怎么做？\n\n```vue\nlet person: Array<PersonInter> = [{id: \"abc\", name: \"张三\", age: 19}]\n```\n\n实际上就是泛型，一般我们会将这个数组类型自定义一个名称，可以简化书写：\n\n```java\n// 在 TS 文件中\nexport type PersonList = Array<PersonInter>\n\n// 使用的时候直接导入就可以使用了\nimport {type PersonList} from \'@/types\'\nlet person: PersonList = [{id: \"abc\", name: \"张三\", age: 19}]\n```\n\n如果我想把满足接口定义的数据改成响应式数据，可以这样：\n\n```java\nlet person = ref<PersonInter>({\n    id: \'1001\',\n    name: \'张三\',\n    age: 18\n})\n```\n\n```java\nlet person = reactive<PersonInter>({\n    id: \'1001\',\n    name: \'张三\',\n    age: 18\n})\n```\n\n#### props\n父组件给子组件传递数据是很常见的操作，在 Vue 里分两步：父组件传，子组件收。\n\n##### 父组件传数据\n父组件给子组件数据很简单，在子组件的标签里添加上属性就可以了：\n\n```java\n<Person info=\"消息\" :persons=\"persons\" />\n\n// persons 是定义在父组件里的数据\nlet persons = [\n    {id: \"1001\", name: \"张三\", age: 18},\n    {id: \"1002\", name: \"李四\", age: 19},\n    {id: \"1003\", name: \"王五\", age: 20}\n]\n```\n\n我们这边给子组件传递了一个字符串`info`和一个人员数组`persons`。\n\n##### 子组件收数据\n```vue\n<template>\n  <p>{{ info }}</p>\n  <p>\n    <div v-for=\"(p, i) in persons\" :key=\"i\">{{ p }}</div>\n  </p>\n</template>\n\n<script setup lang=\"ts\">\n  import {defineProps} from \'vue\'\n\n  defineProps([\'info\', \'persons\'])\n\n  info = \"哈哈\"  // 错误！接受的数据只能作用于模板里\n</script>\n```\n\n子组件接受数据使用`defineProps`，它需要一个数组表示要接受的数据名称，名称要和父组件给的一致。**注意，数据接收下来之后可以在模板里面使用，但是 js 里面是不能使用的。**\n\n想要在 js 里面使用传过来的变量，我们可以使用`defineProps`的返回值：\n\n```vue\nlet data = defineProps([\'info\', \'persons\'])\nconsole.log(data.info, data.persons)\n```\n\n`defineProps`的返回值是一个对象，子组件接收的数据都在这个对象里。\n\n如果我们想在子组件对父组件传过来的数据做类型限制，可以这样用：\n\n```java\n// 给 defineProps 函数加泛型，里面传入各个数据的类型约束\nlet data = defineProps<{persons: PersonList}>()\n```\n\n再进一步，对于某个数据父组件可传可不传，如果不传子组件能够获取一个默认值：\n\n```java\nlet data = withDefaults(defineProps<{persons?: PersonList}>(), {\n    persons: ()=> [{id: \"001\", name: \"工具人\", age: 10}]\n})\n```\n\n1. 首先通过`persons?: PersonList`使`persons`变为可传可不传\n2. 是`withDefaults`将整个`defineProps`调用作为第一个参数，第二个参数是一个对象用来配置默认值，**对象里面的属性值必须写成函数的形式**。\n\n**注意：默认值写法只能写在有 TS 限制类型的**`**defineProps**`**上。**\n\n一个小知识点，所有`define`开头的函数（`defineProps`、`defineExpose`等）其实都是默认导入的，我们可以手动不导入。\n\n#### 生命周期\n##### Vue2 生命周期\nVue2 有 4 个生命阶段，每个阶段有两个钩子函数，共 8 个钩子函数。\n\n| **状态** | **周期** |\n| :---: | :---: |\n| `beforeCreate` | 创建前 |\n| `created` | 创建后 |\n| `beforeMount` | 挂载前 |\n| `mounted` | 挂载完成，一般在里面发送数据请求 |\n| `beforeUpdate` | 更新前 |\n| `updated` | 更新后 |\n| `beforeDestroy` | 销毁前 |\n| `destroyed` | 销毁后 |\n\n\n##### Vue3 生命周期\nVue3 的生命周期和 Vue2 有些不同，我们直接看代码：\n\n```vue\n<script setup lang=\"ts\">\n  import {onBeforeMount, onMounted, onBeforeUpdate, \n          onUpdated, onBeforeUnmount, onUnmounted} from \'vue\'\n\n  console.log(\"创建\")\n\n  onBeforeMount(()=>{\n    console.log(\"挂载前\")\n  })\n  onMounted(()=>{\n    console.log(\"挂载完成\")\n  })\n  onBeforeUpdate(()=>{\n    console.log(\"更新前\")\n  })\n  onUpdated(()=>{\n    console.log(\"更新完成\")\n  })\n  onBeforeUnmount(()=>{\n    console.log(\"卸载前\")\n  })\n  onUnmounted(()=>{\n    console.log(\"写在完成\")\n  })\n</script>\n```\n\n1. Vue3 可以直接在`setup`里面做创建时要做的操作\n2. 其它所有钩子函数也都换了名字，但套路是一样的\n3. Vue3 没有销毁的钩子，取而代之的是卸载的钩子函数\n4. 调用某个钩子时需要传进去一个回调函数，在回调函数里面写要做的事情\n\n#### 自定义 Hooks\n我们在组件里面总会定义变量与操作它的函数、计算属性、监视器等，当代码多的时候这些内容混杂在一起就很混乱。于是我们可以利用自定义 Hooks 将同一个逻辑抽出来，看例子：\n\n```vue\n<template>\n    <h2>{{ sum }}</h2>\n    <button @click=\"add\">点我sum+1</button>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref, watch} from \'vue\'\n    let sum = ref(0)\n    function add() {\n        sum.value++\n    }\n    watch(sum, (newVal)=>{\n        console.log(newVal)\n    })\n</script>\n```\n\n这个例子很简单，因为整个组件只有一个逻辑，就是操作变量`sum`。为了演示，我们打算将所有关于`sum`的逻辑抽出来，操作步骤：\n\n1. 在`src`下创建目录`hooks`\n2. 在`hooks`目录下新建文件`useSum.ts`，名字需以`use`开头\n3. 然后将所有相关的逻辑写到这个文件中\n\n```vue\nimport {ref, watch} from \'vue\'\n\nexport default function() {\n    let sum = ref(0)\n    function add() {\n        sum.value++\n    }\n    watch(sum, (newVal)=>{\n        console.log(newVal)\n    })\n    return {sum, add}\n}\n```\n\n整个逻辑部分要导出为一个函数，函数的返回值是所有需要导出的变量、函数、计算属性等。\n\n接下来我们在组件中使用这个 hook：\n\n```vue\n<template>\n    <h2>{{ sum }}</h2>\n    <button @click=\"add\">点我sum+1</button>\n</template>\n\n<script setup lang=\"ts\">\n    import useSum from \'@/hooks/useSum\'\n\n    let {sum, add} = useSum()\n</script>\n```\n\n这样就实现了逻辑的抽离，当我们业务代码非常臃肿的时候这么做是非常友好的。而且在 hook 里面还可以写生命周期钩子函数，和我们直接在组件里面使用没有区别。'),
       (18, 18, '### 路由\n#### 安装\n首先我们需要下载安装路由模块，命令是：`npm i vue-router`\n\n#### 创建路由器\n接下来我们需要自定义一个路由器，在路由器里面指定访问路径与展示组件的联系。我们先在`src`下创建目录`router`，为导入方便直接在`router`里面创建`index.ts`，最后我们就在`index.ts`里面创建路由器并导出：\n\n```typescript\nimport {createRouter, createWebHistory} from \'vue-router\'\nimport Home from \'@/components/Home.vue\'\nimport News from \'@/components/News.vue\'\nimport About from \'@/components/About.vue\'\n\n// 使用 createRouter 函数创建路由器\nconst router = createRouter({\n  history: createWebHistory(),  // 指定路由工作模式\n  routes: [  // 数组中每个对象表示路由配置\n    {\n      path: \'/home\',\n      component: Home\n    },\n    {\n      path: \'/news\',\n      component: News\n    },\n    {\n      path: \'/about\',\n      component: About\n    }\n  ]\n})\n\n// 最后要导出这个路由器，不然别人拿不到\nexport default router\n```\n\n#### 应用路由器\n创建好路由器之后，我们需要在`main.ts`里创建 APP 时使用路由器：\n\n```typescript\nimport { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport router from \'@/router\'\n\nconst app = createApp(App)\napp.use(router)  // 使用我们定义的路由器\napp.mount(\"#app\");\n```\n\n#### 使用\n路由器被我配置到应用中之后，我们还需要指定一个`RouterView`，这个组件表示根据路径得到的组件显示在哪，可以理解成一个窗口。而且链接跳转也不能直接使用`<a>`标签，要使用 Vue 提供的`RouterLink`组件。\n\n```vue\n<template>\n    <div>路由功能测试</div>\n    <div>\n        <!-- 导航区，需要使用 RouterLink 组件进行页面跳转 -->\n        <RouterLink to=\"/home\" active-class=\"linkActive\">首页</RouterLink>\n        <RouterLink to=\"/news\" active-class=\"linkActive\">新闻</RouterLink>\n        <!-- to 里面还可以传入一个对象，对象的 path 属性作为请求路径 -->\n        <RouterLink :to=\"{path: \'/about\'}\" active-class=\"linkActive\">关于</RouterLink>\n    </div>\n    <div>\n        <!-- RouterView 是组件展示窗口 -->\n        <RouterView></RouterView>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import {RouterView, RouterLink} from \'vue-router\'\n</script>\n```\n\n`RouterLink`有`active-class`属性，里面传一个 CSS 类进去，表示链接被激活的样式。\n\n#### 注意点\n我们将自定义的组件人为区分成一般组件和路由组件，那如何区分这两种组件？举个例子，假设我们自定义了`Demo.vue`，如果我们在某个地方这么使用`<Demo/>`它，那么他就是一般组件，否则就是路由组价。因为路由组件是根据请求路径自动展示的，不是我们手动写标签展示的。\n\n之所以区分这个，是应用中一般组件放在`src/components`目录下，路由组件放在`src/pages`或`src/views`目录下。**通过路由切换组件的时候，原来的组件会卸载掉。**\n\n#### 路由器的工作模式\n1. `history`模式\n    - 优点：URL 更加美观，不带有`#`，更接近传统网站的 URL\n    - 缺点：后期项目上线需要服务端配合处理路径问题\n    - 配置：在路由器里面使用`history: createWebHistory()`\n    - 应用场景：网站直接面对大众时一般采用这种策略\n2. `hash`模式\n    - 优点：兼容性好，不需要服务端配合处理\n    - 缺点：URL 带有`#`不美观且 SEO 优化差\n    - 配置：在路由器里面使用`history: createWebHashHistory()`\n    - 应用场景：一般的后台管理系统都是采用这种策略\n\n#### 路由的几种方式\n我们在`RouterLink`的`to`属性里面指定路径的时候有三种写法：\n\n1. 直接写字符串，例如`<RouterLink to=\"/home\">xxx</RouterLink>`\n2. 使用对象指定`path`，例如`<RouterLink :to=\"{path: \'/home\'}\">xxx</RouterLink>`\n3. 使用对象指定`name`，例如`<RouterLink :to=\"{name: \'home\'}\">xxx</RouterLink>`，这种写法需要在路由器里面给规则配置名称，如下：\n\n```json\n{\n  name: \'about\',\n  path: \'/about\',\n  component: About\n}\n```\n\n#### 路由嵌套\n一个组件里面有路由显示的界面，路由出来的组件里面仍然有路由，这叫做路由嵌套。下图描述了一种路由嵌套的应用场景：\n\n![](/upload/covers/f942589a72c1430783989c435917051a.png)\n\n新闻界面的代码如下：\n\n```vue\n<template>\n  <div class=\"left\">\n    <ul>\n      <li v-for=\"news in newsList\" :key=\"news.id\">\n        <!-- 左侧导航栏，链接是 /news 的子链接 -->\n        <RouterLink to=\"/news/detail\">{{ news.title }}</RouterLink>\n      </li>\n    </ul>\n  </div>\n  <div class=\"right\">\n    <!-- 内容展示区 -->\n    <RouterView />\n  </div>\n</template>\n```\n\n配置路由器的时候在新闻路由里面添加`children`属性：\n\n```json\n{\n  path: \'/news\',\n  component: News,\n  children: [\n    {\n      path: \'detail\',\n      component: Detail\n    }\n  ]\n}\n```\n\n仔细观察可以发现，子级路由的`path`属性不是`/`开头，而是直接写路径。因为如果你加了`/`开头这就表示根下的`detail`。 \n\n#### 路由参数\n我们使用路由跳转的时候可以携带参数，参数分为`query`和`params`。\n\n##### query 参数\n传递参数有两种方式，主要修改`RouterLink`的`to`属性，看代码：\n\n```vue\n<template>\n    <!-- 方式一：直接在路径后面拼接字符串 -->\n    <RouterLink to=\"/news/detail?id=abc\">{{ news.title }}</RouterLink>\n    \n    <!-- 方式二：使用对象，对象里用 query 属性携带参数 -->\n    <RouterLink :to=\"{\n        path: \'/news/detail\',\n        query: {\n            id: \'abc\'\n        }\n    }\">\n        {{ news.title }}\n    </RouterLink>\n</template>\n```\n\n不论使用哪种方式，最终这些参数都会通过路径携带过去。\n\n路由到的组件想要获取传过来的`query`参数可以：\n\n```vue\n<script setup lang=\"ts\">\n    import { useRoute } from \'vue-router\'\n\n    const route = useRoute()\n    // 所有的 query 参数都可以在 route.query 里面找到\n    console.log(route.query.id)\n</script>\n```\n\n##### params 参数\n`params`参数的形式是`/path/p1/p2`，这边`/path`是请求路径，`p1`和`p2`是两个参数。这个参数看起来和路径一样，是如何区分的呢？首先我们需要现在路由器里面配置：\n\n```json\n{\n  path: \'/news\',\n  component: News,\n  children: [\n    {\n      name: \'detail\',\n      path: \'detail/:id/:name?\',\n      component: Detail\n    }\n  ]\n}\n```\n\n我们这边的`path`指定为`detail/:id/:name`，这就表示在路径`detail`后面会有两个参数，这两个参数分别叫做`id`与`name`。\n\n`name`参数使用的是`:name?`表示这个参数可传可不传。\n\n我们在`RouterLink`里面指定参数的时候也有两种方式：\n\n方式一很简单，就是在路径后面拼接参数就可以了，这些参数和路由里面定义的对应：\n\n```vue\n<RouterLink to=\"/news/detail/abc/张三\">{{ news.title }}</RouterLink>\n```\n\n```vue\n<RouterLink :to=\"{\n  name: \'detail\',\n  params: {\n  id: \'abc\',\n  name: \'张三\'\n  }\n}\">\n  {{ news.title }}\n</RouterLink>\n```\n\n这是方式二，我们仍然使用对象的方式传参。不过这次将参数写进`params`属性里面。\n\n注意：这里有一个坑，`params`参数使用对象携带的话，不能通过`path`配置路由路径，只能通过`name`指定。\n\n数据传过去了，组件接收的时候写法和`query`基本一致，不过访问的是`params`属性：\n\n```vue\n<script setup lang=\"ts\">\n  import { useRoute } from \'vue-router\'\n\n  const route = useRoute()\n  // 所有的 params 参数都可以在 route.params 里面找到\n  console.log(route.params.id)\n</script>\n```\n\n#### props 配置\n我们现在可以接收参数，但在组件内访问变量的时候还是很麻烦。需要写`route.query.`或`route.params.`前缀，我想直接访问传过来的参数行不行？行，下面介绍几种写法。\n\n##### 配置 props 属性\n我们在路由器配置界面将子组件的`props`属性配置为`true`，这样会将参数作为属性传给组件。\n\n路由器配置：\n\n```json\n{\n    path: \'/news\',\n    component: News,\n    children: [\n        {\n          name: \'detail\',\n          path: \'detail/:id/:name\',\n          component: Detail,\n          props: true\n        }\n    ]\n}\n```\n\n`props: true`是配置在子组件上的。\n\n传参还是使用一样的传法：\n\n```vue\n<RouterLink \n  to=\"/news/detail/abc/张三\">\n  {{ news.title }}\n</RouterLink>\n```\n\n组件内接收参数时：\n\n```vue\n<template>\n  <div>{{ id }}</div>\n  <div>{{ name }}</div>\n</template>\n\n<script setup lang=\"ts\">\n  defineProps([\'id\', \'name\'])\n</script>\n```\n\n实际上如果将`props`设为`true`，路由渲染的时候相当于渲染`<Detail id=\"abc\" name=\"张三\" />`，那么在组件内通过`defineProps`获取属性也就不奇怪了。\n\n**注意：这种方式只能配合**`**params**`**传参使用，**`**query**`**传参是不能使用的。**\n\n##### 自定义 props\n第一种很好用，但只能配合`params`传参的方式。如果我想使用`query`传参怎么办？此时我们可以自定义 props，首先在路由器里面配置：\n\n```json\n{\n  path: \'/news\',\n  component: News,\n  children: [\n    {\n      name: \'detail\',\n      path: \'detail\',\n      component: Detail,\n      props(route) {\n        return route.query\n      }\n    }\n  ]\n}\n```\n\n我们这边定义了`props`函数，这个函数有一个参数`route`，这个`route`就是我们之前获取数据时使用的`useRoute()`函数的返回值。\n\n`props()`函数的返回值将会被加到组件的`props`里面，例如我们这边直接将`route.query`返回出去，这样所有的参数都会被添加到`props`里。\n\n组件访问数据的时候还是使用`defineProps([\'id\', \'name\'])`\n\n##### 固定 props\n第三种方法能将固定的数据添加到组件的`props`里面，直接看路由器的配置：\n\n```json\n{\n    path: \'/news\',\n    component: News,\n    children: [\n        {\n            name: \'detail\',\n            path: \'detail\',\n            component: Detail,\n            props: {\n                id: \'abc\',\n                name: \'王五\'\n            }\n        }\n    ]\n}\n```\n\n#### replace 属性\n正常浏览器的历史记录是`push`模式，即浏览器维护一个栈，每次访问新页面就将这个网址入栈，当前访问的永远在栈顶。初次之外，还有`replace`模式，这个模式下每次访问新页面都会将新网址替换掉栈顶的网址（而不是入栈），这样做你前一次访问的页面就无法通过回退访问。\n\n想要开启`replace`模式，只需要在`RouterLink`里面定义`replace`属性：\n\n```vue\n<RouterLink replace to=\"/home\" active-class=\"linkActive\">首页</RouterLink>\n```\n\n#### 编程式路由导航\n目前我们路由导航都是通过点击`RouterLink`实现的跳转，如果我想在代码里实现跳转应该怎么做：\n\n```vue\n<script setup lang=\"ts\">\n    import { useRouter } from \'vue-router\'\n\n    const router = useRouter()\n    router.push(\'/home\')\n</script>\n```\n\n`useRouter()`函数的返回值就是路由器对象，调用路由器的`push`方法就可以实现跳转。\n\n除此之外，实际上`push`函数的参数和`RouterLink`组件的`to`属性一样，可以传字符串也可以传一个对象。\n\n```vue\n<script setup lang=\"ts\">\n    import { useRouter } from \'vue-router\'\n\n    const router = useRouter()\n    router.push({\n        path: \'/news/detail\',\n        query: {\n            id: \'abc\',\n            name: \'张三\'\n        }\n    })\n</script>\n```\n\n所以传参或者配置`props`都是一样的，子组件解析的方式也是不需要变化的。\n\n和上一节呼应，`push`是有记录的跳转，自然还有`replace`方法表示无记录跳转。\n\n#### 重定向\n重定向是使用比较多的功能，例如我们访问一个页面的时候如果没有登录会重定向到登录界面。我们只需要在路由器配置页面添加一个配置项：\n\n```json\n{\n  path: \'/\',\n  redirect: \'/home\'\n}\n```\n\n配置好之后，访问根路径会自动重定向到`/home`页面。\n\n### pinia 集成管理\n`pinia`在 Vue 中主要充当状态管理的角色，所谓状态管理简单说就是存储数据，存储在`pinia`中的数据允许我们在各个组件使用。例如用户登录成功以后我们需要将用户的相关信息保存起来，其它的页面也有可能需要使用用户的信息，这就是一个典型的跨组件访问数据的案例。\n\n#### 安装并集成\n直接使用命令`npm i pinia`安装`pinia`；\n\n接着我们在`main.ts`里面创建`pinia`对象并挂载到 Vue 中：\n\n```vue\nimport { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport { createPinia } from \'pinia\'\n\nconst app = createApp(App)\nconst pinia = createPinia()  // 创建 pinia 对象\napp.use(pinia)  // 安装到 app 中\napp.mount(\"#app\");\n```\n\n#### 存储并读取数据\n##### 存储数据\n根据规范我们会在`src`目录下创建`store`目录用来存储相关的 TS 文件，TS 文件的命名要见名知义，例如存储用户信息的我们可以使用`user.ts`。`user.ts`样例代码如下：\n\n```typescript\nimport {defineStore} from \'pinia\'\n\n// 使用 defineStore 定义一个 store 并 export 出去\nexport const useUserStore = defineStore(\'user\', {\n    state() {\n        return {\n            id: \'1001\',\n            name: \'张三\',\n            age: 18\n        }\n    }\n})\n```\n\n`defineStore`的第一个参数是一个字符串，它是`store`的唯一标识；第二个参数是一个配置项，存储的数据需要写在`state`函数的返回值里。\n\n##### 读取数据\n假设我想在`User.vue`组件里想要访问用户的信息，组件内部可以：\n\n```vue\n<template>\n    <div class=\"user\">\n        <p>ID：{{ userStore.id }}</p>\n        <p>姓名：{{ userStore.name }}</p>\n        <p>年龄：{{ userStore.age }}</p>\n    </div>    \n</template>\n\n<script setup lang=\"ts\">\n    import { useUserStore } from \'@/store/user\'\n\n    // useUserStore() 函数的返回值是一个 store 对象\n    // 存储的数据都会作为这个对象的属性存在\n    let userStore = useUserStore()\n</script>\n```\n\n#### 修改数据\n##### 方式一\n直接操作`store`对象，这是最简单的方式：\n\n```typescript\n// 直接操作 store 对象的 name 属性修改\nuserStore.name = \'李四\'\n```\n\n##### 方式二\n当要操作的属性比较多的时候，按照方式一的写法代码比较臃肿。`pinia`给我们提供`patch`的方式批量修改数据：\n\n```typescript\nuserStore.$patch({\n    id: \'1002\',\n    name: \'王五\',\n    age: 20\n})\n```\n\n`$patch`函数传进去一个对象，对象里面就是要修改的数据。但是请注意，传的数据必须是定义在`store`里面，例如你传一个`score`会报错。\n\n##### 方式三\n`pinia`还给我们提供`actions`用来操作存储的数据，首先我们在`store`里面配置：\n\n```typescript\nimport {defineStore} from \'pinia\'\n\nexport const useUserStore = defineStore(\'user\', {\n    actions: {  // actions 里面定义若干函数操作数据\n        addAge() {\n            if (this.age < 20) {  // 访问数据的时候需要 this.\n                ++this.age\n            }\n        }\n    },\n    state() {\n        return {\n            id: \'1001\',\n            name: \'张三\',\n            age: 18\n        }\n    }\n})\n```\n\n我们定义好`actions`之后就可以直接通过`store`对象调用这些函数：\n\n```typescript\nimport { useUserStore } from \'@/store/user\'\nlet userStore = useUserStore()  // 创建 store 对象\nuserStore.addAge()  // 调用 addAge 函数\n```\n\n如果只是为了修改属性而使用`actions`就比较麻烦，一般`actions`的应用场景是修改属性的逻辑比较复杂的时候，例如我们这边修改年龄的逻辑里面有一个判断。\n\n#### storeToRefs\n目前我们访问数据还是使用`userStore.`的方式，这个比较麻烦。于是出现下面的代码：\n\n```vue\nlet {id, name, age} = useUserStore()\n```\n\n其实就是解包，但问题是这样解出来的数据会丢失响应式。理所当然想到：\n\n```vue\nlet {id, name, age} = toRefs(useUserStore())\n```\n\n这样出来的数据会变为`Ref`对象，仍然具备响应式。但是`toRefs`会将`useUserStore()`返回对象里面的所有属性都变为`Ref`，这是不合理的。因为我们只想将自定义的数据变为响应式，这可以：\n\n```vue\nimport { storeToRefs } from \'pinia\'\nlet {id, name, age} = storeToRefs(useUserStore())\n```\n\n因此我们的标准写法是使用`storeToRefs`。\n\n#### getters\n`pinia`还给我们提供了`getters`功能，可以在获取数据的时候做些操作。首先我们需要在`defineStore`的配置项里面添加`getters`配置项，如下：\n\n```vue\ngetters: {\n    father(): string {\n        return this.name + \'父亲\'\n    },\n    mother(state) {\n        return state.name + \'母亲\'\n    }\n}\n```\n\n`getters`里面定义若干函数，函数可以有一个参数`state`，我们定义的所有数据都是在这个`state`里面。\n\n除了通过参数`state`获取定义的数据，还可以使用`this`关键字获取，如果定义的函数没有参数，则需要指明函数的返回值类型。\n\n#### 订阅\n`pinia`还给我提供了订阅功能，可以监视`store`的改变。\n\n```vue\nconst userStore = useUserStore()\nuserStore.$subscribe((_, state)=>{\n    console.log(\'用户发生变化\', state)\n})\n```\n\n第一个参数一般用不到所以直接定义为`_`，第二个参数`state`存着我们定义的所有数据。\n\n一个通用的场景是持久化，我们可以在数据发生变化的时候将数据存到`localStorage`里面，`store`对象初始化数据的时候也从`localStorage`里面读取。\n\n#### 组合式写法\n`store`的定义还有组合式写法，看下面例子：\n\n```typescript\nimport {defineStore} from \'pinia\'\nimport { reactive } from \'vue\'\n\nexport const useUserStore = defineStore(\'user\', ()=>{\n  let userInfo = reactive({\n    id: \'1001\', \n    name: \'张三\',\n    age: 18\n  })\n  function changeUser() {\n    userInfo.id = \'1002\'\n    userInfo.name = \'李四\'\n    userInfo.age = 20\n    console.log(\'user.ts\', userInfo.name)\n  }\n  return {userInfo, changeUser}\n})\n```\n\n本来传配置项的地方现在改为一个函数，函数里面定义数据和函数，然后通过返回值返回。\n\n### 组件通信\n#### props 方式\n`props`主要用于父子组件间的通信，父组件向子组件传递数据是[2.10](#Q0ijS)着重讲的内容。那么子组件想要通过`props`传递数据给父组件怎么做？其实很简单，父组件先定义一个函数，然后将这个函数通过`props`传给子组件，子组件将要传的数据作为参数调用这个函数。\n\n```vue\n<template>\n    <div>\n        <p>父组件</p>\n        <p>自己的车：{{ car }}</p>\n        <p>儿子的玩具：{{ toy }}</p>\n        <Child :car=\"car\" :sendToy=\"getToy\" />\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import { ref } from \'vue\'\n    import Child from \'./Child.vue\'\n\n    let car = ref(\'奔驰\')\n    let toy = ref(\'\')\n    function getToy(t: string) {\n        toy.value = t\n    }\n</script>\n```\n\n```vue\n<template>\n    <div>\n        <p>子组件</p>\n        <p>父亲的车：{{ car }}</p>\n        <p>我的玩具：{{ toy }}</p>\n        <button @click=\"sendToy(toy)\">把玩具传给父组件</button>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import { ref } from \'vue\'\n\n    defineProps([\'car\', \'sendToy\'])\n    let toy = ref(\'奥特曼\')\n</script>\n```\n\n#### 自定义事件\n自定义事件主要用于子组件传递数据给父组件，我们知道系统中定义了一些常见的事件例如点击、键盘按动、鼠标滑动等，除此之外 Vue 还支持自定义事件。例如，我们在写子组件标签的时候为其添加一个`get-toy`事件可以这样：\n\n```vue\n<Child @get-toy=\"getToy\" />\n```\n\n这个事件触发时执行的`getToy`函数是定义在父组件里面的，如果子组件能够在合适的时机触发这个事件那不就可以通过参数给父组件传数据了吗？那子组件该怎么和触发这个自定义事件呢？\n\n```java\nconst emit = defineEmits([\'get-toy\'])  // 声明 get-toy 事件\nemit(\'get-toy\', toy.value)  // 触发事件并传参\n```\n\n#### mitt\n`mitt`可以实现任意组件的通信，基本原理就是找一个中间人，接收数据的组件往中间人上绑定一个事件，发送数据的组件触发这个事件并将数据作为参数传递过去。\n\n想要使用`mitt`，我们首先需要：\n\n1. 使用命令`npm i mitt`安装这个模块\n2. 在`src`目录下创建`tools`或`utils`目录，这是一个规范不强制\n3. 接着在`tools/utils`目录下创建 TS 文件，我们这边就创建`emitter.ts`\n\n```typescript\nimport mitt from \'mitt\'\nconst emitter = mitt()  // 这就是上面说的中间人\nexport default emitter  // 将其暴露出去，其它组件才能访问它\n```\n\n需要接收数据的组件在`emitter`上绑定事件如下：\n\n```typescript\nimport emitter from \'@/tools/emitter\'\n// 绑定 send-toy 事件，并设置需要一个参数\nemitter.on(\'send-toy\', (value:any)=>{\n    toy.value = value\n})\nonUnmounted(()=>{  // 组件被卸载时应该取消绑定这个事件\n    emitter.off(\'send-toy\')  // 取消指定事件\n    emitter.all.clear()  // 取消所有事件\n})\n```\n\n需要发送数据的组件在合适的时机触发这个事件并将数据作为参数传过去即可：\n\n```typescript\nimport emitter from \'@/tools/emitter\'\nemitter.emit(\'send-toy\', toy)  // 触发 send-toy 事件并将数据传过去\n```\n\n#### v-model\n我们会经常使用`v-model`将变量与输入框双向绑定，其实也可以对自定义组件使用`v-model`。不过这个自定义组件一般也是封装的输入框，因为用户能修改的一般也只有输入框。\n\n首先我们需要明白双向绑定的本质，下面的两种写法是完全等价的：\n\n```typescript\n<MyInput v-model=\"username\" />\n<MyInput :modelValue=\"username\" @update:modelValue=\"username = $event\" />\n```\n\n对一个自定义组件做`v-model`，实际上会添加`modelValue`属性和`update:modelValue`事件（事件的命名可以有`:`）。子组件`MyInput`代码如下：\n\n```vue\n<template>\n    <input \n        type=\"text\"\n        :value=\"modelValue\"\n        @input=\"emit(\'update:modelValue\', $event.target.value)\"\n    />\n</template>\n\n<script setup lang=\"ts\">\n    defineProps([\'modelValue\'])\n    const emit = defineEmits([\'update:modelValue\'])\n</script>\n```\n\n首先通过获取属性传过来的值并显示，然后当内部的输入框发生变化的时候再通过触发自定义事件将值带回去。父组件接受到新的值后，将值设置到变量中，于是就实现了双向绑定。\n\n在原生事件里面`$event`表示的是事件对象，在自定义事件里`$event`就是触发事件时传递的值。\n\n上面`v-model`的默认属性是`modelValue`，我们可以修改这个属性，语法很简单：\n\n```vue\n<MyInput v-model:name=\"username\" />\n```\n\n这边修改之后，子组件获取的属性和自定义方法就变成了`name`和`update:name`。一般来说没必要修改，但在需要双向绑定多个变量的情况下就很有用了。\n\n#### $attrs\n`$attrs`一般用于祖孙组件互传数据，当我们通过属性给子组件传递消息的时候，子组件需要通过`defineProps`声明才能使用该变量。父组件通过属性传递的数据，未被子组件使用`defineProps`声明的变量会放到`$attrs`里面。所以我们可以将这些数据再通过属性传给孙组件：\n\n```vue\n<GrandChild v-bind=\"$attrs\" />\n<!-- 假设 $attrs 里面装着属性 x 和 y，那么上面等价下面 -->\n<GrandChild :x=\"x\" :y=\"y\" />\n```\n\n`v-bind`里面可以传一个对象，相当于将对象里面的值通过属性传递给子组件。因此孙组件就可以使用`defineProps`声明并使用这些变量。\n\n这样就可以借助子组件使用`$attrs`实现祖到孙的通信，那么孙怎么传数据给祖呢？很简单，祖组件可以传递一个函数给孙组件，然后孙组件调用这个函数并将数据作为参数传递到祖。具体实现比较简单就不演示了。\n\n#### $refs 和 $parent\n##### $refs\n[2.8.3](#pW963)讲过给子组件加`ref`属性，父组件只需要声明一个同名的空`ref()`就可以拿到子组件对象。如果组件内有较多的子组件需要去获取，我们就需要定义多个空`ref()`变量，而且操作起来也需要挨个操作。那能不能批量获取子组件并进行批量操作呢？其实是可以的，我们在父组件里面可以使用`$refs`获取所有的子组件对象，想要批量操作还可以使用循环：\n\n```vue\n<template>\n    <div class=\"father\">\n        <p>父组件</p>\n        <!-- 通过 ref 属性给子组件命名 -->\n        <Child1 ref=\"c1\" />\n        <Child2 ref=\"c2\" />\n        <!-- 通过函数调用将 $refs 传给 JS 脚本 -->\n        <button @click=\"getChildren($refs)\">增加子组件的书本数目</button>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import Child1 from \'./Child1.vue\'\n    import Child2 from \'./Child2.vue\'\n\n    // 这边的 refs 就是模板里的 $refs，这是一个对象，里面装着所有命名的子组件 \n    function getChildren(refs: any) {\n        for (let key in refs) {  // 遍历所有子组件\n            refs[key].bookNum += 2\n        }\n    }\n</script>\n```\n\n有几个注意点：\n\n1. 所有的`$`开头的变量都只能在模板里访问，JS 想要访问需要通过模板调用函数传参的方式\n2. 通过`$refs`能够获取的组件必须定义`ref`属性，否则是找不到的\n3. 例子里面父组件访问子组件的`bookNum`变量，那么子组件必须将其使用`defineExpose({bookNum})`暴露出来\n\n##### $parent\n子组件可以通过`$parent`获取父组件对象，当然也要通过模板传给 JS 脚本。拿到父组件对象就可以操作父组件的一些变量，前提是父组件将这些变量使用`defineExpose`暴露出来：\n\n```vue\n<template>\n    <div class=\"child\">\n        <p>子组件</p>\n        <button @click=\"addHouse($parent)\">修改父组件数据</button>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    function addHouse(parent: any) {\n        parent.houseNum++\n    }\n</script>\n```\n\n#### provide 和 inject\n`provide`与`inject`可以实现子孙后代之间通信，父组件通过`provide`提供数据，后代组件通过`inject`接收数据。\n\n```typescript\n/* 以下是祖先组件内容 */\nimport {ref, provide} from \'vue\'\n\nlet money = ref(100)\nprovide(\'money\', money)  // 祖先组件使用 provide 传递数据，两个参数分别是键与值\n\n/* 以下是后代组件内容 */\nimport { inject } from \'vue\'\nlet money = inject(\'money\', 0)  // inject 函数两个参数分别是键和默认值\n```\n\n关于这种方式实现的子孙通信有一些注意点：\n\n1. 如果父组件传递的数据是响应式的，那么子组件接收到的也是响应式的且两者是同一个对象，即子组件修改数据对父组件是可见的\n2. 子组件接收数据时会选择就近原则，即爷组件传递数据，父组件传递同名数据，子组件接收的时候会选择父组件的数据\n3. 祖先传递的数据可以被多个子孙`inject`，不存在截断现象\n\n#### 插槽\n##### 默认插槽\n假设我们要做下图的效果：\n\n![](/upload/covers/e4f00674c64b47ba8838008d452fbe08.png)\n\n父组件里面有两个子组件，这两个子组件不完全一样。一个想法是写两个`.vue`文件表示两个组件，但是没必要，因为图中两个子组件的大体结构是一样的。那我们在子组件里面使用`v-if`或`v-show`来选择性展示？可以，但是很麻烦。更优雅的解决方案是使用插槽，父组件内的代码：\n\n```vue\n<template>\n    <div class=\"father\">\n        <p>父组件</p>\n        <div class=\"content\">\n            <Child title=\"热门游戏列表\">\n                <ul>\n                    <li v-for=\"g in games\" :key=\"g.id\">{{ g.name }}</li>\n                </ul>\n            </Child>\n            <Child title=\"每日好图\">\n                <MyImage/>\n            </Child>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import {ref, reactive} from \'vue\'\n    import Child from \'./Child.vue\'\n    import MyImage from \'./MyImage.vue\'\n\n    let games = reactive([\n        {id: \'1001\', name: \'交错战线\'},\n        {id: \'1002\', name: \'王者荣耀\'},\n        {id: \'1003\', name: \'英雄联盟\'},\n        {id: \'1004\', name: \'斗罗大陆\'},\n    ])\n</script>\n```\n\n这个代码很简单，只不过我们在自定义组件内部写上了其它标签（可以是原生标签，也可以是自定义组件）。这些写在标签内部的内容默认并不会展现出来，因为 Vue 不知道将这些内容展示在什么地方。因此需要我们在子组件内开启插槽：\n\n```vue\n<template>\n    <div class=\"child\">\n        <p>{{ title }}</p>\n        <!-- 插槽标签，后续在本组件标签内部写东西会展现在这 -->\n        <slot>默认内容</slot>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    defineProps([\'title\'])\n</script>\n```\n\n关于插槽有两个注意点：\n\n1. 如果定义了多个插槽标签，那么传递的内容会展示多次。\n2. 我们在组件内定义了插槽，但是使用的时候没有传递内容会展示插槽内部的默认内容。\n\n##### 具名插槽\n一般默认插槽只会定义一个，毕竟定义多个也只是将内容多复制几遍。如果我们确实想要通过插槽插入多个不同的内容该怎么做？此时可以给每一个插槽命名，然后插入的时候指定插入到哪一个插槽。\n\n子组件可以通过`name`属性给插槽命名：\n\n```vue\n<template>\n    <div class=\"child\">\n        <p>{{ title }}</p>\n        <!-- 给插槽起名叫 content -->\n        <slot name=\"content\"></slot>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    defineProps([\'title\'])\n</script>\n```\n\n父组件使用的时候给内容指定具体的插槽：\n\n```html\n<template>\n    <div class=\"father\">\n        <p>父组件</p>\n        <div class=\"content\">\n            <Child title=\"热门游戏列表\">\n                <!-- 使用 “v-slot:插槽名” 语法指定插槽 -->\n                <template v-slot:content>\n                  <ul>\n                    <li v-for=\"g in games\" :key=\"g.id\">{{ g.name }}</li>\n                  </ul>\n                </template>\n            </Child>\n            <Child title=\"每日好图\">\n                <!-- 语法糖，指定插槽可以简写成 “#插槽名” -->\n                <template #content>\n                  <MyImage />\n                </template>\n            </Child>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n  import {ref, reactive} from \'vue\'\n  import Child from \'./Child.vue\'\n  import MyImage from \'./MyImage.vue\'\n\n  let games = reactive([\n    {id: \'1001\', name: \'交错战线\'},\n    {id: \'1002\', name: \'王者荣耀\'},\n    {id: \'1003\', name: \'英雄联盟\'},\n    {id: \'1004\', name: \'斗罗大陆\'},\n  ])\n</script>\n```\n\n指定插槽的时候必须写在`template`标签上，因此往往需要包裹一层`<template>`。\n\n学完具名插槽提一句，其实默认插槽也有名字，就叫做`default`。\n\n##### 作用域插槽\n插槽出现的背景是父组件想要控制子组件的结构，上面的两种插槽都存在一个问题，那就是插槽的数据都是父组件维护。如果数据在子组件里面，但展示的格式由父组件决定，这个需求怎么实现？说白了就是子组件想给使用插槽的人传数据，子组件可以：\n\n```html\n<template>\n    <div class=\"child\">\n        <p>每日游戏推荐</p>\n        <!-- 给 slot 标签加上属性，这个值会被传递给使用插槽的人 -->\n        <slot :games=\"games\"></slot>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import {reactive} from \'vue\'\n\n    let games = reactive([\n        {id: \'1001\', name: \'交错战线\'},\n        {id: \'1002\', name: \'王者荣耀\'},\n        {id: \'1003\', name: \'英雄联盟\'},\n        {id: \'1004\', name: \'斗罗大陆\'},\n    ])\n</script>\n```\n\n父组件使用插槽的元素能够获取到传递的数据构成的对象：\n\n```html\n<template>\n    <div class=\"father\">\n        <p>父组件</p>\n        <div class=\"content\">\n            <Child>\n                <!-- 拿到的是所有数据构成的对象 -->\n                <template v-slot=\"params\">\n                    <ul>\n                        <li v-for=\"g in params.games\" :key=\"g.id\">{{ g.name }}</li>\n                    </ul>\n                </template>\n            </Child>\n            <Child>\n                <!-- 接收数据的同时直接解包 -->\n                <template v-slot=\"{games}\">\n                    <ol>\n                        <li v-for=\"g in games\" :key=\"g.id\">{{ g.name }}</li>\n                    </ol>\n                </template>\n            </Child>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import Child from \'./Child.vue\'\n</script>\n```\n\n关于数据传递有几个要点：\n\n1. 插槽可以传递若干个数据，例如`<slot a=\"1\" b=\"2\"></slot>`，使用插槽的人获取到的数据是这些属性构成的对象`{a: \"1\", b: \"2\"}`\n2. 对于具名插槽获取数据也是一样的写法`<template v-slot:name=\"{games}\">`\n\n#### 通信总结\n| **组件关系** | **传递方式** |\n| :---: | --- |\n| 父传子 | 1. `props`<br/>2. `v-model`<br/>3. `$refs`<br/>4. 默认插槽、具名插槽 |\n| 子传父 | 1. `props`<br/>2. 自定义事件<br/>3. `v-model`<br/>4. `$parent`<br/>5. 作用域插槽 |\n| 祖孙互传 | 1. `$attrs`<br/>2. `provide、inject` |\n| 任意组件传递 | 1. `pinia`<br/>2. `mitt` |\n\n'),
       (19, 19, '### 其它 API\n#### shallow\n##### shallowRef\n之前学过使用`ref`定义响应式对象，对象里面一个属性发生变化都会展现在界面上。本节的`shallowRef`是浅层的`ref`，它只监听数据`.value`的变化，至于更深层次的属性变化不管。\n\n```html\n<template>\n    <p>Person1：{{ person1 }}</p>\n    <p>Person2：{{ person2 }}</p>\n    <button @click=\"changeName1\">修改person1姓名</button>\n    <button @click=\"changePerson1\">修改整个person1</button> <br>\n    <button @click=\"changeName2\">修改person2姓名</button>\n    <button @click=\"changePerson2\">修改整个person2</button>\n</template>\n\n<script setup lang=\"ts\">\n    import { ref, shallowRef } from \'vue\'\n\n    let person1 = ref({name: \'张三\', age: 18})\n    let person2 = shallowRef({name: \'李四\', age: 20})\n    function changeName1() {  // 响应式\n        person1.value.name += \'~\'\n    }\n    function changePerson1() {  // 响应式\n        person1.value = {name: \"王五\", age: 60}\n    }\n    function changeName2() {  // 非响应式！！！\n        person2.value.name += \'!\'\n    }\n    function changePerson2() {  // 响应式\n        person2.value = {name: \"赵六\", age: 80}\n    }\n</script>\n```\n\n若一个响应式变量是`shallowRef`定义的，那么只能监听`.value`的修改，至于更深的`.value.name`的修改是监听不到的。\n\n##### shallowReactive\n`reactive、shallowReactive`之间的关系与`ref、shallowRef`之间的关系很像，对于`reactive`定义的响应式对象，我们只能修改对象的属性，如果要改的内容比较多可以借助`Object.assign`批量赋值。`shallowReactive`定义的响应式对象可以监听第一层的属性变化，监听不到内层的属性变化。具体看一个例子：\n\n```html\n<template>\n    <p>Person1：{{ person1 }}</p>\n    <p>Person2：{{ person2 }}</p>\n    <button @click=\"changeCar1Name\">修改person1车品牌</button>\n    <button @click=\"changeCar1\">修改整个person1整个车</button> <br>\n    <button @click=\"changeCar2Name\">修改person2车品牌</button>\n    <button @click=\"changeCar2\">修改整个person2整个车</button>\n</template>\n\n<script setup lang=\"ts\">\n    import { reactive, shallowReactive } from \'vue\'\n\n    let person1 = reactive({name: \'张三\', car: {brand: \'奔驰\', price: 100}})\n    let person2 = shallowReactive({name: \'李四\', car: {brand: \'宝马\', price: 80}})\n    function changeCar1Name() {  // 响应式\n        person1.car.brand = \'爱玛\'\n    }\n    function changeCar1() {  // 响应式\n        person1.car = {brand: \'丰田\', price: 10}\n    }\n    function changeCar2Name() {  // 非响应式！！！\n        person2.car.brand = \'雅迪\'\n    }\n    function changeCar2() {  // 响应式\n        person2.car = {brand: \'大众\', price: 20}\n    }\n</script>\n```\n\n正如例子所呈现的，`shallowReactive`定义的`person`对象能监听`person.car`的变化但不能监听`person.car.brand`的变化。\n\n#### only\n##### readonly\n`readonly`用来生成一个响应式对象的只读副本，具体使用如下：\n\n```typescript\nimport { ref, readonly } from \'vue\'\n\nlet person1 = ref({name: \'张三\', car: {brand: \'奔驰\', price: 100}})\nlet person2 = readonly(person1)\n\n// 以下两种写法都是错误的，因为 person2 是只读的不能修改\nperson2.value.car.brand = \'雅迪\'\nperson2.value.car = {brand: \'大众\', price: 20}\n```\n\n使用`readonly`生成的对象副本和原来的对象是共通的，原来的对象修改数据对副本也是可见的。\n\n##### shallowReadonly\n`shallowReadonly`会为响应式对象生成一个浅只读副本，可以修改深层次的属性，不能修改浅层次的属性。具体来说对于`ref`定义的变量，不能修改`.value`但可以修改`.value.name`之类的；对于`reactive`定义的对象，不能修改`.car`但可以修改`.car.name`。\n\n#### raw\n##### toRaw\n`toRaw`能够获得响应式对象的非响应式形式，举个例子：\n\n```typescript\nimport { reactive, toRaw } from \'vue\'\n\nlet person1 = reactive({name: \'张三\', age: 18})\nlet person2 = toRaw(person1)  // 返回一个非响应式的普通对象\n```\n\n使用`toRaw`得到的就是一个普通的对象，对它修改不会作用到界面上。但是，`person1`和`person2`是互通的，**其中任意一方修改数据都会影响到另一方**，若响应式对象`person1`因此而改变也不会作用到页面上。\n\n##### markRaw\n`markRaw`可以使一个普通对象无法变为响应式对象，例子：\n\n```typescript\nlet person1 = markRaw({name: \'张三\', age: 18})\nlet person2 = reactive(person1)\nconsole.log(person1, person2)\n```\n\n上面代码不会报错，但是`person2`即使使用`reactive`包裹，也不会变为响应式的，仍然是普通对象。\n\n#### customRef\n`customRef`是自定义`ref`，应用场景是什么呢？假设我们输入框使用`v-model`双向绑定了一个`ref`定义的响应式数据，此时我们在输入框里输入内容，新内容会立刻放到变量中。思考一个需求，我要求输入框输入新内容后延迟 1 秒将内容刷新怎么实现？延迟 1 秒显得呆呆的，我们可以把延迟 1 秒改成网络请求等其它具有实际意义的事情。\n\n```typescript\n<template>\n    {{ name }} <br>\n    <input type=\"text\" v-model=\"name\">\n</template>\n\n<script setup lang=\"ts\">\n    import { customRef } from \'vue\'\n\n    let initValue = \'张三\'\n    let name = customRef((trace, trigger)=>{\n        return {\n            get() {  // 访问 name 的时候会调用 get\n                trace()\n                return initValue\n            },\n            set(value) {  // 给 name 设置值的时候会调用 set\n                setTimeout(()=>{\n                    initValue = value\n                    trigger()\n                }, 1000)\n            }\n        }\n    })\n</script>\n```\n\n整体代码逻辑很好理解，但是有两个函数调用`trace()`与`trigger()`比较奇怪。\n\n+ `trace()`是通知 Vue 对 name 进行监听，一旦发生变化就去更新\n+ `trigger()`是通知 Vue 数据发生了变化\n\n这两个函数是配套使用的，访问数据前调用`trace()`，修改数据后调用`trigger()`。\n\n一般情况下，我们会将一些常用的自定义`ref`封装成`hook`方便调用。\n\n#### Teleport\n`Teleport`是传送门标签，它能将写在里面的元素放到指定位置。看例子：\n\n```typescript\n<template>\n    <div class=\"outer\">\n        <Child/>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n    import Child from \'./components/Child.vue\'\n</script>\n```\n\n代码很简单，父组件内部维护一个子组件。按道理渲染的时候子组件是在`div.outer`内部的。\n\n```vue\n<template>\n  <!-- 将要转移的内容写到 Teleport 标签内部，使用 to 属性指定要去的地方 -->\n  <Teleport to=\"#app\">\n    <div class=\"child\"></div>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\"></script>\n```\n\n这是子组件代码，这么写之后子组件会放到`#app`对应元素内部，就移出了父组件。`Teleport`的`to`属性里面写选择器，可以是标签选择器、类选择器、ID 选择器等。\n\n#### 全局\n##### 全局组件\n所谓全局组件就是你可以在任意一个组件内无需导入却能直接访问它，Vue3 可以在`main.ts`的`app`对象上注册全局组件：\n\n```typescript\nimport { createApp } from \"vue\"\nimport App from \"./App.vue\"\nimport Child from \'./components/Child.vue\'\n\nconst app = createApp(App)\napp.component(\'Child\', Child)  // 全局注册 Child 组件\napp.mount(\"#app\")\n```\n\n注册完毕之后，其它地方可以直接使用`Child`组件而不需要导入它。\n\n##### 全局指令\nVue 给我们提供了很多指令，例如`v-bind`、`v-model`等。其实 Vue 还支持我们自定义指令，例如我想自定义一个`v-beauty`指令仍然需要修改`main.ts`：\n\n```typescript\nimport { createApp } from \"vue\"\nimport App from \"./App.vue\"\n\nconst app = createApp(App)\n// 注册 v-beauty 事件，传入一个回调，回调的参数分别是绑定的元素以及绑定的变量\napp.directive(\'beauty\', (element, {value})=>{\n    console.log(value)\n    element.style.color = \'green\'\n    element.style.backgroundColor = \'yellow\'\n})\napp.mount(\"#app\")\n```\n\n使用的时候可以直接：\n\n```vue\n<template>\n  <div class=\"child\" v-beauty=\"user\">你好！{{ user.name }}</div>\n</template>\n\n<script setup lang=\"ts\">\n  import {reactive} from \'vue\'\n\n  let user = reactive({name: \'张三\'})\n</script>\n```\n\n### 常用功能\n#### 随机字符串\n##### nanoid\n1. 首先安装模块`npm i nanoid`\n2. 使用`nanoid`生成随机字符串\n\n```vue\nimport {nanoid} from \'nanoid\'  // 导入 nanoid\nlet data1 = nanoid()  // 默认生成 21 位随机字符串\nlet data2 = nanoid(36)  // 指定随机字符串位数\n```\n\n##### uuid\n1. 首先安装模块`npm i uuid`\n2. 使用`uuid`生成随机字符串\n\n```vue\nimport {v4 as uuidv4} from \'uuid\'  // 导包、引入 v4 函数并改名\nlet d1 = uuidv4()  // 直接调用获取 uuid\nconsole.log(d1, d1.length)  // uuid 默认 32 位十六进制数字再加上 4 个‘-’共 36 位\n```\n\n#### flex 布局\n##### 简介\n`Flex`是`Flexible Box`的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局，即使是行内元素：\n\n```css\n.box{\n  display: flex;\n}\n```\n\n```css\n.box{\n  display: inline-flex;\n}\n```\n\n##### 基本概念\n采用`Flex`布局的元素，称为`Flex`容器（flex container），简称“容器”。容器的所有子元素自动成为容器成员，称为`Flex`项目（flex item），简称”项目”。\n\n![](/upload/covers/4b254796a13e4af8883652598bc92abe.png)\n\n容器默认存在两根轴：水平的主轴（`main axis`）和垂直的交叉轴（`cross axis`）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。**项目默认沿主轴排列**，单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n##### 容器的属性\n###### flex-direction\n`flex-direction`属性可以决定主轴的方向即项目的排列方向。\n\n```css\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n它有四种可能的取值：\n\n1. `row`主轴是水平方向，起点在左侧，是**默认值**。\n2. `row-reverse`主轴是水平方向，起点在右侧。\n3. `column`主轴是垂直方向，起点在上沿。\n4. `column-reverse`主轴是垂直方向，起点在下沿。\n\n![](/upload/covers/7432326b7cc74a589eab34c078a95b8f.png)\n\n###### flex-wrap\n一般情况下项目会排列在轴线上，使用`flex-wrap`属性可以定义轴线上排不下时该如何换行：\n\n```css\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n它有三种可能的取值：\n\n1. `nowrap`是**默认值**，表示不换行。此时项目会被压缩，使其能够放到容器的一行中。\n2. `wrap`表示换行，第一行在上方。\n3. `wrap-reverse`表示换行，第一行在下方。\n\n![](/upload/covers/0a9d643774f849ecb52724b89363bcda.png)\n\n\n###### flex-flow\n`flex-flow`属性是`flex-direction`与`flex-wrap`属性的合并简写形式，其**默认值**为`row nowrap`。\n\n```css\n.box {\n  flex-flow: <flex-direction> <flex-wrap>;\n}\n```\n\n###### justify-content\n`justify-content`定义了项目在主轴上的对齐方式。\n\n```css\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n它有五种可能的取值（假设主轴从左到右）：\n\n1. `flex-start`是**默认值**，表示左对齐。\n2. `flex-end`表示右对齐。\n3. `center`表示水平居中对齐。\n4. `space-between`两端对齐（首尾项目贴边），项目之间的间隔要相等。\n5. `space-around`每个项目两侧间隔相等，因此最边缘的间隔是中间间隔的一半。\n\n![](/upload/covers/ba3e147097a147e38c93d66305d0d7b1.png)\n\n![](/upload/covers/5eb411c1ccb64dfb8bf7742d87c5abec.png)\n\n###### align-items\n`align-items`属性定义项目在交叉轴上的对齐方式。\n\n```css\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n它有五种可能的取值（假设交叉轴自上而下）：\n\n1. `flex-start`表示上对齐。\n2. `flex-end`表示下对齐。\n3. `center`表示竖直居中对齐。\n4. `baseline`项目的第一行文字的基线对齐。\n5. `stretch`是**默认值**，如果项目**未设置高度或设为auto**，将占满整个容器的高度。\n\n![](/upload/covers/4d43cc27629e470ca99c0c1431c5909a.png)\n![](/upload/covers/ff993ad8016b4b8dbe7e47eb5e9bb7bb.png)\n![](/upload/covers/8abd1bbee9ff497f8adf4578a0c4a029.png)\n\n##### 项目的属性\n###### order\n`order`属性定义项目的排列顺序，数值越小排列越靠前，**默认为 0**。\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n![](/upload/covers/78af5b51caa74ada96424adbd4515411.png)\n\n###### flex-grow\n`flex-grow`属性定义项目的放大比例。**默认为 0**，即使存在剩余空间，也不会放大。\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n放大原理是这样的：\n\n1. 首先满足所有的项目需求的大小；\n2. 剩下的空间由所有项目共享，每个项目分到多少空间由`flex-grow`设定的值决定；\n3. 假设一个项目的`grow`值为`x`，所有项目的`grow`之和为`sum`，那么本项目占据剩余空间的比例为`x / sum`。\n\n![](/upload/covers/9116fefd5f154e08bf6c3db979af36a1.png)\n\n###### flex-shrink\n和`flex-grow`相对，`flex-shrink`属性定义项目的缩小比例。**默认为 1**，即所有项目默认情况下都等比缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n原理也是类似的，每个项目根据`shrink`值计算出缩小的比例，然后根据比例进行缩小。\n\n如果`shrink`值为 0，则表示无论如何也不缩小。\n\n![](/upload/covers/9896b281a9824154a97bb99818b230b5.png)\n\n###### flex-basis\n`flex-basis`属性定义项目在主轴上的原始大小，它会覆盖`width`的值。**默认值**是`auto`，即使用项目本来的大小。\n\n```css\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n![](/upload/covers/25dc1a342c92443abbb3f2ff88a56be9.png)\n\n###### flex\n`flex`属性是`flex-grow、flex-shrink、flex-basis`的简写，默认值是`0 1 auto`。\n\n```css\n.item {\n  flex: none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]\n}\n```\n\n这个属性有两个快捷值：`auto（0 1 auto）`和`none（0 0 auto）`。\n\n###### align-self\n`align-self`允许单个项目有与其它项目不一样的对齐方式，可以覆盖容器`align-items`属性。**默认值**是`auto`，表示继承容器`align-items`属性值。\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![](/upload/covers/47ba3991d70a4f2894f1fa029074d981.png)\n\n#### 异步\n传统上使用异步基本上都是借助大量的回调，当回调层数足够多时会出现“回调地狱”。假设我们有这样的需求，1 秒后打印字符串“hello”，打印完之后等 2 秒再打印“world”，打印完后再等 3 秒打印“！！！”。传统上的实现代码可以是：\n\n```javascript\nsetTimeout(()=>{\n    console.log(\"hello\")\n    setTimeout(()=>{\n        console.log(\"world\")\n        setTimeout(()=>{\n            console.log(\"!!!\")\n        }, 3000)\n    }, 2000)\n}, 1000);\n```\n\n以小见大，当回调层数足够多的时候代码的可读性极低，可维护性极差。为了解决“回调地狱”问题，`Promise`就诞生了，这是一种全新的异步写法。我们可以根据构造函数创建`Promise`对象：\n\n```javascript\nnew Promise(function (resolve, reject) {\n    // 要做的事情...\n});\n```\n\n构造函数接收一个函数作为参数，这个函数我们称为初始函数。我们会在初始函数内部写要做的操作，初始函数有两个参数`resolve`和`reject`。`resolve`是操作成功执行的回调，`reject`是操作失败执行的回调。同样的例子使用`Promise`写：\n\n```javascript\nnew Promise((resolve, reject)=>{\n    setTimeout(()=>{\n        console.log(\"hello\")\n        resolve()\n    }, 1000)\n}).then(()=>{\n    return new Promise((resolve, reject)=>{\n        setTimeout(()=>{\n            console.log(\"world\")\n            resolve()\n        }, 2000)\n    })\n}).then(()=>{\n    return new Promise((resolve, reject)=>{\n        setTimeout(()=>{\n            console.log(\"!!!\")\n            resolve()\n        }, 3000)\n    })\n})\n```\n\n看似代码变长了很多，但是代码相对于“回调地狱”扁平化了许多，可读性大增。\n\n`Promise`对象有以下几个方法：\n\n1. `then`用于处理`Promise`成功的回调，初始函数里面执行`resolve()`时就会执行这边的回调；\n2. `catch`用于处理`Promise`失败的回调，初始函数里面执行`reject()`时就会执行这边的回调；\n3. `finally`无论`Promise`是否成功，都会执行的回调；\n\n我们再看一个例子：\n\n```javascript\nnew Promise(function (resolve, reject) {\n    console.log(1111);\n    resolve(2222);\n}).then(function (value) {\n    console.log(value);\n    return 3333;\n}).then(function (value) {\n    console.log(value);\n    throw \"An error\";\n}).catch(function (err) {\n    console.log(err);\n}).finally(function () {\n    console.log(\'finally\')\n});\n```\n\n`then`函数可以连续调用，由于`then`指定的回调有参数，所以调用`resolve`函数的时候也传递了参数。\n\n多个`then`连续调用的时候，上一个`then`的返回值作为下一个`then`的参数。\n\n通过`throw`抛出异常的时候会进入最近的`catch`。\n\n下面看一个高端写法，使用`await`关键字简写：\n\n```javascript\nfunction print(msg, delay) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(()=>{\n            console.log(msg)\n            resolve()\n        }, delay)\n    })\n}\n\nasync function start() {\n    await print(\"hello\", 1000)\n    await print(\"world\", 2000)\n    await print(\"!!!\", 3000)\n}\n```\n\n`await`关键字后面需要跟一个`Promise`对象，它会在这个`Promise`执行结束之后再执行后面的语句，这样写异步代码就和写同步代码一样简单。\n\n**注意：**如果一个函数内部使用了`await`，那么这个函数需要使用`async`关键字修饰。\n\n如果异步操作里面需要返回值应该怎么获取？很简单，直接定义变量接收即可。\n\n```javascript\nasync function asyncFunc() {\n    let value = await new Promise(\n        function (resolve, reject) {\n            resolve(\"Return value\");  // 执行成功且有返回值需要处理\n        }\n    );\n    console.log(value);  // 直接在上面定义变量接收即可\n}\n```\n\n使用了`await`之后似乎没有地方写失败的回调了，该怎么做？使用`try...catch`\n\n```javascript\nasync function asyncFunc() {\n    try {\n        await new Promise(function (resolve, reject) {\n            throw \"Some error\"; // 或者 reject(\"Some error\")\n        });\n    } catch (err) {  // 有异常会被 catch 到\n        console.log(err);  // 会输出 Some error\n    }\n}\n```\n\n#### 解构赋值\n解构赋值语法是一种 JS 表达式。通过解构赋值, 可以将属性值从对象或数组中取出，赋值给其他变量。\n\n##### 对象的解构\n对象的解构赋值有两种写法，如下：\n\n```javascript\nlet obj = {x: 1, y: 2, z: 3}\n\n// 标准写法，冒号前面是源对象的属性名，冒号后面是要赋值的变量\nlet {x: a, y: b, z: c} = obj\nconsole.log(a, b, c)  // 1 2 3\n\n// 简写，如果源对象属性与变量同名可以简写成下面的方式\nlet {x, y, z} = obj\nconsole.log(x, y, z)  // 1 2 3\n```\n\n上面的例子都是边创建变量边解构，如果想要解构给已经存在的变量可以：\n\n```javascript\nlet x, y, z\n({x, y, z} = obj)  // 赋值表达式需要使用小括号括起来，不然会把等号左侧当做代码块会出错\nconsole.log(x, y, z)  // 1 2 3\n```\n\n解构时可以为变量赋予默认值：\n\n```javascript\nlet {x, q=9} = obj  // 这边给变量 q 一个默认值 9\nconsole.log(x, q)  // 1 9\n```\n\n当右侧对象里面没有同名属性或属性值为`undefined`时，变量会使用自己的默认值。\n\n##### 数组的解构\n数组的解构并不仅仅是将数组解构，解构的对象包含所有的可迭代对象，包含字符串、数组、集合、Map 等。\n\n###### 字符串\n字符串的赋值单位是字符。\n\n```javascript\nlet message = \'Hello\';\nlet [a, b] = message;  // 按顺序获取前两个元素给变量 a、b\nlet [x, y, ...z] = message;  // ...z 表示将剩下的所有元素全部赋给 z\n\nconsole.log(a, b);        // H e\nconsole.log(x, y, z);     // H e [\'l\', \'l\', \'o\']\n```\n\n###### 数组\n数组的赋值单位是元素。\n\n```javascript\nlet numbers = [1, 2, 3];\nlet [x, y, ...z] = numbers;  // 尽管 z 只能分到一个元素，但因为 ... 的存在它仍然是数组\n\nconsole.log(x, y, z);    // 1 2 [3]\n```\n\n###### 集合\n集合的赋值单位也是元素。\n\n```javascript\nlet set = new Set().add(\'foo\').add(\'bar\');\nlet [a, b] = set;\n\nconsole.log(a, b);      // foo bar\n```\n\n###### Map\nMap 的赋值单位是键值对组合而成的数组。\n\n```javascript\nlet map = new Map().set(\'a\', 1).set(\'b\', 2);\nlet [x, y] = map;\n\nconsole.log(x, y);    // [\"a\", 1] [\"b\", 2]\n```\n\n###### 一些小知识点\n```javascript\nlet data = [1, 2, 3]\nlet [, y, z] = data  // 需要跳过某些元素时可以直接写逗号\nconsole.log(y, z)  // 2 3\n\nlet [a, b, c, d=-1] = data  // 数组解构也可以有默认值\nconsole.log(a, b, c, d)  // 1 2 3 -1\n\nlet m, n\n[m, n] = data  // 和对象解构不同，数组解构对已存在的变量解构不需要加“()”\nconsole.log(m, n)  // 1 2\n```\n\n##### 嵌套解构\n嵌套解构也是支持的，我们首先看对象的嵌套解构：\n\n```javascript\nconst student = {\n    name: \'ZhangSan\',\n    age: 18,\n    scores: {\n        math: 19,\n        english: 85,\n        chinese: 100\n    }\n};\n\nconst { name, scores: {math, english, chinese} } = student; \nconsole.log(name, math, english, chinese)  // Zhangsan 19 85 100\n```\n\n比较好理解，我们并没有定义`scores`变量，而是使用标准写法将源对象的`scores`属性赋值给`{math, english, chinese}`，这又触发了对象的解构简写。\n\n对数组的解构赋值更简单，看例子：\n\n```javascript\nlet numbers = [1, [2, 3, 4], 5];\nlet [a, [b, c, d], e] = numbers;  // 直接嵌套定义数组即可\nconsole.log(a, b, c, d, e); // 1 2 3 4 5\n```\n\n##### 应用场景\n###### 函数参数\n```javascript\nfunction func([a, b, c]) {  // 直接在形参里解构\n    console.log(a, b, c)\n}\n\nlet data = [1, 2, 3]\nfunc(data)\n```\n\n###### 函数返回值\n```javascript\nfunction func() {\n    return {name: \'张三\', age: 18}\n}\n\nlet {name, age} = func()  // 直接对返回值解构\nconsole.log(name, age)\n```\n\n###### 交换变量\n```javascript\nlet a = 1, b = 2;\n[a, b] = [b, a]\nconsole.log(a, b)\n```\n\n###### 数组拷贝\n```javascript\nlet arr = [1, 2, 3]\nlet [...x] = arr  // 与下面的语句等价\n// let x = [...arr]\nconsole.log(x)\n```\n\n'),
       (20, 20, '#### 1. 两数之和\n给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出和为目标值`target`的那两个整数，并返回它们的数组下标。注意：你可以按任意顺序返回答案，数组中同一个元素在答案里不能重复出现。\n\n> [https://leetcode.cn/problems/two-sum/](https://leetcode.cn/problems/two-sum/)\n>\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for i, n in enumerate(nums):\n            idx = num_map.get(target - n, None)\n            if idx is not None:\n                return [idx, i]\n            num_map[n] = i\n        return []\n```\n\n#### 2. 两数相加\n给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n> [https://leetcode.cn/problems/add-two-numbers/](https://leetcode.cn/problems/add-two-numbers/)\n>\n\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        flg = 0\n        p, head = None, None\n        while l1 or l2:\n            n1 = l1.val if l1 else 0\n            n2 = l2.val if l2 else 0\n            val = n1 + n2 + flg\n            if val > 9:\n                val -= 10\n                flg = 1\n            else: flg = 0\n            t = ListNode(val)\n            if head is None:\n                p = t\n                head = t\n            else:\n                p.next = t\n                p = p.next\n            if l1: l1 = l1.next\n            if l2: l2 = l2.next\n        if flg == 1:\n            p.next = ListNode(1)\n        return head\n```\n\n#### 3. 无重复字符的最长子串\n给定一个字符串`s`，请你找出其中不含有重复字符的**最长子串**的长度。\n\n> [https://leetcode.cn/problems/longest-substring-without-repeating-characters/](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n>\n\n**方法名称：滑动窗口**\n\n**思路描述：**\n\n假设第`i`个字符开头的子串末尾字符下标为`j`，那么第`i + 1`个字符开头的子串末尾下标必然`≥ j`。因此我们使用`i`从前到后遍历整个串，并不断更新`j`，这过程中最长的子串长度就是解。\n\n判断字符是否重复我们借助`Set`这种数据结构来实现。\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s: return 0\n        exist_set = set()\n        j, ans, length = 0, 0, len(s)\n        for i in range(length):\n            while j < length and s[j] not in exist_set:\n                exist_set.add(s[j])\n                j += 1\n            if j - i > ans: ans = j - i\n            if j >= length: break\n            exist_set.remove(s[i])\n        return ans\n```\n\n#### 4. 寻找两个正序数组的中位数\n给定两个大小分别为`m`和`n`的正序（从小到大）数组`nums1`和`nums2`。请你找出并返回这两个正序数组的中位数 。算法的时间复杂度应该为`O(log (m+n))`。\n\n> [https://leetcode.cn/problems/median-of-two-sorted-arrays/](https://leetcode.cn/problems/median-of-two-sorted-arrays/)\n>\n\n**思路一：**\n\n因为两个数组是自小到大排列的正序数组，我们只需找到所有元素的中间`1`或`2`个元素，并计算求得中位数即可。\n\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        i, j, p = 0, 0, 0\n        len1, len2 = len(nums1), len(nums2)\n        arr, max_size = [], (len1 + len2) // 2 + 1\n        while p < max_size:\n            if i < len1 and j < len2:\n                if nums1[i] < nums2[j]:\n                    arr.append(nums1[i])\n                    i += 1\n                else:\n                    arr.append(nums2[j])\n                    j += 1\n            else:\n                if i < len1:\n                    arr.append(nums1[i])\n                    i += 1\n                else:\n                    arr.append(nums2[j])\n                    j += 1\n            p += 1\n        if (len1 + len2) % 2 == 0:\n            return (arr[-1] + arr[-2]) / 2\n        return arr[-1]\n```\n\n**思路二：**\n\n我们不难将题目变形为查找整体数组中第`k`小的数。\n\n假设我们现在要从数组`A`与`B`中查找出第`k`小的数，我们比较`A[k / 2 - 1]`与`B[k / 2 - 1]` 的大小关系（下标从`0`开始计算）。不妨设`A[k / 2 - 1] ≤ B[k / 2 - 1]`，那么我们知道两个数组中比`A[k / 2 - 1]`小的数字最多有`(k / 2 - 1) * 2 = k - 2`个，因此我们可以直接得出结论：`A`数组中下标`0 ~ k / 2 - 1`的元素都可以舍去。那么接下来只需要找新数组中第`k - k / 2`小的数。\n\n```python\ndef find_k_element(nums1, nums2, k):\n    \"\"\" 寻找两个有序数组中第 k 小的数字，k 从 1 开始计算 \"\"\"\n    while k > 1 and nums1 and nums2:\n        len1 = len(nums1)\n        len2 = len(nums2)\n        idx = min(k // 2 - 1, len1 - 1, len2 - 1)\n        if nums1[idx] <= nums2[idx]:\n            nums1 = nums1[idx + 1:]\n        else:\n            nums2 = nums2[idx + 1:]\n        k -= (idx + 1)\n    if nums1 and nums2:\n        return min(nums1[0], nums2[0])\n    nums = nums1 if nums1 else nums2\n    return nums[k - 1]\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        size = len(nums1) + len(nums2)\n        mid = (size + 1) // 2\n        ans = find_k_element(nums1, nums2, mid)\n        if size % 2 == 1:\n            return ans\n        ans += find_k_element(nums1, nums2, mid + 1)\n        return ans / 2\n```\n\n#### 5. 最长回文子串\n给你一个字符串`s`，找到`s`中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n> [https://leetcode.cn/problems/longest-palindromic-substring/](https://leetcode.cn/problems/longest-palindromic-substring/)\n>\n\n**思路一：动态规划**\n\n长度为`1`的串本身就是回文串，长度为`2`的串若两个字符相同也是回文串。对于长度大于等于`3`的串，若满足**首尾相等且中间是回文串**则本身就是回文串。因此很轻易可以得出状态转移方程：\n\n![image](https://cdn.nlark.com/yuque/__latex/dfee18faf59423111ec2183eeaf0c8f1.svg)\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        length = len(s)\n        maxlen, maxitem = 1, s[0]\n        dp = [[True] * length for _ in range(length)]\n        for i in range(length - 2, -1, -1):\n            for j in range(i + 1, length):\n                dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]\n                if dp[i][j] and j - i + 1 > maxlen:\n                    maxitem = s[i: j + 1]\n                    maxlen = j - i + 1\n        return maxitem\n```\n\n**思路二：中心扩展法**\n\n对于每一个回文串来说，都有一个回文中心。奇数位的回文串中心是一个字符，偶数位的回文串中心是两个字符。我们可以穷举所有回文中心，然后向两边扩展，穷举过程中最长的串既是答案。\n\n```python\nclass Solution:\n    def expand(self, s, begin, end):\n        length = len(s)\n        while begin>= 0 and end < length and s[begin] == s[end]:\n            end += 1\n            begin -= 1\n        return begin, end\n\n    def longestPalindrome(self, s: str) -> str:\n        if not s: return \"\"\n        length = len(s)\n        maxlen, maxitem = 1, s[0]\n        for i in range(length - 1):\n            l1, r1 = self.expand(s, i, i)\n            l2, r2 = self.expand(s, i, i + 1)\n            if r1 - l1 - 1 > maxlen:\n                maxlen = r1 - l1 - 1\n                maxitem = s[l1 + 1: r1]\n            if r2 - l2 - 1 > maxlen:\n                maxlen = r2 - l2 - 1\n                maxitem = s[l2 + 1: r2]\n        return maxitem\n```\n\n#### 6. N 字形变换\n将一个给定字符串`s`根据给定的行数`numRows`，以从上往下、从左到右进行 N 字形排列。\n\n比如输入字符串为`PAYPALISHIRING`行数为`3`时，排列如下：\n\n```plain\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，上述案例返回：`PAHNAPLSIIGYIR`。\n\n> [https://leetcode.cn/problems/zigzag-conversion/](https://leetcode.cn/problems/zigzag-conversion/)\n>\n\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if not s or numRows <= 1: return s\n        flg, line = 1, 0\n        ans = [\"\" for _ in range(numRows)]\n        for ch in s:\n            ans[line] += ch\n            if line == 0: flg = 1\n            if line == numRows - 1: flg = -1\n            line += flg\n        return \'\'.join(ans)\n```\n\n#### 7. 整数反转\n给你一个 32 位的有符号整数`x`，返回将`x`中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围![image](https://cdn.nlark.com/yuque/__latex/dbe5c00e0ff1669cf581b1783f2354fe.svg)，就返回 0。\n\n**假设环境不允许存储 64 位整数（有符号或无符号）。**\n\n> [https://leetcode.cn/problems/reverse-integer/](https://leetcode.cn/problems/reverse-integer/)\n>\n\n**思路分析：**\n\n正数与负数情况相似，因此我们这边仅讨论正数。32 位正数的界限是`2147483647`，因为`x`是 32 位正数，因此`x`的位数必不大于 10，且`x`首位数字不会超过 2。我们需要判断`x`的逆序数`y`是否会越界，仅需判断`y`的前 9 位是否大于`214748364`。注意，负数转整数越界问题。\n\n```python\nclass Solution:\n    def reverse(self, x: int) -> int:\n        a = 2147483647\n        b = -2147483648\n        if x == b: return 0\n        ans, flg, r = 0, 1, a // 10\n        if x < 0:\n            x = -x\n            flg = -1\n        while x > 0:\n            t = x % 10\n            x = x // 10\n            ans = ans * 10 + t\n            # 前 9 位大于 r 说明会越界\n            if x > 0 and ans > r: return 0\n        return flg * ans\n```\n\n#### 8. 字符串转换整数（atoi）\n请你来实现一个`myAtoi(string s)`函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\n\n函数`myAtoi(string s)`的算法如下：\n\n1. 读入字符串并丢弃无用的前导空格\n2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n4. 将前面步骤读入的这些数字转换为整数（即，\"123\" -> 123， \"0032\" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n5. 如果整数数超过 32 位有符号整数范围![image](https://cdn.nlark.com/yuque/__latex/dbe5c00e0ff1669cf581b1783f2354fe.svg)，需要截断这个整数，使其保持在这个范围内。具体来说，小于![image](https://cdn.nlark.com/yuque/__latex/57abbcb10415b65a07a48c47541afd01.svg)的整数应该被固定为![image](data:image/svg+xml;utf8,%3Csvg%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%222.971ex%22%20height%3D%222.343ex%22%20style%3D%22vertical-align%3A%20-0.505ex%3B%22%20viewBox%3D%220%20-791.3%201279%201008.6%22%20role%3D%22img%22%20focusable%3D%22false%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20aria-labelledby%3D%22MathJax-SVG-1-Title%22%3E%0A%3Ctitle%20id%3D%22MathJax-SVG-1-Title%22%3EEquation%3C%2Ftitle%3E%0A%3Cdefs%20aria-hidden%3D%22true%22%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMAIN-2212%22%20d%3D%22M84%20237T84%20250T98%20270H679Q694%20262%20694%20250T679%20230H98Q84%20237%2084%20250Z%22%3E%3C%2Fpath%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMAIN-32%22%20d%3D%22M109%20429Q82%20429%2066%20447T50%20491Q50%20562%20103%20614T235%20666Q326%20666%20387%20610T449%20465Q449%20422%20429%20383T381%20315T301%20241Q265%20210%20201%20149L142%2093L218%2092Q375%2092%20385%2097Q392%2099%20409%20186V189H449V186Q448%20183%20436%2095T421%203V0H50V19V31Q50%2038%2056%2046T86%2081Q115%20113%20136%20137Q145%20147%20170%20174T204%20211T233%20244T261%20278T284%20308T305%20340T320%20369T333%20401T340%20431T343%20464Q343%20527%20309%20573T212%20619Q179%20619%20154%20602T119%20569T109%20550Q109%20549%20114%20549Q132%20549%20151%20535T170%20489Q170%20464%20154%20447T109%20429Z%22%3E%3C%2Fpath%3E%0A%3C%2Fdefs%3E%0A%3Cg%20stroke%3D%22currentColor%22%20fill%3D%22currentColor%22%20stroke-width%3D%220%22%20transform%3D%22matrix(1%200%200%20-1%200%200)%22%20aria-hidden%3D%22true%22%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMAIN-2212%22%20x%3D%220%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMAIN-32%22%20x%3D%22778%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%3C%2Fg%3E%0A%3C%2Fsvg%3E)，大于![image](https://cdn.nlark.com/yuque/__latex/e82645ec79264cff81109d47b25a3da7.svg)的整数应该被固定为![image](https://cdn.nlark.com/yuque/__latex/e82645ec79264cff81109d47b25a3da7.svg)。\n\n返回整数作为最终结果。\n\n> [https://leetcode.cn/problems/string-to-integer-atoi](https://leetcode.cn/problems/string-to-integer-atoi)\n>\n\n```python\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()\n        ans, flg = 0, 1\n        max_last, r = 7, 214748364\n        for i, ch in enumerate(s):\n            if ch in \"+-\":\n                if i > 0: break\n                if ch == \"+\": continue\n                flg = -1\n                max_last = 8\n            elif not ch.isdigit(): break\n            else:\n                t = int(ch)\n                if ans > r or (ans == r and t > max_last):\n                    return 2147483647 if flg > 0 else -2147483648\n                ans = ans * 10 + t\n        return flg * ans\n```\n\n#### 9. 回文数\n给你一个整数`x`，如果`x`是一个回文整数，返回`true`；否则，返回`false`。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，`121`是回文，而`123`不是。\n\n> [https://leetcode.cn/problems/palindrome-number](https://leetcode.cn/problems/palindrome-number)\n>\n\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0: return False\n        if x == 0: return True\n        if x % 10 == 0: return False\n        ans = 0\n        while ans < x:\n            ans = ans * 10 + x % 10\n            x //= 10\n        return ans == x or ans // 10 == x\n```\n\n#### 10. 正则表达式匹配\n给你一个字符串`s`和一个字符规律`p`，请你来实现一个支持`\'.\'`和`\'*\'`的正则表达式匹配。\n\n+ `\'.\'`匹配任意单个字符\n+ `\'*\'`匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖整个字符串`s`的，而不是部分字符串。\n\n这里有个坑：`a*`的解读并不是：开头一个`a`后面可以跟任意多个`a`；我们要把`a*`看做一个整体，表示这两个字符可以代替`0~INF`个`a`。\n\n> [https://leetcode.cn/problems/regular-expression-matching](https://leetcode.cn/problems/regular-expression-matching)\n>\n\n**思路分析：**\n\n我们认为字符串中的字符下标从 1 开始，`dp[i][j]`表示模式串`p[1-i]`能否匹配字符串`s[1-j]`。\n\n有以下两种情形：\n\n1. `p[i] != \'*\'`\n    - ![image](https://cdn.nlark.com/yuque/__latex/dd55e3ace9300fe01957473ec92dc652.svg)\n2. `p[i] == \'*\'`\n    - ![image](https://cdn.nlark.com/yuque/__latex/f84c963fcb0fa63c53bbb428d3497938.svg)\n\n至于下标为什么从 1 开始，`dp[0][j]`表示模式串是空串，类似的`dp[i][0]`表示字符串为空串的情况。显而易见有，`dp[0][0] = True, dp[0][j] = False`。\n\n```python\ndef match(ch1, ch2):\n    \"\"\" 判断两个字符是否匹配 \"\"\"\n    if \".\" in ch1 + ch2: return True\n    return ch1 == ch2\n\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(p), len(s)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        s, p = \" \" + s, \" \" + p\n        for i in range(1, m + 1):\n            for j in range(n + 1):\n                if p[i] != \"*\":\n                    if j == 0 or not match(p[i], s[j]): continue\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 2][j]\n                    if j > 0 and match(p[i - 1], s[j]):\n                        dp[i][j] |= dp[i][j - 1]\n        return dp[m][n]\n```\n\n#### 11. 盛最多水的容器\n给定一个长度为`n`的整数数组`height`。有`n`条垂线，第`i`条线的两个端点是`(i, 0)`和`(i, height[i])`。\n\n找出其中的两条线，使得它们与`x`轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。\n\n![](/yuque/0/2023/png/1561375/1679385334041-dd36db26-d70f-4ade-9d3b-9da0ad8351c4.png)\n\n> [https://leetcode.cn/problems/container-with-most-water](https://leetcode.cn/problems/container-with-most-water)\n>\n\n**思路解析：**\n\n容器的盛水量由短板决定，我们初始使用`i, j`位于数组两端，每次将较短的那一个下标往里面移动直到`i`与`j`相遇。至于为什么移动短板？因为移动长板必然导致水量变小，移动短板可能遇到更多水量。\n\n```python\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        ans = 0\n        i, j = 0, len(height) - 1\n        while i < j:\n            area = min(height[i], height[j]) * (j - i)\n            ans = max(ans, area)\n            if height[i] < height[j]: i += 1\n            else: j -= 1\n        return ans\n```\n\n#### 12. 整数转罗马数字\n罗马数字包含以下七种字符：`I`，`V`，`X`，`L`，`C`，`D`和`M`。\n\n```plain\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做`II`，即为两个并列的 1。12 写做`XII`，即为`X + II`。27 写做`XXVII`, 即为`XX + V + II`。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做`IIII`，而是`IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4。同样地，数字 9 表示为`IX`。这个特殊的规则只适用于以下六种情况：\n\n`I`可以放在`V`(5) 和`X`(10) 的左边，来表示 4 和 9。\n\n`X`可以放在`L`(50) 和`C`(100) 的左边，来表示 40 和 90。 \n\n`C`可以放在`D`(500) 和`M`(1000) 的左边，来表示 400 和 900。\n\n给你一个整数（`1 ≤ n ≤ 3999`），将其转为罗马数字。\n\n> [https://leetcode.cn/problems/integer-to-roman](https://leetcode.cn/problems/integer-to-roman)\n>\n\n```python\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        ge = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n        shi = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        bai = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        qian = [\"\", \"M\", \"MM\", \"MMM\"]\n        ans = qian[num // 1000] + bai[num // 100 % 10]\n        ans += (shi[num // 10 % 10] + ge[num % 10])\n        return ans\n```\n\n#### 13. 罗马数字转整数\n罗马数字包含以下七种字符：`I`，`V`，`X`，`L`，`C`，`D`和`M`。\n\n```plain\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做`II`，即为两个并列的 1。12 写做`XII`，即为`X + II`。27 写做`XXVII`, 即为`XX + V + II`。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做`IIII`，而是`IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4。同样地，数字 9 表示为`IX`。这个特殊的规则只适用于以下六种情况：\n\n`I`可以放在`V`(5) 和`X`(10) 的左边，来表示 4 和 9。\n\n`X`可以放在`L`(50) 和`C`(100) 的左边，来表示 40 和 90。 \n\n`C`可以放在`D`(500) 和`M`(1000) 的左边，来表示 400 和 900。\n\n给你一个罗马数字（对应整数范围：`1 ≤ n ≤ 3999`），将其转为整数。\n\n> [https://leetcode.cn/problems/roman-to-integer](https://leetcode.cn/problems/roman-to-integer/)\n>\n\n```python\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        ans, length = 0, len(s)\n        numap = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n        for i in range(1, length):\n            flg = -1 if numap[s[i]] > numap[s[i - 1]] else 1\n            ans += (flg * numap[s[i - 1]])\n        ans += numap[s[-1]]\n        return ans\n```\n\n#### 14. 最长公共前缀\n编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串`\"\"`。\n\n> [https://leetcode.cn/problems/longest-common-prefix/](https://leetcode.cn/problems/longest-common-prefix/)\n>\n\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        ans = \"\"\n        m, n = len(strs), len(strs[0])\n        for j in range(n):\n            for i in range(1, m):\n                if len(strs[i]) <= j: return ans\n                if strs[i][j] != strs[0][j]: return ans\n            ans += strs[0][j]\n        return ans\n```\n\n#### 15. 三数之和\n给你一个整数数组`nums`，判断是否存在三元组`[nums[i], nums[j], nums[k]]`满足`i != j`、`i != k`且`j != k`，同时还满足`nums[i] + nums[j] + nums[k] == 0`。请你返回所有和为 0 且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n> [https://leetcode.cn/problems/3sum](https://leetcode.cn/problems/3sum)\n>\n\n**思路分析：**\n\n我们先对数组排序，为了防止重复，我们令`a ≤ b ≤ c`且有`a + b + c = 0`。接着我们将`b`变为`b\'`，如果还想满足条件，那么`c`必减少。所以，我们发现遍历整个数组的时候，仅需要完全遍历`a`，`b`与`c`的遍历是并行向内的。\n\n注意，`a、b、c`的遍历不能重复。\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans, n = [], len(nums)\n        for i, a in enumerate(nums):\n            if a > 0: break\n            if i > 0 and a == nums[i - 1]: continue\n            l, r = i + 1, n - 1\n            while l < r:\n                t = a + nums[l] + nums[r]\n                if t > 0: r -= 1\n                elif t < 0: l += 1\n                else:\n                    ans.append([a, nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l + 1]: l += 1\n                    while l < r and nums[r] == nums[r - 1]: r -= 1\n                    l += 1\n                    r -= 1\n        return ans\n```\n\n#### 16. 最接近的三数之和\n给你一个长度为`n`的整数数组`nums`和 一个目标值`target`。请你从`nums`中选出三个整数，使它们的和与`target`最接近，返回这三个数的和。\n\n> [https://leetcode.cn/problems/3sum-closest](https://leetcode.cn/problems/3sum-closest)\n>\n\n```python\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        length = len(nums)\n        ans, diff = -1, -1\n        for i in range(length):\n            if i > 0 and nums[i] == nums[i - 1]: continue\n            l, r = i + 1, length - 1\n            while l < r:\n                v = nums[i] + nums[l] + nums[r]\n                if diff < 0 or diff > abs(v - target):\n                    ans = v\n                    diff = abs(v - target)\n                if v < target: l += 1\n                elif v > target: r -= 1\n                else: return target\n        return ans\n```\n\n#### 17. 电话号码的字母组合\n给定一个仅包含数字`2-9`的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意`1`不对应任何字母。\n\n![](/yuque/0/2023/png/1561375/1679471108548-b974ea61-2d3c-44e5-935c-c9408d2b29b4.png)\n\n> [https://leetcode.cn/problems/letter-combinations-of-a-phone-number](https://leetcode.cn/problems/letter-combinations-of-a-phone-number)\n>\n\n```python\nclass Solution:\n    ans = []\n    alphamap = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\",\n                \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\n\n    def dfs(self, prefix, digit):\n        if not digit:\n            if prefix: self.ans.append(prefix)\n            return\n        for alpha in self.alphamap[digit[0]]:\n            self.dfs(prefix + alpha, digit[1:])\n\n    def letterCombinations(self, digits: str) -> List[str]:\n        self.ans.clear()\n        self.dfs(\"\", digits)\n        return self.ans\n```\n\n#### 18. 四数之和\n给你一个由`n`个整数组成的数组`nums`，和一个目标值`target`。请你找出并返回满足下述全部条件且不重复的四元组`[nums[a], nums[b], nums[c], nums[d]]`（若两个四元组元素一一对应，则认为两个四元组重复）：\n\n+ `0 <= a, b, c, d < n`\n+ `a`、`b`、`c`和`d`互不相同\n+ `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\n你可以按任意顺序返回答案。\n\n> [https://leetcode.cn/problems/4sum](https://leetcode.cn/problems/4sum)\n>\n\n```python\nclass Solution:\n    def threeSum(self, nums, target):\n        \"\"\" 挑三个数的和等于 target \"\"\"\n        ans = []\n        n = len(nums)\n        for i in range(n - 2):\n            if sum(nums[i: i + 3]) > target: break\n            if i > 0 and nums[i] == nums[i - 1]: continue\n            if nums[i] + sum(nums[-2:]) < target: continue\n            l, r = i + 1, n - 1\n            while l < r:\n                t = nums[i] + nums[l] + nums[r]\n                if t < target: l += 1\n                elif t > target: r -= 1\n                else:\n                    ans.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l + 1]: l += 1\n                    while l < r and nums[r] == nums[r - 1]: r -= 1\n                    l += 1\n                    r -= 1\n        return ans\n\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        ans = []\n        n = len(nums)\n        nums.sort()\n        for i in range(n - 3):\n            if sum(nums[i: i + 4]) > target: break\n            if i > 0 and nums[i] == nums[i - 1]: continue\n            if nums[i] + sum(nums[-3:]) < target: continue\n            three_ans = self.threeSum(nums[i + 1:], target - nums[i])\n            ans.extend(map(lambda x: [nums[i]] + x, three_ans))\n        return ans\n```\n\n#### 19. 删除链表的倒数第 N 个节点\n给你一个链表，删除链表的倒数第`n`个结点，并且返回链表的头结点。\n\n> [https://leetcode.cn/problems/remove-nth-node-from-end-of-list/](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n>\n\n```python\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        h = ListNode(next=head)\n        p1, p2 = h, h\n        for i in range(n): p1 = p1.next\n        while p1.next:\n            p1 = p1.next\n            p2 = p2.next\n        p2.next = p2.next.next\n        return h.next\n```\n\n#### 20. 有效的括号\n给定一个只包括`\'(\'`，`\')\'`，`\'{\'`，`\'}\'`，`\'[\'`，`\']\'`的字符串`s`，判断字符串是否有效。\n\n有效字符串需满足：\n\n+ 左括号必须用相同类型的右括号闭合。\n+ 左括号必须以正确的顺序闭合。\n+ 每个右括号都有一个对应的相同类型的左括号。\n\n> [https://leetcode.cn/problems/valid-parentheses](https://leetcode.cn/problems/valid-parentheses)\n>\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        chmap = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        for ch in s:\n            if ch in \"([{\": stack.append(ch)\n            else:\n                if len(stack) == 0: return False\n                if stack[-1] != chmap[ch]: return False\n                del stack[-1]\n        return len(stack) == 0\n```\n\n#### 21. 合并两个有序链表\n将两个升序链表合并为一个新的**升序**链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n> [https://leetcode.cn/problems/merge-two-sorted-lists/](https://leetcode.cn/problems/merge-two-sorted-lists/)\n>\n\n```python\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        head = ListNode()\n        p = head\n        while list1 and list2:\n            if list1.val < list2.val:\n                p.next = list1\n                list1 = list1.next\n            else:\n                p.next = list2\n                list2 = list2.next\n            p = p.next\n        if list1: p.next = list1\n        if list2: p.next = list2\n        return head.next\n```\n\n#### 22. 括号生成\n数字`n`代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且**有效的**括号组合。\n\n> [https://leetcode.cn/problems/generate-parentheses/](https://leetcode.cn/problems/generate-parentheses/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.n = 0\n        self.left = 0\n        self.right = 0\n\n    def dfs(self, prefix, k):\n        \"\"\" 填第 k（从 0 开始）个位置的字符 \"\"\"\n        if k == self.n * 2:\n            self.ans.append(prefix)\n            return\n        if self.left < self.n:\n            self.left += 1\n            self.dfs(prefix + \"(\", k + 1)\n            self.left -= 1\n        if self.right < self.left:\n            self.right += 1\n            self.dfs(prefix + \")\", k + 1)\n            self.right -= 1\n\n    def generateParenthesis(self, n: int) -> List[str]:\n        self.n = n\n        self.ans.clear()\n        self.dfs(\"\", 0)\n        return self.ans\n```\n\n#### 23. 合并 K 个升序链表\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n> [https://leetcode.cn/problems/merge-k-sorted-lists/](https://leetcode.cn/problems/merge-k-sorted-lists/)\n>\n\n```python\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        head = ListNode()\n        p = head\n        while list1 and list2:\n            if list1.val < list2.val:\n                p.next = list1\n                list1 = list1.next\n            else:\n                p.next = list2\n                list2 = list2.next\n            p = p.next\n        if list1: p.next = list1\n        if list2: p.next = list2\n        return head.next\n\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        n = len(lists)\n        if n == 0: return None\n        if n == 1: return lists[0]\n        head = lists[0]\n        for i in range(1, n):\n            head = self.mergeTwoLists(head, lists[i])\n        return head\n```\n\n#### 24. 两两交换链表中的节点\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n![](/yuque/0/2023/png/1561375/1679507910385-1e5c9199-55ab-45b6-ad2c-48a6983419bd.png)\n\n> [https://leetcode.cn/problems/swap-nodes-in-pairs/](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n>\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        h = ListNode(next=head)\n        tail = h\n        while tail.next and tail.next.next:\n            p = tail.next.next\n            tail.next.next = p.next\n            p.next = tail.next\n            tail.next = p\n            tail = tail.next.next\n        return h.next\n```\n\n#### 25. K 个一组翻转链表\n给你链表的头节点`head`，每`k`个节点一组进行翻转，请你返回修改后的链表。\n\n`k`是一个正整数，它的值小于或等于链表的长度。如果节点总数不是`k`的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n> [https://leetcode.cn/problems/reverse-nodes-in-k-group](https://leetcode.cn/problems/reverse-nodes-in-k-group)\n>\n\n```python\nclass Solution:\n    def reverse(self, p, q):\n        head = ListNode()\n        r, tail = p, p\n        while r != q:\n            r = r.next\n            p.next = head.next\n            head.next = p\n            p = r\n        return head.next, None if tail == q else tail\n\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k <= 1: return head\n        if head is None: return None\n        p, q = head, head\n        h = ListNode()\n        t = h\n        while True:\n            for i in range(k):\n                if not q: break\n                q = q.next\n            else: i += 1\n            if i < k: break\n            t.next, tail = self.reverse(p, q)\n            t = tail\n            p = q\n        if p is not None: t.next = p\n        return h.next\n```\n\n#### 26. 删除有序数组中的重复项\n给你一个升序排列的数组`nums`，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。\n\n> [https://leetcode.cn/problems/remove-duplicates-from-sorted-array](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)\n>\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        p, n = 1, len(nums)\n        if n <= 1: return n\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]: continue\n            nums[p] = nums[i]\n            p += 1\n        return p\n```\n\n#### 27. 移除元素\n给你一个数组`nums`和一个值`val`，你需要原地移除所有数值等于`val`的元素，并返回移除后数组的新长度。\n\n> [https://leetcode.cn/problems/remove-element/](https://leetcode.cn/problems/remove-element/)\n>\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        p, n = 0, len(nums)\n        for i in range(n):\n            if nums[i] == val: continue\n            nums[p] = nums[i]\n            p += 1\n        return p\n```\n\n#### 28. 找出字符串中第一个匹配项的下标\n给你两个字符串`haystack`和`needle`，请你在`haystack`字符串中找出`needle`字符串的第一个匹配项的下标（下标从 0 开始）。如果`needle`不是`haystack`的一部分，则返回` -1`。\n\n> [https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)\n>\n\n```python\nclass Solution:\n    def get_next(self, pattern):\n        n = len(pattern)\n        i, pre, nxt = 1, 0, [0] * n\n        while i < n:\n            if pattern[pre] == pattern[i]:\n                i += 1\n                pre += 1\n                nxt[i - 1] = pre\n            elif pre != 0: pre = nxt[pre - 1]\n            else:\n                i += 1\n                nxt[i - 1] = 0\n        return nxt\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        m, n = len(haystack), len(needle)\n        if m < n: return -1\n        i, j = 0, 0\n        nxt = self.get_next(needle)\n        while i < m:\n            if haystack[i] == needle[j]:\n                i += 1\n                j += 1\n            elif j != 0: j = nxt[j - 1]\n            else: i += 1\n            if j == n: return i - j\n        return -1\n```\n\n#### 29. 两数相除\n给你两个整数，被除数`dividend`和除数`divisor`。将两数相除，要求不使用乘法、除法和取余运算。\n\n整数除法应该向零截断，也就是截去（`truncate`）其小数部分。例如，8.345 将被截断为 8，-2.7335 将被截断至 -2。返回被除数`dividend`除以除数`divisor`得到的商 。\n\n注意：假设我们的环境只能存储 32 位有符号整数，其数值范围是![image](https://cdn.nlark.com/yuque/__latex/dbe5c00e0ff1669cf581b1783f2354fe.svg)。本题中，如果商严格大于![image](https://cdn.nlark.com/yuque/__latex/e82645ec79264cff81109d47b25a3da7.svg)，则返回![image](data:image/svg+xml;utf8,%3Csvg%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%220%22%20height%3D%220.343ex%22%20style%3D%22vertical-align%3A%20-0.171ex%3B%22%20viewBox%3D%220%20-73.8%200%20147.5%22%20role%3D%22img%22%20focusable%3D%22false%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20aria-labelledby%3D%22MathJax-SVG-1-Title%22%3E%0A%3Ctitle%20id%3D%22MathJax-SVG-1-Title%22%3EEquation%3C%2Ftitle%3E%0A%3Cdefs%20aria-hidden%3D%22true%22%3E%3C%2Fdefs%3E%0A%3Cg%20stroke%3D%22currentColor%22%20fill%3D%22currentColor%22%20stroke-width%3D%220%22%20transform%3D%22matrix(1%200%200%20-1%200%200)%22%20aria-hidden%3D%22true%22%3E%3C%2Fg%3E%0A%3C%2Fsvg%3E)；如果商严格小于![image](https://cdn.nlark.com/yuque/__latex/57abbcb10415b65a07a48c47541afd01.svg)，则返回![image](data:image/svg+xml;utf8,%3Csvg%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%222.971ex%22%20height%3D%222.343ex%22%20style%3D%22vertical-align%3A%20-0.505ex%3B%22%20viewBox%3D%220%20-791.3%201279%201008.6%22%20role%3D%22img%22%20focusable%3D%22false%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20aria-labelledby%3D%22MathJax-SVG-1-Title%22%3E%0A%3Ctitle%20id%3D%22MathJax-SVG-1-Title%22%3EEquation%3C%2Ftitle%3E%0A%3Cdefs%20aria-hidden%3D%22true%22%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMAIN-2212%22%20d%3D%22M84%20237T84%20250T98%20270H679Q694%20262%20694%20250T679%20230H98Q84%20237%2084%20250Z%22%3E%3C%2Fpath%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMAIN-32%22%20d%3D%22M109%20429Q82%20429%2066%20447T50%20491Q50%20562%20103%20614T235%20666Q326%20666%20387%20610T449%20465Q449%20422%20429%20383T381%20315T301%20241Q265%20210%20201%20149L142%2093L218%2092Q375%2092%20385%2097Q392%2099%20409%20186V189H449V186Q448%20183%20436%2095T421%203V0H50V19V31Q50%2038%2056%2046T86%2081Q115%20113%20136%20137Q145%20147%20170%20174T204%20211T233%20244T261%20278T284%20308T305%20340T320%20369T333%20401T340%20431T343%20464Q343%20527%20309%20573T212%20619Q179%20619%20154%20602T119%20569T109%20550Q109%20549%20114%20549Q132%20549%20151%20535T170%20489Q170%20464%20154%20447T109%20429Z%22%3E%3C%2Fpath%3E%0A%3C%2Fdefs%3E%0A%3Cg%20stroke%3D%22currentColor%22%20fill%3D%22currentColor%22%20stroke-width%3D%220%22%20transform%3D%22matrix(1%200%200%20-1%200%200)%22%20aria-hidden%3D%22true%22%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMAIN-2212%22%20x%3D%220%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMAIN-32%22%20x%3D%22778%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%3C%2Fg%3E%0A%3C%2Fsvg%3E)。\n\n> [https://leetcode.cn/problems/divide-two-integers](https://leetcode.cn/problems/divide-two-integers)\n>\n\n```python\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        MIN = -2 ** 31\n        MAX = 2 ** 31 - 1\n        if dividend == MIN and divisor == -1: return MAX\n\n        ans, flg = 0, True\n        if divisor < 0: flg = not flg\n        else: divisor = -divisor\n        if dividend < 0: flg = not flg\n        else: dividend = -dividend\n\n        while dividend <= divisor:\n            res, tmp = 1, divisor\n            while tmp > dividend - tmp:\n                tmp += tmp\n                res += res\n            ans += res\n            dividend -= tmp\n        return ans if flg else -ans\n```\n\n#### 30. 串联所有单词的子串\n给定一个字符串`s`和一个字符串数组`words`。`words`中所有字符串长度相同。\n\n`s`中的串联子串是指一个包含`words`中所有字符串以任意顺序排列连接起来的子串。\n\n例如，如果`words = [\"ab\",\"cd\",\"ef\"]`， 那么`\"abcdef\"`，`\"abefcd\"`，`\"cdabef\"`，`\"cdefab\"`，`\"efabcd\"`，和`\"efcdab\"`都是串联子串。`\"acdbef\"`不是串联子串，因为他不是任何`words`排列的连接。\n\n返回所有串联字串在`s`中的开始索引。你可以以任意顺序返回答案。\n\n> [https://leetcode.cn/problems/substring-with-concatenation-of-all-words](https://leetcode.cn/problems/substring-with-concatenation-of-all-words)\n>\n\n**思路一：**\n\n遍历每一个长度为`m * n`的子串，通过字典判断单词出现次数是否相同。\n\n```python\ndef same(s, word_map, m, n):\n    for i in range(n):\n        word = s[i * m: (i + 1) * m]\n        times = word_map.get(word, 0)\n        if times <= 0: return False\n        if times == 1: del word_map[word]\n        else: word_map[word] = times - 1\n    return len(word_map) == 0\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        m, n = len(words[0]), len(words)\n        i, len_sub, ls = 0, m * n, len(s)\n        if ls < len_sub: return []\n        ans, word_map = [], {}\n        for word in words:\n            word_map[word] = word_map.get(word, 0) + 1\n        while i + len_sub <= ls:\n            if same(s[i: i + len_sub], word_map.copy(), m, n):\n                ans.append(i)\n            i += 1\n        return ans\n```\n\n**思路二：**\n\n子串之间单词存在大量重复，使用方法一则无视了这部分。使用滑动窗口方法，窗口长度为`m * n`，每次移动一个单词长度，`map`中每次去掉第一个单词，添加最后一个单词。\n\n```python\ndef scan(s, words_map, m, n, bias):\n    ans = []\n    cnt = len(s) // m\n    if cnt < n: return ans\n    for i in range(cnt):\n        word = s[i * m: (i + 1) * m]\n        if i >= n:\n            head_idx = (i - n) * m\n            if len(words_map) == 0: ans.append(head_idx + bias)\n            head = s[head_idx: head_idx + m]\n            words_map[head] = words_map.get(head, 0) + 1\n            if words_map[head] == 0: del words_map[head]\n        words_map[word] = words_map.get(word, 0) - 1\n        if words_map[word] == 0: del words_map[word]\n    if len(words_map) == 0: ans.append((i - n + 1) * m + bias)\n    return ans\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n, m = len(words), len(words[0])\n        i, lens, lensub = 0, len(s), m * n\n        if lens < lensub: return []\n        ans, words_map = [], {}\n        for word in words:\n            words_map[word] = words_map.get(word, 0) + 1\n        for i in range(m):\n            ans.extend(scan(s[i: ], words_map.copy(), m, n, i))\n        return ans\n```\n\n#### 31. 下一个排列\n整数数组的一个排列就是将其所有成员以序列或线性顺序排列。\n\n例如，`arr = [1,2,3]`，以下这些都可以视作`arr`的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]`。\n\n整数数组的下一个排列是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的下一个排列就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n例如，`arr = [1,2,3]`的下一个排列是`[1,3,2]`。类似地，`arr = [2,3,1]`的下一个排列是`[3,1,2]`。而`arr = [3,2,1]`的下一个排列是`[1,2,3]`，因为`[3,2,1]`不存在一个字典序更大的排列。\n\n给你一个整数数组`nums`，找出`nums`的下一个排列。必须原地修改，只允许使用额外常数空间。\n\n> [https://leetcode.cn/problems/next-permutation](https://leetcode.cn/problems/next-permutation)\n>\n\n**思路分析：**\n\n对于任意一个排列，想要生成一个比它大的排列，那么必然需要从排列左端选择一个数与右边一个较大的数交换。为了保证变大的幅度尽可能的小，所以需要选择较小数的时候尽可能靠右，因此本题做法可以归纳为：\n\n1. 从右到左找第一个顺序组合，即满足`nums[i] < nums[i + 1]`的最大的`i`。\n2. 从右到左找第一个比`nums[i]`大的数，这样可以保证这个数是比`nums[i]`大的最小的数。\n3. 交换`nums[i]`与`nums[j]`并将第`i`位后面的数字按照从小到大的顺序排列。\n\n做最后一步的时候，第`i`位后面的数字必然是从大到小排列的。\n\n```python\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        i, j = n - 2, n - 1\n        while i >= 0 and nums[i] >= nums[i + 1]: i -= 1\n        if i >= 0:\n            while j >= 0 and nums[j] <= nums[i]: j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        i, j = i + 1, n - 1\n        while i < j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n```\n\n#### 32. 最长有效括号\n给你一个只包含`\'(\'`和`\')\'`的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n> [https://leetcode.cn/problems/longest-valid-parentheses/](https://leetcode.cn/problems/longest-valid-parentheses/)\n>\n\n**思路一：动态规划**\n\n假设`dp[i]`表示以第`i`个字符结尾的有效括号的最长长度。\n\n1. 若`s[i] == \'(\'`则`dp[i] = 0`\n2. 若`s[i] == \')\'`\n    1. 若`s[i - 1] == \'(\'`则`dp[i] = 2 + dp[i - 2]`\n    2. 若`s[i - 1] == \')\'`\n        1. 若`s[i - dp[i - 1] - 1] == \')\'`则`dp[i] = 0`\n        2. 若`s[i - dp[i - 1] - 1] == \'(\'`则`dp[i] = 2 + dp[i - 1] + dp[i - dp[i - 1] - 2]`\n\n```python\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * n\n        if n == 0: return 0\n\n        def get_dp(i):\n            return 0 if i < 0 else dp[i]\n        \n        for i in range(1, n):\n            if s[i] == \'(\': continue\n            if s[i - 1] == \'(\': \n                dp[i] = 2 + get_dp(i - 2)\n                continue\n            idx = i - get_dp(i - 1) - 1\n            if idx >= 0 and s[idx] == \'(\':\n                dp[i] = 2 + get_dp(i - 1) + get_dp(idx - 1)\n        return max(dp)\n```\n\n**思路二：栈模拟**\n\n栈底记录这扫描到的下标最大的`\')\'`的下标，以后：\n\n1. 遇到`\'(\'`直接将它的下标入栈\n2. 遇到`\')\'`则判断栈顶：\n    1. 栈顶为`\'(\'`，出栈并计算长度\n    2. 否则，替换掉栈底里面存的下标\n\n为什么需要记录最近的`\')\'`下标？因为我们要计算最长的长度，仔细看下面的代码，尤其是计算长度的那一块代码。\n\n```python\nclass Stack:\n    def __init__(self):\n        self.__arr = []\n\n    def empty(self):\n        return len(self.__arr) == 0\n\n    def peek(self):\n        if self.empty():\n            raise IndexError\n        return self.__arr[-1]\n\n    def pop(self):\n        if self.empty():\n            raise IndexError\n        item = self.peek()\n        del self.__arr[-1]\n        return item\n\n    def push(self, item):\n        self.__arr.append(item)\n\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        ans = 0\n        stack = Stack()\n        stack.push(-1)\n        for i, ch in enumerate(s):\n            if ch == \'(\':\n                stack.push(i)\n                continue\n            stack.pop()\n            if stack.empty():\n                stack.push(i)\n                continue\n            ans = max(ans, i - stack.peek())\n        return ans\n```\n\n#### 33. 搜索旋转排序数组\n整数数组`nums`按升序排列，数组中的值互不相同 。\n\n在传递给函数之前，`nums`在预先未知的某个下标`k`（`0 <= k < nums.length`）上进行了旋转，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从`0`开始计数）。例如，`[0,1,2,4,5,6,7]`在下标`3`处经旋转后变为`[4,5,6,7,0,1,2]` 。\n\n给你旋转后的数组`nums`和一个整数`target`，如果`nums`中存在这个目标值`target`，则返回它的下标，否则返回`-1`。\n\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n\n> [https://leetcode.cn/problems/search-in-rotated-sorted-array](https://leetcode.cn/problems/search-in-rotated-sorted-array)\n>\n\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target: return mid\n            if l == r: break\n            if nums[l] < nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else: r = mid - 1\n            else:\n                if target > nums[r] or target < nums[mid + 1]:\n                    r = mid\n                else: l = mid + 1\n        return -1\n```\n\n#### 34. 在排序数组中查找元素的第一个和最后一个位置\n给你一个按照非递减顺序排列的整数数组`nums`，和一个目标值`target`。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。\n\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n\n> [https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array)\n>\n\n```python\nclass Solution:\n    def search(self, nums, target, find_small):\n        pos = -1\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                pos = mid\n                if find_small: r = mid - 1\n                else: l = mid + 1\n            elif nums[mid] > target: r = mid - 1\n            else: l = mid + 1\n        return pos\n\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        a = self.search(nums, target, True)\n        b = self.search(nums, target, False)\n        return [a, b]\n```\n\n#### 35. 搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为`O(log n)`的算法。\n\n> [https://leetcode.cn/problems/search-insert-position](https://leetcode.cn/problems/search-insert-position)\n>\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target: return mid\n            if nums[mid] < target: l = mid + 1\n            else: r = mid - 1\n        return l\n```\n\n#### 36. 有效的数独\n请你判断一个`9 x 9`的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。\n\n1. 数字`1-9`在每一行只能出现一次。\n2. 数字`1-9`在每一列只能出现一次。\n3. 数字`1-9`在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n\n> [https://leetcode.cn/problems/valid-sudoku](https://leetcode.cn/problems/valid-sudoku)\n>\n\n```python\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows, cols = 9, 9\n        col_set = [set() for _ in range(9)]\n        area_set = [set() for _ in range(9)]\n        for r in range(rows):\n            row = list(filter(lambda x: x != \".\", board[r]))\n            if len(set(row)) < len(row): return False\n            for c in range(cols):\n                ch = board[r][c]\n                if ch == \".\": continue\n                if ch in col_set[c]: return False\n                col_set[c].add(ch)\n                idx = (r // 3) * 3 + c // 3\n                if ch in area_set[idx]: return False\n                area_set[idx].add(ch)\n        return True\n```\n\n#### 37. 解数独\n编写一个程序，通过填充空格来解决数独问题。\n\n数独的解法需遵循如下规则：\n\n1. 数字`1-9`在每一行只能出现一次。\n2. 数字`1-9`在每一列只能出现一次。\n3. 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次。\n\n数独部分空格内已填入了数字，空白格用`\'.\'`表示。\n\n> [https://leetcode.cn/problems/sudoku-solver](https://leetcode.cn/problems/sudoku-solver)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.board = None\n        self.found = False\n\n    def check(self, row, col, num):\n        \"\"\" 判断在位置 (row, col) 处填入 num 是否合理 \"\"\"\n        if num in self.board[row]: return False\n        if num in list(map(lambda x: x[col], self.board)): return False\n        begin_row, begin_col = (row // 3) * 3, (col // 3) * 3\n        for i in range(begin_row, begin_row + 3):\n            for j in range(begin_col, begin_col + 3):\n                if self.board[i][j] == num: return False\n        return True\n\n    def location(self):\n        \"\"\" 查询第一个 . 的位置 \"\"\"\n        for row in range(9):\n            for col in range(9):\n                if self.board[row][col] == \".\": return row, col\n        return -1, -1\n\n    def dfs(self, row, col):\n        \"\"\" 使用回溯判断每种情况 \"\"\"\n        for i in range(1, 10):\n            if not self.check(row, col, f\"{i}\"): continue\n            self.board[row][col] = f\"{i}\"\n            r, c = self.location()\n            if r < 0:\n                self.found = True\n                return\n            self.dfs(r, c)\n            if self.found: return\n            self.board[row][col] = \".\"\n\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        self.found = False\n        self.board = board\n        r, c = self.location()\n        if r < 0: return\n        self.dfs(r, c)\n```\n\n#### 38. 外观数列\n给定一个正整数`n`，输出外观数列的第`n`项。\n\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\n\n你可以将其视作是由递归公式定义的数字字符串序列：\n\n+ `countAndSay(1) = \"1\"`\n+ `countAndSay(n)`是对`countAndSay(n-1)`的描述，然后转换成另一个数字字符串。\n\n前五项如下：\n\n```python\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n第一项是数字 1 \n描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \"11\"\n描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \"21\"\n描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 \"1211\"\n描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \"111221\"\n```\n\n要描述一个数字字符串，首先要将字符串分割为最小数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\n\n> [https://leetcode.cn/problems/count-and-say](https://leetcode.cn/problems/count-and-say)\n>\n\n```python\ndef describe(string):\n    ans = \"\"\n    i, j, n = 0, 0, len(string)\n    while j < n:\n        while j < n and string[i] == string[j]: j += 1\n        ans += f\"{j - i}\"\n        ans += string[i]\n        i = j\n    return ans\n\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        ans = \"1\"\n        for _ in range(n - 1):\n            ans = describe(ans)\n        return ans\n```\n\n#### 39. 组合总和\n给你一个无重复元素的整数数组`candidates`和一个目标整数`target`，找出`candidates`中可以使数字和为目标数`target`的所有不同组合 ，并以列表形式返回。你可以按任意顺序返回这些组合。\n\n`candidates`中的同一个数字可以无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n\n> [https://leetcode.cn/problems/combination-sum](https://leetcode.cn/problems/combination-sum)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n        self.candidates = None\n\n    def dfs(self, begin, target):\n        \"\"\" 从 self.candidates 中挑选一个序列使其和为 target \"\"\"\n        if target == 0:\n            self.ans.append(self.path[:])\n            return\n        for i, item in enumerate(self.candidates[begin:]):\n            if item > target: continue\n            self.path.append(item)\n            self.dfs(begin + i, target - item)\n            self.path.pop()\n\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        self.ans.clear()\n        self.path.clear()\n        self.candidates = candidates\n        self.dfs(0, target)\n        return self.ans\n```\n\n#### 40. 组合总和Ⅱ\n给定一个候选人编号的集合`candidates`和一个目标数`target`，找出`candidates`中所有可以使数字和为`target`的组合。`candidates`中的每个数字在每个组合中只能使用 一次 。\n\n注意：解集不能包含重复的组合。 \n\n> [https://leetcode.cn/problems/combination-sum-ii](https://leetcode.cn/problems/combination-sum-ii)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n        self.candidates = None\n\n    def dfs(self, begin, target):\n        \"\"\" 从 self.candidates 中挑选一个序列使其和为 target \"\"\"\n        if target == 0:\n            self.ans.append(self.path[:])\n            return\n        candidates = self.candidates[begin:]\n        for i, item in enumerate(candidates):\n            if item > target: continue\n            if i > 0 and item == candidates[i - 1]: continue\n            self.path.append(item)\n            self.dfs(begin + i + 1, target - item)\n            self.path.pop()\n\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        self.ans.clear()\n        self.path.clear()\n        self.candidates = candidates\n        self.candidates.sort()\n        self.dfs(0, target)\n        return self.ans\n```\n\n#### 41. 缺失的第一个正数\n给你一个未排序的整数数组`nums`，请你找出其中没有出现的最小的正整数。\n\n请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。\n\n> [https://leetcode.cn/problems/first-missing-positive/](https://leetcode.cn/problems/first-missing-positive/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.nums = None\n\n    def location(self, i):\n        \"\"\" 第 i 个元素开始归位 \"\"\"\n        carrot = self.nums[i] - 1\n        while True:\n            tmp = self.nums[carrot]\n            self.nums[carrot] = -1\n            if tmp < 1 or tmp > self.n: break\n            carrot = tmp - 1\n\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        self.nums = nums\n        self.n = len(nums)\n        for i in range(self.n):\n            if 0 < nums[i] <= self.n: continue\n            nums[i] = self.n + 1\n        for i in range(self.n):\n            if nums[i] < 1 or nums[i] > self.n: continue\n            self.location(i)\n        for i in range(self.n):\n            if nums[i] >= 0: return i + 1\n        return self.n + 1\n```\n\n#### 42. 接雨水\n给定`n`个非负整数表示每个宽度为`1`的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![](/yuque/0/2023/png/1561375/1680533253928-a3e24426-9a9a-4f4a-9f9b-0c5cbc3f7295.png)\n\n> [https://leetcode.cn/problems/trapping-rain-water/](https://leetcode.cn/problems/trapping-rain-water/)\n>\n\n```python\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        ans, lmax, rmax = 0, 0, 0\n        l, r = 0, len(height) - 1\n        while l < r:\n            lmax = max(lmax, height[l])\n            rmax = max(rmax, height[r])\n            if height[l] < height[r]:\n                ans += (lmax - height[l])\n                l += 1\n            else:\n                ans += (rmax - height[r])\n                r -= 1\n        return ans\n```\n\n#### 43. 字符串相乘\n给定两个以字符串形式表示的非负整数`num1`和`num2`，返回`num1`和`num2`的乘积，它们的乘积也表示为字符串形式。\n\n**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\n\n> [https://leetcode.cn/problems/multiply-strings/](https://leetcode.cn/problems/multiply-strings/)\n>\n\n```python\ndef add(num1, num2):\n    \"\"\" 模拟两个整数相加 \"\"\"\n    ans, flg = \"\", 0\n    i = len(num1) - 1\n    j = len(num2) - 1\n    while i >= 0 or j >= 0:\n        a = 0 if i < 0 else int(num1[i])\n        b = 0 if j < 0 else int(num2[j])\n        res = a + b + flg\n        if res > 9:\n            flg = 1\n            res -= 10\n        else:\n            flg = 0\n        ans = f\"{res}\" + ans\n        i -= 1\n        j -= 1\n    if flg > 0: ans = \"1\" + ans\n    return ans\n\n\ndef multiply_one(num1, k):\n    \"\"\" 模拟多位数乘以一位数 \"\"\"\n    if num1 == \"0\" or k == 0: return \"0\"\n    i, flg, ans = len(num1) - 1, 0, \"\"\n    while i >= 0:\n        res = int(num1[i]) * k + flg\n        if res > 9:\n            flg = res // 10\n            res %= 10\n        else: flg = 0\n        ans = f\"{res}\" + ans\n        i -= 1\n    if flg > 0: ans = f\"{flg}\" + ans\n    return ans\n\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\": return \"0\"\n        n = len(num2) - 1\n        j = len(num2) - 2\n        ans = multiply_one(num1, int(num2[-1]))\n        while j >= 0:\n            b = multiply_one(num1, int(num2[j]))\n            b += \"0\" * (n - j)\n            ans = add(ans, b)\n            j -= 1\n        return ans\n```\n\n#### 44. 通配符匹配\n给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持`\'?\'`和`\'*\'`匹配规则的通配符匹配：\n\n+ `\'?\'`可以匹配任何单个字符。\n+ `\'*\'`可以匹配任意字符序列（包括空字符序列）。\n\n判定匹配成功的充要条件是：字符模式必须能够完全匹配输入字符串（而不是部分匹配）。\n\n> [https://leetcode.cn/problems/wildcard-matching](https://leetcode.cn/problems/wildcard-matching)\n>\n\n```python\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        p = \" \" + p\n        s = \" \" + s\n        m, n = len(s) - 1, len(p) - 1\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(1, n + 1):\n            for j in range(m + 1):\n                if p[i] != \"*\":\n                    if j == 0: continue\n                    if p[i] not in \"?*\" and p[i] != s[j]: continue\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    if j == 0:\n                        dp[i][j] = dp[i - 1][j]\n                        continue\n                    dp[i][j] = dp[i][j - 1]\n                    if p[i - 1] in \"?*\" or p[i - 1] == s[j]:\n                        dp[i][j] |= dp[i - 1][j]\n        return dp[n][m]\n```\n\n#### 45. 跳跃游戏Ⅱ\n给定一个长度为`n`的 0 索引整数数组`nums`。初始位置为`nums[0]`。\n\n每个元素`nums[i]`表示从索引`i`向前跳转的最大长度。换句话说，如果你在`nums[i]`处，你可以跳转到任意`nums[i + j]`处:\n\n+ `0 <= j <= nums[i] `\n+ `i + j < n`\n\n返回到达`nums[n - 1]`的最小跳跃次数。\n\n> [https://leetcode.cn/problems/jump-game-ii](https://leetcode.cn/problems/jump-game-ii)\n>\n\n```python\nclass Solution:\n    INF = 2 ** 31 - 1\n    \n    def jump(self, nums: List[int]) -> int:\n        n = len(nums)\n        i, dp = n - 2, [0] * n\n        while i >= 0:\n            if nums[i] == 0: dp[i] = self.INF\n            elif i + nums[i] >= n - 1: dp[i] = 1\n            else: dp[i] = 1 + min(dp[i + 1: i + nums[i] + 1])\n            i -= 1\n        return dp[0]\n```\n\n#### 46. 全排列\n给定一个不含重复数字的数组`nums`，返回其所有可能的全排列 。你可以按任意顺序返回答案。\n\n> [https://leetcode.cn/problems/permutations/](https://leetcode.cn/problems/permutations/)\n>\n\n**思路一：排完序之后，一直取下一个排列**\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.nums = None\n\n    def next(self):\n        n = len(self.nums)\n        i, j = n - 2, n - 1\n        while i >= 0 and self.nums[i] >= self.nums[i + 1]: i -= 1\n        if i < 0: return False\n        while j >= 0 and self.nums[j] <= self.nums[i]: j -= 1\n        self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        i, j = i + 1, n - 1\n        while i < j:\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n            i += 1\n            j -= 1\n        return True\n\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) <= 1: return [nums]\n        self.ans.clear()\n        self.nums = sorted(nums)\n        while True:\n            self.ans.append(self.nums[:])\n            if not self.next(): break\n        return self.ans\n```\n\n**思路二：回溯**\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n        self.nums = None\n        self.item_map = None\n        self.p, self.n = 0, 0\n\n    def dfs(self, n):\n        if n == self.n:\n            self.ans.append(self.path[:])\n            return\n        for item in self.nums:\n            if not self.item_map[item]: continue\n            self.path.append(item)\n            self.item_map[item] = False\n            self.dfs(n + 1)\n            self.path.pop()\n            self.item_map[item] = True\n\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) <= 1: return [nums]\n        self.nums = nums\n        self.ans.clear()\n        self.path.clear()\n        self.n = len(nums)\n        self.item_map = {item: True for item in nums}\n        self.dfs(0)\n        return self.ans\n```\n\n#### 47. 全排列Ⅱ\n给定一个可包含重复数字的序列`nums`，按任意顺序返回所有不重复的全排列。\n\n> [https://leetcode.cn/problems/permutations-ii/](https://leetcode.cn/problems/permutations-ii/)\n>\n\n**思路一：排序后取排列（与上一题没有差别）**\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.nums = None\n\n    def next(self):\n        n = len(self.nums)\n        i, j = n - 2, n - 1\n        while i >= 0 and self.nums[i] >= self.nums[i + 1]: i -= 1\n        if i < 0: return False\n        while j >= 0 and self.nums[j] <= self.nums[i]: j -= 1\n        self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        i, j = i + 1, n - 1\n        while i < j:\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n            i += 1\n            j -= 1\n        return True\n\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) <= 1: return [nums]\n        self.ans.clear()\n        self.nums = sorted(nums)\n        while True:\n            self.ans.append(self.nums[:])\n            if not self.next(): break\n        return self.ans\n```\n\n**思路二：回溯但同一个位置的元素必须不同**\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n        self.nums = None\n        self.item_map = {}\n        self.p, self.n = 0, 0\n\n    def dfs(self, n):\n        if n == self.n:\n            self.ans.append(self.path[:])\n            return\n        for i, item in enumerate(self.nums):\n            if self.item_map[item] <= 0: continue\n            if i > 0 and self.nums[i - 1] == item: continue\n            self.path.append(item)\n            self.item_map[item] -= 1\n            self.dfs(n + 1)\n            self.path.pop()\n            self.item_map[item] += 1\n\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) <= 1: return [nums]\n        nums.sort()\n        self.nums = nums\n        self.ans.clear()\n        self.path.clear()\n        self.n = len(nums)\n        self.item_map.clear()\n        for item in nums:\n            self.item_map[item] = self.item_map.get(item, 0) + 1\n        self.dfs(0)\n        return self.ans\n```\n\n#### 48. 旋转图像\n给定一个`n × n`的二维矩阵`matrix`表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n\n> [https://leetcode.cn/problems/rotate-image](https://leetcode.cn/problems/rotate-image)\n>\n\n**方法：**\n\n1. 沿铅直中线镜像翻转\n2. 沿副对角线翻转\n\n```python\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(n):\n            for j in range(n // 2):\n                x, y = i, n - j - 1\n                matrix[i][j], matrix[x][y] = matrix[x][y], matrix[i][j]\n        for i in range(n):\n            for j in range(n - i - 1):\n                x, y = n - j - 1, n - i - 1\n                matrix[i][j], matrix[x][y] = matrix[x][y], matrix[i][j]\n\n```\n\n#### 49. 字母异位词分组\n给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。\n\n> [https://leetcode.cn/problems/group-anagrams](https://leetcode.cn/problems/group-anagrams)\n>\n\n```python\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ans_map = {}\n        for string in strs:\n            os = \"\".join(sorted(string))\n            if os in ans_map:\n                ans_map[os].append(string)\n            else:\n                ans_map[os] = [string]\n        return [value for value in ans_map.values()]\n```\n\n#### 50. Pow(x, n)\n实现`pow(x, n)`，即计算`x`的整数`n`次幂函数（即，![image](https://cdn.nlark.com/yuque/__latex/722eebfa0ac87ff7cbadf3b46424b7f6.svg)）。\n\n> [https://leetcode.cn/problems/powx-n/](https://leetcode.cn/problems/powx-n/)\n>\n\n```python\ndef iter_one(x, n):\n    ans, p = x, 1\n    while p <= n - p:\n        p *= 2\n        ans *= ans\n    return ans, p\n\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0: return 0\n        if x == 1 or n == 0: return 1\n        ans = 1\n        k = n if n > 0 else -n\n        while k > 0:\n            tmp, p = iter_one(x, k)\n            k -= p\n            ans *= tmp\n        return ans if n > 0 else 1 / ans\n```\n\n'),
       (21, 21, '#### 51. N 皇后\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\n\n`n`皇后问题研究的是如何将`n`个皇后放置在`n×n`的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数`n`，返回所有不同的`n`皇后问题的解决方案。\n\n每一种解法包含一个不同的`n`皇后问题的棋子放置方案，该方案中`\'Q\'`和`\'.\'`分别代表了皇后和空位。\n\n> [https://leetcode.cn/problems/n-queens](https://leetcode.cn/problems/n-queens)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.ans = []\n        self.position = []\n\n    def judge(self, col):\n        \"\"\" 在 position 最后添加一个 col 是否合适 \"\"\"\n        if col in self.position: return False\n        row = len(self.position)\n        for i, j in enumerate(self.position):\n            if abs(row - i) == abs(col - j): return False\n        return True\n\n    def generate_map(self):\n        \"\"\" 根据 position 生成棋盘 \"\"\"\n        ans = []\n        for i in range(self.n):\n            k = self.position[i]\n            ans.append(\".\" * k + \"Q\" + \".\" * (self.n - k - 1))\n        return ans\n\n    def dfs(self, k):\n        \"\"\" 回溯第 k 个位置 \"\"\"\n        if k == self.n:\n            self.ans.append(self.generate_map())\n            return\n        for j in range(self.n):\n            if not self.judge(j): continue\n            self.position.append(j)\n            self.dfs(k + 1)\n            self.position.pop()\n\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        self.n = n\n        self.ans.clear()\n        self.position.clear()\n        self.dfs(0)\n        return self.ans\n```\n\n#### 52. N 皇后Ⅱ\n`n`皇后问题研究的是如何将`n`个皇后放置在`n × n`的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数`n`，返回`n`皇后问题 不同的解决方案的数量。\n\n> [https://leetcode.cn/problems/n-queens-ii](https://leetcode.cn/problems/n-queens-ii)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.ans = 0\n        self.position = []\n\n    def judge(self, col):\n        \"\"\" 在 position 最后添加一个 col 是否合适 \"\"\"\n        if col in self.position: return False\n        row = len(self.position)\n        for i, j in enumerate(self.position):\n            if abs(row - i) == abs(col - j): return False\n        return True\n\n    def dfs(self, k):\n        \"\"\" 回溯第 k 个位置 \"\"\"\n        if k == self.n:\n            self.ans += 1\n            return\n        for j in range(self.n):\n            if not self.judge(j): continue\n            self.position.append(j)\n            self.dfs(k + 1)\n            self.position.pop()\n\n    def totalNQueens(self, n: int) -> int:\n        self.n = n\n        self.ans = 0\n        self.position.clear()\n        self.dfs(0)\n        return self.ans\n```\n\n#### 53. 最大子数组和\n给你一个整数数组`nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。\n\n> [https://leetcode.cn/problems/maximum-subarray/](https://leetcode.cn/problems/maximum-subarray/)\n>\n\n```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        ans, dp[0] = nums[0], nums[0]\n        for i in range(1, n):\n            dp[i] = nums[i] + max(dp[i - 1], 0)\n            ans = max(ans, dp[i])\n        return ans\n```\n\n#### 54. 螺旋矩阵\n给你一个`m`行`n`列的矩阵`matrix`，请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n\n> [https://leetcode.cn/problems/spiral-matrix/](https://leetcode.cn/problems/spiral-matrix/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.matrix = []\n\n    def circle(self, begin, width, height):\n        \"\"\" 给定一个矩形的左上角和宽高，绕矩形一圈 \"\"\"\n        r, c = begin, begin\n        self.ans.append(self.matrix[r][c])\n        for i in range(1, width):\n            self.ans.append(self.matrix[r][c + i])\n        for i in range(1, height):\n            self.ans.append(self.matrix[r + i][c + width - 1])\n        if height > 1:\n            for i in range(1, width):\n                self.ans.append(self.matrix[r + height - 1][c + width - i - 1])\n        if width > 1:\n            for i in range(1, height - 1):\n                self.ans.append(self.matrix[r + height - 1 - i][c])\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        self.ans.clear()\n        self.matrix = matrix\n        m, n = len(matrix), len(matrix[0])\n        for i in range((min(m, n) + 1) // 2):\n            width = n - 2 * i\n            height = m - 2 * i\n            self.circle(i, width, height)\n        return self.ans\n```\n\n#### 55. 跳跃游戏\n给定一个非负整数数组`nums`，你最初位于数组的第一个下标。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。\n\n> [https://leetcode.cn/problems/jump-game/](https://leetcode.cn/problems/jump-game/)\n>\n\n```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n <= 1: return True\n        jump = [False] * n\n        p, jump[-1] = n - 2, True\n        while p >= 0:\n            jump[p] = True in jump[p + 1: p + nums[p] + 1]\n            p -= 1\n        return jump[0]\n```\n\n#### 56. 合并区间\n以数组`intervals`表示若干个区间的集合，其中单个区间为![image](https://cdn.nlark.com/yuque/__latex/8995e677208b1f217c344a0955018660.svg)。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n\n> [https://leetcode.cn/problems/merge-intervals](https://leetcode.cn/problems/merge-intervals)\n>\n\n```python\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        ans, n = [], len(intervals)\n        intervals.sort(key=lambda x: x[0])\n        begin, end = intervals[0]\n        for i in range(1, n):\n            b, e = intervals[i]\n            if end < b:\n                ans.append([begin, end])\n                begin, end = b, e\n            elif end < e: end = e\n        ans.append([begin, end])\n        return ans\n```\n\n#### 57. 插入区间\n给你一个**无重叠的**_，_按照区间起始端点排序的区间列表。\n\n在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\n\n> [https://leetcode.cn/problems/insert-interval/](https://leetcode.cn/problems/insert-interval/)\n>\n\n```python\nclass Solution:\n    def merge(self, intervals):\n        ans, n = [], len(intervals)\n        intervals.sort(key=lambda x: x[0])\n        begin, end = intervals[0]\n        for i in range(1, n):\n            b, e = intervals[i]\n            if end < b:\n                ans.append([begin, end])\n                begin, end = b, e\n            elif end < e:\n                end = e\n        ans.append([begin, end])\n        return ans\n\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        intervals.append(newInterval)\n        return self.merge(intervals)\n```\n\n#### 58. 最后一个单词的长度\n给你一个字符串`s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。\n\n单词是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n> [https://leetcode.cn/problems/length-of-last-word](https://leetcode.cn/problems/length-of-last-word)\n>\n\n```python\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        s = s.strip()\n        idx = s.rfind(\" \")\n        return len(s) - idx - 1\n```\n\n#### 59. 螺旋矩阵Ⅱ\n给你一个正整数`n`，生成一个包含`1`到![image](https://cdn.nlark.com/yuque/__latex/b67c3aca1bcc34aec861fef4fbf09535.svg)所有元素，且元素按顺时针顺序螺旋排列的`n x n`正方形矩阵`matrix`。\n\n> [https://leetcode.cn/problems/spiral-matrix-ii/](https://leetcode.cn/problems/spiral-matrix-ii/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.cnt = 0\n        self.matrix = None\n\n    def circle(self, begin, length):\n        self.cnt += 1\n        r, c = begin, begin\n        self.matrix[r][c] = self.cnt\n        for i in range(1, length):\n            self.cnt += 1\n            self.matrix[r][c + i] = self.cnt\n        for i in range(1, length):\n            self.cnt += 1\n            self.matrix[r + i][c + length - 1] = self.cnt\n        if length > 1:\n            for i in range(1, length):\n                self.cnt += 1\n                self.matrix[r + length - 1][c + length - i - 1] = self.cnt\n            for i in range(1, length - 1):\n                self.cnt += 1\n                self.matrix[r + length - i - 1][c] = self.cnt\n\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        self.cnt = 0\n        self.matrix = [[0] * n for _ in range(n)]\n        for i in range((n + 1) // 2):\n            self.circle(i, n - 2 * i)\n        return self.matrix\n```\n\n#### 60. 排列序列\n给出集合`[1,2,3,...,n]`，其所有元素共有`n!`种排列。\n\n按大小顺序列出所有排列情况，并一一标记，当`n = 3`时, 所有排列如下：\n\n1. `\"123\"`\n2. `\"132\"`\n3. `\"213\"`\n4. `\"231\"`\n5. `\"312\"`\n6. `\"321\"`\n\n给定`n`和`k`，返回第`k`个排列。\n\n> [https://leetcode.cn/problems/permutation-sequence](https://leetcode.cn/problems/permutation-sequence)\n>\n\n**思路一：暴力求解全排列**\n\n```python\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.nums = None\n\n    def next(self):\n        \"\"\" 获取下一个排列 \"\"\"\n        i, j = self.n - 2, self.n - 1\n        while i >= 0 and self.nums[i] > self.nums[i + 1]: i -= 1\n        if i < 0: return\n        while j >= 0 and self.nums[j] < self.nums[i]: j -= 1\n        self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        i, j = i + 1, self.n - 1\n        while i < j:\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n            i += 1\n            j -= 1\n\n    def getPermutation(self, n: int, k: int) -> str:\n        if n == 1: return \"1\"\n        self.n = n\n        self.nums = [f\"{i + 1}\" for i in range(n)]\n        while k > 1:\n            k -= 1\n            self.next()\n        return \"\".join(self.nums)\n```\n\n**思路二：数学技巧**\n\n以数字`1-n`排成的所有排列中，任意一个数字开头的排列共有`(n-1)!`个，故：\n\n1. `0 < k ≤ (n-1)!`时，必然由列表中最小的元素`1`开头。\n2. `(n-1)! < k ≤ 2(n-1)!`时，必然由列表中第二小的元素`2`开头。\n3. 依次类推\n\n当我们确定了开头数字之后，删掉已经选择的数字并且更新`k`就可以按照同样的方法确定其它位置的数字。\n\n计算第`i`（`i`从`1`开始算起）个数字的算法步骤如下：\n\n1. 选择列表中第![image](https://cdn.nlark.com/yuque/__latex/7bddc1485b0f919b3cfdfc3e4306492f.svg)小的数字。\n2. 删除该数字，并且按照![image](https://cdn.nlark.com/yuque/__latex/33a5beeef0ffe01b6066a09c48cda092.svg)更新`k`。\n3. 若![image](https://cdn.nlark.com/yuque/__latex/5e0a7763ccf8967b850018463a5285df.svg)则退出，否则转到步骤 1。\n\n```python\nclass Solution:\n    def __init__(self):\n        # 存着 0! ~ 9!\n        self.prop = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n\n    def getPermutation(self, n: int, k: int) -> str:\n        ans = \"\"\n        nums = [i + 1 for i in range(n)]\n        while n > 0:\n            n -= 1\n            idx = (k - 1) // self.prop[n]\n            k = (k - 1) % self.prop[n] + 1\n            ans += f\"{nums[idx]}\"\n            del nums[idx]\n        return ans\n```\n\n#### 61. 旋转链表\n给你一个链表的头节点`head`，旋转链表，将链表每个节点向右移动`k`个位置。\n\n> [https://leetcode.cn/problems/rotate-list/](https://leetcode.cn/problems/rotate-list/)\n>\n\n```python\nclass Solution:\n    def count(self, head):\n        cnt = 0\n        while head is not None:\n            cnt += 1\n            head = head.next\n        return cnt\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        n = self.count(head)\n        if n <= 1: return head\n        if k % n == 0: return head\n        k %= n\n        head = ListNode(next=head)\n        p, q = head, head\n        for _ in range(k):\n            q = q.next\n        while q.next is not None:\n            p = p.next\n            q = q.next\n        r = p.next\n        p.next = None\n        q.next = head.next\n        return r\n```\n\n#### 62. 不同路径\n一个机器人位于一个`m x n`网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n![](/yuque/0/2023/png/1561375/1680767664635-12514e36-e43c-4408-948e-a893642db518.png)\n\n> [https://leetcode.cn/problems/unique-paths](https://leetcode.cn/problems/unique-paths)\n>\n\n```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[0] * n for _ in range(m)]\n        for col in range(n - 1, -1, -1):\n            for row in range(m - 1, -1, -1):\n                if row == m - 1: dp[row][col] = 1\n                elif col == n - 1: dp[row][col] = 1\n                else: dp[row][col] = dp[row + 1][col] + dp[row][col + 1]\n        return dp[0][0]\n```\n\n#### 63. 不同路径Ⅱ\n一个机器人位于一个`m x n`网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n![](/yuque/0/2023/png/1561375/1680769754825-a45000f4-6ac5-471f-8b46-eb7f071a64b6.png)\n\n> [https://leetcode.cn/problems/unique-paths-ii](https://leetcode.cn/problems/unique-paths-ii)\n>\n\n```python\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        for col in range(n - 1, -1, -1):\n            for row in range(m - 1, -1, -1):\n                if obstacleGrid[row][col] == 1:\n                    dp[row][col] = 0\n                elif row == m - 1:\n                    arr = obstacleGrid[-1][col:]\n                    dp[row][col] = 0 if 1 in arr else 1\n                elif col == n - 1:\n                    arr = list(map(lambda x: x[-1], obstacleGrid))[row:]\n                    dp[row][col] = 0 if 1 in arr else 1\n                else:\n                    dp[row][col] = dp[row + 1][col] + dp[row][col + 1]\n        return dp[0][0]\n```\n\n#### 64. 最小路径和\n给定一个包含非负整数的`m x n`网格`grid`，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。**说明：**每次只能向下或者向右移动一步。\n\n![](/yuque/0/2023/png/1561375/1680770333910-c487a029-7d8e-40f5-b3db-e1bcb9de1fa3.png)\n\n> [https://leetcode.cn/problems/minimum-path-sum/](https://leetcode.cn/problems/minimum-path-sum/)\n>\n\n```python\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        for c in range(n - 1, -1, -1):\n            for r in range(m - 1, -1, -1):\n                if r == m - 1 and c == n - 1: continue\n                if r == m - 1: grid[r][c] += grid[r][c + 1]\n                elif c == n - 1: grid[r][c] += grid[r + 1][c]\n                else: grid[r][c] += min(grid[r][c + 1], grid[r + 1][c])\n        return grid[0][0]\n```\n\n#### 65. 有效数字\n有效数字（按顺序）可以分成以下几个部分：\n\n1. 一个**小数**或者**整数**\n2. （可选）一个`\'e\'`或`\'E\'`，后面跟着一个整数\n\n小数（按顺序）可以分成以下几个部分：\n\n1. （可选）一个符号字符（`\'+\'`或`\'-\'`）\n2. 下述格式之一：\n    - 至少一位数字，后面跟着一个点`\'.\'`\n    - 至少一位数字，后面跟着一个点`\'.\'`，后面再跟着至少一位数字\n    - 一个点`\'.\'`，后面跟着至少一位数字\n\n整数（按顺序）可以分成以下几个部分：\n\n1. （可选）一个符号字符（`\'+\'`或`\'-\'`）\n2. 至少一位数字\n\n部分有效数字列举如下：`[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]`\n\n部分无效数字列举如下：`[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]`\n\n给你一个字符串`s`，如果`s`是一个有效数字 ，请返回`true`。\n\n> [https://leetcode.cn/problems/valid-number](https://leetcode.cn/problems/valid-number)\n>\n\n**思路：有限状态自动机**\n\n每次取一个字符，判断状态的流转。若不能流转就是非法，流转到最后的时候，看看状态是否是在成功状态里。\n\n```python\nfrom enum import Enum\n\nCharType = Enum(\"CharType\", [\n    \"E\",\n    \"DOT\",\n    \"SIGN\",\n    \"NUMBER\",\n])\n\nState = Enum(\"State\", [\n    \"STATE_INIT\",\n    \"STATE_SIGN\",\n    \"STATE_NUMBER\",\n    \"STATE_NUMBER_DOT\",\n    \"STATE_NONE_DOT\",\n    \"STATE_LITTLE_NUMBER\",\n    \"STATE_E\",\n    \"STATE_EXP_SIGN\",\n    \"STATE_EXP_NUMBER\",\n])\n\nsuccess_state = [State.STATE_NUMBER, State.STATE_NUMBER_DOT, \n                 State.STATE_LITTLE_NUMBER, State.STATE_EXP_NUMBER]\n\ntransfer = {\n    State.STATE_INIT: {\n        CharType.SIGN: State.STATE_SIGN,\n        CharType.NUMBER: State.STATE_NUMBER,\n        CharType.DOT: State.STATE_NONE_DOT\n    },\n    State.STATE_SIGN: {\n        CharType.NUMBER: State.STATE_NUMBER,\n        CharType.DOT: State.STATE_NONE_DOT\n    },\n    State.STATE_NUMBER: {\n        CharType.NUMBER: State.STATE_NUMBER,\n        CharType.DOT: State.STATE_NUMBER_DOT,\n        CharType.E: State.STATE_E\n    },\n    State.STATE_NUMBER_DOT: {\n        CharType.NUMBER: State.STATE_LITTLE_NUMBER,\n        CharType.E: State.STATE_E\n    },\n    State.STATE_NONE_DOT: {\n        CharType.NUMBER: State.STATE_LITTLE_NUMBER\n    },\n    State.STATE_LITTLE_NUMBER: {\n        CharType.NUMBER: State.STATE_LITTLE_NUMBER,\n        CharType.E: State.STATE_E\n    },\n    State.STATE_E: {\n        CharType.SIGN: State.STATE_EXP_SIGN,\n        CharType.NUMBER: State.STATE_EXP_NUMBER\n    },\n    State.STATE_EXP_SIGN: {\n        CharType.NUMBER: State.STATE_EXP_NUMBER\n    },\n    State.STATE_EXP_NUMBER: {\n        CharType.NUMBER: State.STATE_EXP_NUMBER\n    },\n}\n\n\ndef to_char_type(ch: str):\n    \"\"\" 判断一个字符的类型 \"\"\"\n    if ch in \"eE\": return CharType.E\n    if ch == \'.\': return CharType.DOT\n    if ch in \"+-\": return CharType.SIGN\n    if ch.isdigit(): return CharType.NUMBER\n    return None\n\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        state = State.STATE_INIT\n        for ch in s:\n            tp = to_char_type(ch)\n            if tp is None: return False\n            if tp not in transfer[state]: return False\n            state = transfer[state][tp]\n        return state in success_state\n```\n\n#### 66. 加一\n给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n\n你可以假设除了整数`0`之外，这个整数不会以零开头。\n\n> [https://leetcode.cn/problems/plus-one](https://leetcode.cn/problems/plus-one)\n>\n\n```python\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        flg = 1\n        p = len(digits) - 1\n        while p >= 0:\n            tmp = digits[p] + flg\n            if tmp > 9:\n                flg = 1\n                tmp -= 10\n            else: flg = 0\n            digits[p] = tmp\n            p -= 1\n        if flg > 0: digits.insert(0, flg)\n        return digits\n```\n\n#### 67. 二进制求和\n给你两个二进制字符串`a`和`b`，以二进制字符串的形式返回它们的和。\n\n> [https://leetcode.cn/problems/add-binary/](https://leetcode.cn/problems/add-binary/)\n>\n\n```python\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        ans, i = \"\", len(a) - 1\n        flg, j = 0, len(b) - 1\n        while i >= 0 or j >= 0:\n            t1 = int(a[i]) if i >= 0 else 0\n            t2 = int(b[j]) if j >= 0 else 0\n            tmp = t1 + t2 + flg\n            if tmp > 1:\n                flg = 1\n                tmp -= 2\n            else: flg = 0\n            i -= 1\n            j -= 1\n            ans = f\"{tmp}\" + ans\n        if flg > 0: ans = f\"{flg}\" + ans\n        return ans\n```\n\n#### 68. 文本左右对齐\n给定一个单词数组`words`和一个长度`maxWidth`，重新排版单词，使其成为每行恰好有`maxWidth`个字符，且左右两端对齐的文本。\n\n你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格`\' \'`填充，使得每行恰好有`maxWidth`个字符。\n\n要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。文本的最后一行应为左对齐，且单词之间不插入额外的空格。\n\n注意:\n\n+ 单词是指由非空格字符组成的字符序列。\n+ 每个单词的长度大于`0`，小于等于`maxWidth`。\n+ 输入单词数组`words`至少包含一个单词。\n\n> [https://leetcode.cn/problems/text-justification](https://leetcode.cn/problems/text-justification)\n>\n\n```python\ndef generate_str(words, maxWidth, last=False):\n    \"\"\" 根据字符串列表生成字符串 \"\"\"\n    if last or len(words) == 1:\n        ans = \" \".join(words)\n        ans += \" \" * (maxWidth - len(ans))\n        return ans\n    ans = \"\"\n    n = len(words)\n    word_len = len(\"\".join(words))\n    base = (maxWidth - word_len) // (n - 1)\n    extra = (maxWidth - word_len) % (n - 1)\n    for i in range(n):\n        if i > 0:\n            space = base + (1 if i <= extra else 0)\n            ans += \" \" * space\n        ans += words[i]\n    return ans\n\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        b, e = 0, 1\n        ans, n = [], len(words)\n        length = len(words[0])\n        while e < n:\n            l = len(words[e]) + 1\n            if length + l <= maxWidth:\n                length += l\n            else:\n                ans.append(generate_str(words[b: e], maxWidth))\n                b = e\n                length = len(words[b])\n            e += 1\n        ans.append(generate_str(words[b: e], maxWidth, True))\n        return ans\n```\n\n#### 69. x 的平方根\n给你一个非负整数`x`，计算并返回`x`的算术平方根 。\n\n由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。\n\n注意：不允许使用任何内置指数函数和算符，例如`pow(x, 0.5)`或者`x ** 0.5`。\n\n> [https://leetcode.cn/problems/sqrtx](https://leetcode.cn/problems/sqrtx)\n>\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        l, r = 1, x\n        while l <= r:\n            mid = (l + r) // 2\n            square = mid * mid\n            if square == x: return mid\n            if square < x: l = mid + 1\n            else: r = mid - 1\n        return r\n```\n\n#### 70. 爬楼梯\n假设你正在爬楼梯。需要`n`阶你才能到达楼顶。\n\n每次你可以爬`1`或`2`个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n> [https://leetcode.cn/problems/climbing-stairs/](https://leetcode.cn/problems/climbing-stairs/)\n>\n\n本质上就是斐波那契数列：\n\n+ `n == 1`时，只有`1`种方案\n+ `n == 2`时，有了`2`种方案\n+ `n ≥ 3`时，总方案数就是走一步和走两步的方案和。\n\n```python\nclass Solution:\n    def __init__(self):\n        fib = [1, 2]\n        for i in range(2, 45):\n            fib.append(fib[i - 1] + fib[i - 2])\n        self.fib = fib\n\n    def climbStairs(self, n: int) -> int:\n        return self.fib[n - 1]\n```\n\n#### 71. 简化路径\n给你一个字符串`path`，表示指向某一文件或目录的 Unix 风格绝对路径（以`\'/\'`开头），请你将其转化为更加简洁的规范路径。\n\n在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点（`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`\'//\'`）都被视为单个斜杠`\'/\'`。 对于此问题，任何其他格式的点（例如，`\'...\'`）均被视为文件/目录名称。\n\n请注意，返回的规范路径必须遵循下述格式：\n\n+ 始终以斜杠`\'/\'`开头。\n+ 两个目录名之间必须只有一个斜杠`\'/\'`。\n+ 最后一个目录名（如果存在）不能 以`\'/\'`结尾。\n+ 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含`\'.\'`或`\'..\'`）。\n\n返回简化后得到的规范路径 。\n\n> [https://leetcode.cn/problems/simplify-path](https://leetcode.cn/problems/simplify-path)\n>\n\n```python\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        for ab in filter(lambda x: x, path.split(\"/\")):\n            if ab == \".\": continue\n            if ab == \"..\":\n                if len(stack) > 0: stack.pop()\n                continue\n            stack.append(ab)\n        return \"/\" + \"/\".join(stack)\n```\n\n#### 72. 编辑距离\n给你两个单词`word1`和`word2`， 请返回将`word1`转换成`word2`所使用的最少操作数  。\n\n你可以对一个单词进行如下三种操作：\n\n+ 插入一个字符\n+ 删除一个字符\n+ 替换一个字符\n\n> [https://leetcode.cn/problems/edit-distance](https://leetcode.cn/problems/edit-distance)\n>\n\n**思路：动态规划**\n\n设`dp[i][j]`表示字符串`A`的第`[1, i]`位子串与字符串`B`的第`[1, j]`位子串的最短编辑距离。那么分下面三种情况：\n\n1. 对`A`插入。若已知`dp[i - 1][j]`，我们只需要在`A[1, i - 1]`后面插入一个`B[j]`就完成了转换。因此，这种情况下有`dp[i][j] = dp[i - 1][j] + 1`。\n2. ~~对~~`~~A~~`~~删除~~。同样的道理，可以推出`dp[i][j] = dp[i + 1][j] + 1`。但是这样是没法规划的，因为计算`dp[i][j]`的时候需要其上下两个位置的值。\n3. 对`B`插入。针对第 2 种情况，我们发现删除`A`最后一个元素（`ch`）与在`B`最后添加一个`ch`是等价的。因此就有`dp[i][j] = dp[i][j - 1] + 1`。\n4. 替换`A`最后一个字符。若已知`dp[i - 1][j - 1]`，那么若：\n    1. `A[i] == B[j]`，那么`dp[i][j] = dp[i - 1][j - 1]`\n    2. `a[i] != B[j]`，那么`dp[i][j] = dp[i - 1][j - 1] + 1`\n\n```python\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        if m == 0 or n == 0: return max(m, n)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        word1 = \" \" + word1\n        word2 = \" \" + word2\n        for i in range(m + 1): dp[i][0] = i\n        for i in range(n + 1): dp[0][i] = i\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                a = dp[i - 1][j] + 1\n                b = dp[i][j - 1] + 1\n                c = dp[i - 1][j - 1] + (0 if word1[i] == word2[j] else 1)\n                dp[i][j] = min(a, b, c)\n        return dp[m][n]\n```\n\n#### 73. 矩阵置零\n给定一个`m x n`的矩阵，如果一个元素为 **0 **，则将其所在行和列的所有元素都设为 **0** 。请使用原地算法**。**\n\n**思路：**\n\n1. 定义两个变量用来记录第 0 行和第 0 列是否有 0。\n2. 扫描每一行/列，如果该行/列有 0，那么这一行/列第 0 个元素置 0。\n3. 根据每行/列的第 0 个元素，判断该行/列是否应该全部置 0。\n4. 根据一开始的两个变量确定第 0 行/列是否应该全部置 0。\n\n```python\nclass Solution:\n    def __init__(self):\n        self.m = 0\n        self.n = 0\n        self.matrix = None\n\n    def fill_zero(self, row=-1, col=-1):\n        if row >= 0:\n            for i in range(self.n):\n                self.matrix[row][i] = 0\n        if col < 0: return\n        for i in range(self.m):\n            self.matrix[i][col] = 0\n\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        self.m = len(matrix)\n        self.n = len(matrix[0])\n        self.matrix = matrix\n        row0 = 0 in matrix[0]\n        col0 = 0 in map(lambda x: x[0], matrix)\n        for i in range(1, self.m):\n            if 0 not in matrix[i]:\n                continue\n            matrix[i][0] = 0\n        for i in range(1, self.n):\n            if 0 not in map(lambda x: x[i], matrix):\n                continue\n            matrix[0][i] = 0\n        for i in range(1, self.m):\n            if matrix[i][0]: continue\n            self.fill_zero(row=i)\n        for i in range(1, self.n):\n            if matrix[0][i]: continue\n            self.fill_zero(col=i)\n        if row0: self.fill_zero(row=0)\n        if col0: self.fill_zero(col=0)\n```\n\n#### 74. 搜索二维矩阵\n编写一个高效的算法来判断`m x n`矩阵中，是否存在一个目标值。该矩阵具有如下特性：\n\n+ 每行中的整数从左到右按升序排列。\n+ 每行的第一个整数大于前一行的最后一个整数。\n\n> [https://leetcode.cn/problems/search-a-2d-matrix](https://leetcode.cn/problems/search-a-2d-matrix)\n>\n\n```python\ndef half_search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target: return True\n        if nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return False\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        r = 0\n        m = len(matrix)\n        n = len(matrix[0])\n        for r in range(m):\n            if matrix[r][n - 1] >= target: break\n        else: r += 1\n        if r >= m: return False\n        return half_search(matrix[r], target)\n```\n\n#### 75. 颜色分类\n给定一个包含红色、白色和蓝色、共`n`个元素的数组`nums`，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。必须在不使用库内置的 sort 函数的情况下解决这个问题。\n\n> [https://leetcode.cn/problems/sort-colors](https://leetcode.cn/problems/sort-colors)\n>\n\n```python\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        p0, p1, p2 = 0, 0, 0\n        for i in range(n):\n            if nums[i] == 0: p0 += 1\n            elif nums[i] == 1: p1 += 1\n            else: p2 += 1\n        for i in range(p0): nums[i] = 0\n        for i in range(p1): nums[i + p0] = 1\n        for i in range(p2): nums[i + p0 + p1] = 2\n```\n\n#### 76. 最小覆盖子串\n给你一个字符串`s`、一个字符串`t`。返回`s`中涵盖`t`所有字符的最小子串。如果`s`中不存在涵盖`t`所有字符的子串，则返回空字符串`\"\"`。\n\n注意：\n\n+ 对于`t`中重复字符，我们寻找的子字符串中该字符数量必须不少于`t`中该字符数量。\n+ 如果`s` 中存在这样的子串，我们保证它是唯一的答案。\n\n> [https://leetcode.cn/problems/minimum-window-substring](https://leetcode.cn/problems/minimum-window-substring)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.t_map = {}\n        self.cover = False\n\n    def add(self, ch):\n        \"\"\" 窗口中添加了最后的元素 ch \"\"\"\n        self.t_map[ch] -= 1\n        if self.cover: return\n        for item in self.t_map.values():\n            if item > 0: return\n        self.cover = True\n\n    def reduce(self, ch):\n        \"\"\" 窗口中释放了开头的元素 ch \"\"\"\n        self.t_map[ch] += 1\n        if not self.cover: return\n        self.cover = (self.t_map[ch] <= 0)\n\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\" 滑动窗口解题 \"\"\"\n        self.cover = False\n        self.t_map.clear()\n        l, r = 0, -1\n        ans, n = \"\", len(s)\n        for ch in t:\n            a = self.t_map.get(ch, 0)\n            self.t_map[ch] = a + 1\n        while True:\n            r += 1\n            if r >= n: break\n            if s[r] not in t: continue\n            self.add(s[r])\n            while self.cover:\n                if ans == \"\" or len(ans) > r - l + 1:\n                    ans = s[l: r + 1]\n                if s[l] in t:\n                    self.reduce(s[l])\n                l += 1\n        return ans\n```\n\n#### 77. 组合\n给定两个整数`n`和`k`，返回范围`[1, n]`中所有可能的`k`个数的组合。\n\n你可以按任何顺序返回答案。\n\n> [https://leetcode.cn/problems/combinations](https://leetcode.cn/problems/combinations)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n\n    def dfs(self, nums, k):\n        \"\"\" 从 nums 里面挑选 k 个数字 \"\"\"\n        if k == 0:\n            self.ans.append(self.path[:])\n            return\n        for i, item in enumerate(nums):\n            self.path.append(item)\n            self.dfs(nums[i + 1:], k - 1)\n            self.path.pop()\n\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        self.ans.clear()\n        self.path.clear()\n        nums = [i + 1 for i in range(n)]\n        self.dfs(nums, k)\n        return self.ans\n```\n\n#### 78. 子集\n给你一个整数数组`nums`，数组中的元素**互不相同** 。返回该数组所有可能的子集（幂集）。\n\n解集不能包含重复的子集。你可以按**任意顺序**返回解集。\n\n> [https://leetcode.cn/problems/subsets/](https://leetcode.cn/problems/subsets/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n\n    def dfs(self, nums, k):\n        \"\"\" 从 nums 里面挑选 k 个数字 \"\"\"\n        if k == 0:\n            self.ans.append(self.path[:])\n            return\n        for i, item in enumerate(nums):\n            self.path.append(item)\n            self.dfs(nums[i + 1:], k - 1)\n            self.path.pop()\n\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        self.ans.clear()\n        self.path.clear()\n        for i in range(n + 1):\n            self.dfs(nums, i)\n        return self.ans\n```\n\n#### 79. 单词搜索\n给定一个`m x n`二维字符网格`board`和一个字符串单词`word`。如果`word`存在于网格中，返回`true`；否则，返回`false`。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n> [https://leetcode.cn/problems/word-search](https://leetcode.cn/problems/word-search)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.length = 0\n        self.word = None\n        self.board = None\n        self.visited = None\n        self.m, self.n = 0, 0\n\n    def dfs(self, r, c, k):\n        if k >= self.length: return True\n        if r < 0 or r >= self.m: return False\n        if c < 0 or c >= self.n: return False\n        if self.visited[r][c] or self.board[r][c] != self.word[k]: return False\n        ch = self.word[k]\n        self.visited[r][c] = True\n        if self.dfs(r - 1, c, k + 1): return True\n        if self.dfs(r + 1, c, k + 1): return True\n        if self.dfs(r, c - 1, k + 1): return True\n        if self.dfs(r, c + 1, k + 1): return True\n        self.visited[r][c] = False\n        return False\n\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        self.word = word\n        self.board = board\n        self.length = len(word)\n        self.m, self.n = len(board), len(board[0])\n        self.visited = [[False] * self.n for _ in range(self.m)]\n        for i in range(self.m):\n            for j in range(self.n):\n                if board[i][j] == self.word[0]:\n                    if self.dfs(i, j, 0): return True\n        return False\n```\n\n#### 80. 删除有序数组中的重复项Ⅱ\n给你一个有序数组`nums`，请你原地删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组 并在使用`O(1)`额外空间的条件下完成。\n\n> [https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii)\n>\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        dup = 1\n        n = len(nums)\n        i, j, p = 0, 1, 1\n        while j < n:\n            if nums[j] == nums[i]:\n                dup += 1\n                if dup <= 2:\n                    nums[p] = nums[j]\n                    p += 1\n            else:\n                dup = 1\n                nums[p] = nums[j]\n                i = p\n                p += 1\n            j += 1\n        return p\n```\n\n#### 81. 搜索旋转排序数组Ⅱ\n已知存在一个按非降序排列的整数数组`nums`，数组中的值不必互不相同。\n\n在传递给函数之前，`nums`在预先未知的某个下标`k`（`0 <= k < nums.length`）上进行了旋转 ，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从`0`开始计数）。例如，`[0,1,2,4,4,4,5,6,6,7]`在下标`5`处经旋转后变为`[4,5,6,6,7,0,1,2,4,4]`。\n\n给你旋转后的数组`nums`和一个整数`target`，请你编写一个函数来判断给定的目标值是否存在于数组中。如果`nums`中存在这个目标值`target`，则返回`true`，否则返回`false`。\n\n> [https://leetcode.cn/problems/search-in-rotated-sorted-array-ii](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii)\n>\n\n```python\ndef binary_search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target: return True\n        if l == r: return False\n        if nums[l] < nums[mid]:\n            if nums[l] <= target <= nums[mid]: r = mid - 1\n            else: l = mid + 1\n        else:\n            if nums[mid + 1] <= target <= nums[r]: l = mid + 1\n            else: r = mid - 1\n    return False\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        \"\"\" 去重后直接使用二分 \"\"\"\n        nums = list(set(nums))\n        return binary_search(nums, target)\n\n# 对于这题，不如直接：return target in nums\n```\n\n#### 82. 删除排序链表中的重复元素Ⅱ\n给定一个已排序的链表的头`head`， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回已排序的链表。\n\n> [https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)\n>\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None: return None\n        h = ListNode()\n        tail = h\n        p, q = head, head.next\n        while q:\n            if p.val == q.val:\n                q = q.next\n                continue\n            if p.next == q:\n                tail.next = p\n                tail = tail.next\n            p = q\n            q = q.next\n        if p.next == q:\n            tail.next = p\n            tail = tail.next\n        tail.next = None\n        return h.next\n```\n\n#### 83. 删除排序链表中的重复元素\n给定一个已排序的链表的头`head`，删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表。\n\n> [https://leetcode.cn/problems/remove-duplicates-from-sorted-list/](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)\n>\n\n```python\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None: return None\n        tail, p = head, head.next\n        while p:\n            if p.val != tail.val: \n                tail.next.val = p.val\n                tail = tail.next\n            p = p.next\n        tail.next = None\n        return head\n```\n\n#### 84. 柱状图中最大的矩形\n给定`n`个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为`1`。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n> [https://leetcode.cn/problems/largest-rectangle-in-histogram/](https://leetcode.cn/problems/largest-rectangle-in-histogram/)\n>\n\n![](/yuque/0/2023/png/1561375/1681893036779-01d9a48f-3531-45c1-8de5-be8b754a16ec.png)\n\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        ans, stack = 0, []\n        heights.append(0)\n        heights.insert(0, 0)\n        for i, v in enumerate(heights):\n            if len(stack) == 0 or heights[stack[-1]] <= v:\n                stack.append(i)\n                continue\n            while heights[stack[-1]] > v:\n                h = heights[stack.pop()]\n                area = (i - stack[-1] - 1) * h\n                if area > ans: ans = area\n            stack.append(i)\n        return ans\n```\n\n#### 85. 最大矩形\n给定一个仅包含`0`和`1`、大小为`rows x cols`的二维二进制矩阵，找出只包含`1`的最大矩形，并返回其面积。\n\n> [https://leetcode.cn/problems/maximal-rectangle/](https://leetcode.cn/problems/maximal-rectangle/)\n>\n\n![](/yuque/0/2023/png/1561375/1681893128319-db25725a-73bf-4e58-9df2-3ff8fe9e3afa.png)\n\n```python\ndef reconstruct(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            if j == 0 or matrix[i][j] == \"0\":\n                matrix[i][j] = int(matrix[i][j])\n            else:\n                matrix[i][j] = int(matrix[i][j]) + matrix[i][j - 1]\n\n\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        ans = 0\n        reconstruct(matrix)\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0: continue\n                min_width = matrix[i][j]\n                if min_width > ans: ans = min_width\n                for k in range(i - 1, -1, -1):\n                    if matrix[k][j] == 0: break\n                    min_width = min([min_width, matrix[k][j]])\n                    area = min_width * (i - k + 1)\n                    if area > ans: ans = area\n        return ans\n```\n\n#### 86. 分隔链表\n给你一个链表的头节点`head`和一个特定值`x`，请你对链表进行分隔，使得所有小于`x`的节点都出现在 大于或等于`x`的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n> [https://leetcode.cn/problems/partition-list](https://leetcode.cn/problems/partition-list)\n>\n\n```python\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        ans_h = ListNode()\n        h = ListNode(next=head)\n        t, ans_t = h, ans_h\n        while t.next:\n            p = t.next\n            if p.val < x:\n                t.next = p.next\n                ans_t.next = p\n                ans_t = ans_t.next\n            else:\n                t = t.next\n        ans_t.next = h.next\n        return ans_h.next\n```\n\n#### 87. 扰乱字符串\n使用下面描述的算法可以扰乱字符串`s`得到字符串`t`：\n\n1. 如果字符串的长度为`1`，算法停止\n2. 如果字符串的长度`> 1`，执行下述步骤：\n    - 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串`s`，则可以将其分成两个子字符串`x`和`y`，且满足`s = x + y`。\n    - **随机**决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，`s`可能是`s = x + y`或者`s = y + x`。\n    - 在`x`和`y`这两个子字符串上继续从步骤 1 开始递归执行此算法。\n\n给你两个长度相等的字符串`s1`和`s2`，判断`s2`是否是`s1`的扰乱字符串。如果是，返回`true`；否则，返回`false`。\n\n> [https://leetcode.cn/problems/scramble-string](https://leetcode.cn/problems/scramble-string)\n>\n\n**思路解析：动态规划**\n\n对于两个字符串`s1`和`s2`，首先我们可以得出边界条件：\n\n1. 若`s1 == s2`则必然返回`True`；\n2. 若两个字符串不是同构的，必然返回`False`；同构是指组成字符串的字符及其出现次数完全一致。\n\n对于其它一般的情况，我们在第`k`个位置分割字符串`s1`得`s1 = s1[:k] + s1[k:]`，那么：\n\n1. 若不交换`s2`的顺序，那么有`f(s1, s2) = f(s1[:k], s2[:k]) and f(s1[k:], s2[k:])`；\n2. 若选择交换，那么有`f(s1, s2) = f(s1[:k], s2[-k:]) and f(s1[k:], s2[:-k])`。\n\n如果选择填表形式的动态规划会比较麻烦，因此直接选择记忆化递归解题：\n\n```python\ndef judge(s1, s2):\n    \"\"\" 判断两个字符串是否由相同的字符构成 \"\"\"\n    tmp = {}\n    for ch in s1:\n        tmp[ch] = tmp.get(ch, 0) + 1\n    for ch in s2:\n        if ch not in tmp: return False\n        tmp[ch] = tmp.get(ch, 0) - 1\n        if tmp[ch] <= 0: del tmp[ch]\n    return len(tmp) == 0\n\n\nclass Solution:\n    def __init__(self):\n        self.res = None\n        self.s1, self.s2 = \"\", \"\"\n\n    def dfs(self, i, j, n):\n        \"\"\" 返回 s1 从 i 开始、s2 从 j 开始长度均为 n 的子串是否匹配 \"\"\"\n        s1 = self.s1[i: i + n]\n        s2 = self.s2[j: j + n]\n        if self.res[i][j][n] is not None: return self.res[i][j][n]\n        if s1 == s2:\n            self.res[i][j][n] = True\n            return True\n        if not judge(s1, s2):\n            self.res[i][j][n] = False\n            return False\n        for k in range(1, n):\n            if self.dfs(i, j, k) and self.dfs(i + k, j + k, n - k):\n                self.res[i][j][n] = True\n                return True\n            if self.dfs(i, j + n - k, k) and self.dfs(i + k, j, n - k):\n                self.res[i][j][n] = True\n                return True\n        self.res[i][j][n] = False\n        return False\n\n    def isScramble(self, s1: str, s2: str) -> bool:\n        self.s1 = s1\n        self.s2 = s2\n        n = len(s1)\n        self.res = [[[None] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n        return self.dfs(0, 0, n)\n```\n\n#### 88. 合并两个有序数组\n给你两个按非递减顺序排列的整数数组`nums1`和`nums2`，另有两个整数`m`和`n`，分别表示`nums1` 和`nums2`中的元素数目。\n\n请你合并`nums2`到`nums1`中，使合并后的数组同样按非递减顺序排列。\n\n注意：最终，合并后数组不应由函数返回，而是存储在数组`nums1`中。为了应对这种情况，`nums1`的初始长度为`m + n`，其中前`m`个元素表示应合并的元素，后`n`个元素为`0`，应忽略。`nums2`的长度为`n`。\n\n> [https://leetcode.cn/problems/merge-sorted-array](https://leetcode.cn/problems/merge-sorted-array)\n>\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p = m + n - 1\n        i, j = m - 1, n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[p] = nums1[i]\n                i -= 1\n            else:\n                nums1[p] = nums2[j]\n                j -= 1\n            p -= 1\n        while i >= 0:\n            nums1[p] = nums1[i]\n            i -= 1\n            p -= 1\n        while j >= 0:\n            nums1[p] = nums2[j]\n            j -= 1\n            p -= 1\n```\n\n#### 89. 格雷编码\n`n`位格雷码序列是一个由`2n`个整数组成的序列，其中：\n\n+ 每个整数都在范围![image](https://cdn.nlark.com/yuque/__latex/fc6d869621c39905cbb2106c5c1f57dc.svg)内（含![image](https://cdn.nlark.com/yuque/__latex/22d0feea96d3bb2fc273f7598ce748c1.svg)和![image](https://cdn.nlark.com/yuque/__latex/79a3beac2e89c0f2c4c771dc5e85e5c4.svg)）\n+ 第一个整数是`0`\n+ 一个整数在序列中出现**不超过一次**\n+ 每对相邻整数的二进制表示**恰好一位不同**，且\n+ **第一个**和**最后一个**整数的二进制表示**恰好一位不同**\n\n给你一个整数`n`，返回任一有效的`n`位格雷码序列 。\n\n> [https://leetcode.cn/problems/gray-code](https://leetcode.cn/problems/gray-code)\n>\n\n**思路解析：递推**\n\n记![image](https://cdn.nlark.com/yuque/__latex/acd20957595a87390edde8420a9774fb.svg)表示`k`位格雷码序列。假设我们已经有了![image](https://cdn.nlark.com/yuque/__latex/635fe58baefc303bba91e944f2ad376b.svg)，我们可以按照以下方式构造![image](https://cdn.nlark.com/yuque/__latex/30063be24b6f15f322a50cb09c671ca0.svg)：\n\n1. 复制一份![image](https://cdn.nlark.com/yuque/__latex/5d7178d4584c5ee7f218b49cf941cca7.svg)并逆序将其记为![image](https://cdn.nlark.com/yuque/__latex/5c5f38c64748948e60088cc82a23c9f6.svg)；\n2. 将![image](https://cdn.nlark.com/yuque/__latex/5c5f38c64748948e60088cc82a23c9f6.svg)里面每一个数的第`n - 1`位改为`1`记为![image](https://cdn.nlark.com/yuque/__latex/dae980d6bbaf021df10f572d94e91ab5.svg)；\n3. 最后我们可以得出：![image](https://cdn.nlark.com/yuque/__latex/2488f9549df1a8422707c8485e38ff0d.svg)。\n\n上面第`n - 1`位是从右往左算起，最低位是第`0`位。并且我们已经知道![image](https://cdn.nlark.com/yuque/__latex/7a3313d4753130d11e5841a354872c20.svg)。\n\n```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        ans = [0]\n        for i in range(n):\n            for j in range(len(ans) - 1, -1, -1):\n                ans.append(ans[j] | 1 << i)\n        return ans\n```\n\n#### 90. 子集Ⅱ\n给你一个整数数组`nums`，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n\n解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列。\n\n> [https://leetcode.cn/problems/subsets-ii](https://leetcode.cn/problems/subsets-ii)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n\n    def chose(self, nums, n):\n        \"\"\" 从 nums 中挑选 n 个数字 \"\"\"\n        if n == 0:\n            self.ans.append(self.path[:])\n            return\n        for i, item in enumerate(nums):\n            if i > 0 and nums[i] == nums[i - 1]: continue\n            self.path.append(item)\n            self.chose(nums[i + 1:], n - 1)\n            self.path.pop()\n\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        self.ans.clear()\n        self.path.clear()\n        for n in range(0, len(nums) + 1):\n            self.chose(nums, n)\n        return self.ans\n```\n\n#### 91. 解码方法\n一条包含字母`A-Z`的消息通过以下映射进行了编码：\n\n```python\n\'A\' -> \"1\"\n\'B\' -> \"2\"\n...\n\'Z\' -> \"26\"\n```\n\n要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`\"11106\"`可以映射为：\n\n+ `\"AAJF\"`，将消息分组为`(1 1 10 6)`\n+ `\"KJF\"`，将消息分组为`(11 10 6)`\n\n注意，消息不能分组为`(1 11 06)`，因为`\"06\"`不能映射为`\"F\"`，这是由于`\"6\"`和`\"06\"`在映射中并不等价。给你一个只含数字的非空字符串`s`，请计算并返回解码方法的总数 。题目数据保证答案肯定是一个 32 位 的整数。\n\n> [https://leetcode.cn/problems/decode-ways](https://leetcode.cn/problems/decode-ways)\n>\n\n**解题思路：**我们令`dp(i)`表示由`s`中前`i`个字符构成的子串解码方式有几种。\n\n    - 对任意的`i`，若`s[i - 1: i + 1]`构成的子串是合法的，那么`dp(i) = dp(i - 2)`\n    - 若`s[i] != \"0\"`，则`dp(i) += dp(i - 1)`\n\n注意边界条件的设立。\n\n```python\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = [0] * len(s)\n        dp[0] = 1 if s[0] != \"0\" else 0\n        for i in range(1, len(s)):\n            if s[i] != \"0\":\n                dp[i] += dp[i - 1]\n            if s[i - 1] != \"0\" and s[i - 1: i + 1] <= \"26\":\n                dp[i] += 1 if i < 2 else dp[i - 2]\n        return dp[len(s) - 1]\n```\n\n#### 93. 复原 IP 地址\n有效 IP 地址正好由四个整数（每个整数位于`0`到`255`之间组成，且不能含有前导`0`），整数之间用`\'.\'`分隔。\n\n例如：`\"0.1.2.201\"`和`\"192.168.1.1\"`是有效 IP 地址，但是`\"0.011.255.245\"`、`\"192.168.1.312\"`和`\"192.168@1.1\"`是无效 IP 地址。\n\n给定一个只包含数字的字符串`s`，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在`s`中插入`\'.\'`来形成。你不能重新排序或删除`s`中的任何数字。你可以按任何顺序返回答案。\n\n> [https://leetcode.cn/problems/restore-ip-addresses](https://leetcode.cn/problems/restore-ip-addresses)\n>\n\n```python\ndef check_num(s):\n    n = len(s)\n    if n == 0: return False\n    if s[0] == \"0\" and n > 1: return False\n    return int(s) <= 255\n\n\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n\n    def dfs(self, s, n):\n        \"\"\" 将 s 分成 n 份 \"\"\"\n        if n == 1:\n            if not check_num(s): return\n            self.path.append(s)\n            self.ans.append(\".\".join(self.path))\n            self.path.pop()\n        for i in range(1, 4):\n            if len(s) < i: break\n            if not check_num(s[:i]): break\n            self.path.append(s[:i])\n            self.dfs(s[i:], n - 1)\n            self.path.pop()\n\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        self.ans.clear()\n        self.path.clear()\n        self.dfs(s, 4)\n        return self.ans\n```\n\n#### 94. 二叉树的中序遍历\n给定一个二叉树的根节点`root`，返回它的中序遍历 。\n\n> [https://leetcode.cn/problems/binary-tree-inorder-traversal/](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n\n    def dfs(self, root):\n        if root is None: return\n        self.dfs(root.left)\n        self.ans.append(root.val)\n        self.dfs(root.right)\n\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        self.ans.clear()\n        self.dfs(root)\n        return self.ans\n```\n\n#### 95. 不同的二叉搜索树Ⅱ\n给你一个整数`n`，请你生成并返回所有由`n`个节点组成且节点值从`1`到`n`互不相同的不同二叉搜索树。可以按任意顺序返回答案。\n\n> [https://leetcode.cn/problems/unique-binary-search-trees-ii/](https://leetcode.cn/problems/unique-binary-search-trees-ii/)\n>\n\n对任意的![image](https://cdn.nlark.com/yuque/__latex/98db43ff8ca59c0a6c3196f41573c5c0.svg)，我们把![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)作为根节点，那么所有比![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)小的树必然构成其左子树，相对的比![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)大的树构成其右子树。那么以![image](https://cdn.nlark.com/yuque/__latex/df976ff7fcf17d60490267d18a1e3996.svg)作为根节点的不同搜索二叉树的个数就是其左子树个数与右子树个数的积。\n\n```python\nclass Solution:\n    def dfs(self, begin, end):\n        \"\"\" 使用 begin...end 构造所有的树 \"\"\"\n        if begin > end: return [None]\n        nodes = []\n        for i in range(begin, end + 1):\n            left = self.dfs(begin, i - 1)\n            right = self.dfs(i + 1, end)\n            for ln in left:\n                for rn in right:\n                    nodes.append(TreeNode(i, ln, rn))\n        return nodes\n        \n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        return self.dfs(1, n)\n```\n\n#### 96. 不同的二叉搜索树\n给你一个整数`n`，求恰由`n`个节点组成且节点值从`1`到`n `互不相同的二叉搜索树有多少种？返回满足题意的二叉搜索树的种数。下面是`n = 3`的情况：\n\n> [https://leetcode.cn/problems/unique-binary-search-trees/](https://leetcode.cn/problems/unique-binary-search-trees/)\n>\n\n![](/yuque/0/2023/png/1561375/1686278585358-124b01ac-9994-4f8c-95df-174401e740e9.png)\n\n根据上一题的思路，我们可以写出下面的代码：\n\n```python\nclass Solution:\n    def dfs(self, begin, end):\n        \"\"\" 返回由 begin...end 构成的不同搜索树的个数 \"\"\"\n        ans = 0\n        if begin >= end: return 1\n        for i in range(begin, end + 1):\n            left = self.dfs(begin, i - 1)\n            right = self.dfs(i + 1, end)\n            ans += left * right\n        return ans\n\n    def numTrees(self, n: int) -> int:\n        return self.dfs(1, n)\n```\n\n上面这段代码能求出正确答案，但是必然会超时的。一种想法就是保存每次求的子树的结果，不过多说了。仔细分析，因为我们只关注树的个数，对于树本身无所谓，所以两个节点数一样的序列是等价的。例如：`1, 2, 3`和`4, 5, 6`能构成的不同搜索二叉树数目是一样的，因此没有必要使用`begin`和`end`来标志序列的开头结尾，我们只需要一个变量记录序列长度即可。\n\n设![image](https://cdn.nlark.com/yuque/__latex/f2e148970dcc35ac1f60e85a8cfe7f78.svg)表示长度为`n`的序列能组成的二叉搜索树的个数。因为数字本身并没有意义，不妨设这个序列是`1...n`，则有![image](https://cdn.nlark.com/yuque/__latex/a8c6303d3da6ae8713f50c6868826c7d.svg)。其实就是左子树的个数乘以右子树的个数，对每一个节点轮流作为根节点并求和。\n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        C = [1] + [0] * n\n        for k in range(1, n + 1):  # 填充 C[k]\n            for i in range(1, k + 1):\n                C[k] += C[i - 1] * C[k - i]\n        return C[n]\n```\n\n#### 97. 交错字符串\n给定三个字符串`s1、s2、s3`，请你帮忙验证`s3`是否是由`s1`和`s2`交错组成的。\n\n两个字符串`s`和`t`交错的定义与过程如下，其中每个字符串都会被分割成若干非空子字符串：\n\n+ `s = s1 + s2 + ... + sn`\n+ `t = t1 + t2 + ... + tm`\n+ `|n - m| <= 1`\n+ 交错是`s1 + t1 + s2 + t2 + s3 + t3 + ...`或者`t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n注意：`a + b`意味着字符串`a`和`b`连接。\n\n![](/yuque/0/2023/png/1561375/1686020840210-5bc060dc-c72a-43c0-9708-9e90cd4d4f59.png)\n\n> [https://leetcode.cn/problems/interleaving-string](https://leetcode.cn/problems/interleaving-string)\n>\n\n**思路分析：**\n\n1. 只有当`|s1| + |s2| == |s3|`时才有可能匹配；\n2. 假设`dp(i, j)`表示`s1`前`i`个字符与`s2`前`j`个字符能否交替构成`s3`的前`i + j`个字符\n    1. 若`s1[i] == s3[i + j]`则`dp(i, j) = dp(i - 1, j)`；\n    2. 若`s2[j] == s3[i + j]`则`dp(i, j) = dp(i, j - 1)`；\n\n```python\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3): return False\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        s1, s2, s3 = \" \" + s1, \" \" + s2, \" \" + s3\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if s3[i + j] not in [s1[i], s2[j]]:\n                    continue\n                if i > 0 and s1[i] == s3[i + j]:\n                    dp[i][j] |= dp[i - 1][j]\n                if j > 0 and s2[j] == s3[i + j]:\n                    dp[i][j] |= dp[i][j - 1]\n        return dp[m][n]\n```\n\n#### 98. 验证二叉搜索树\n给你一个二叉树的根节点`root`，判断其是否是一个有效的二叉搜索树。\n\n有效二叉搜索树定义如下：\n\n+ 节点的左子树只包含**小于**当前节点的数。\n+ 节点的右子树只包含**大于**当前节点的数。\n+ 所有左子树和右子树自身必须也是二叉搜索树。\n\n> [https://leetcode.cn/problems/validate-binary-search-tree](https://leetcode.cn/problems/validate-binary-search-tree)\n>\n\n```python\nclass Solution:\n    def dfs(self, root, lb=None, ub=None):\n        \"\"\" 判断某个树是否所有元素都在 (lb, rb) 之间 \"\"\"\n        if root is None: return True\n        if lb is not None and root.val <= lb: return False\n        if ub is not None and root.val >= ub: return False\n        if not self.dfs(root.left, lb=lb, ub=root.val): return False\n        return self.dfs(root.right, lb=root.val, ub=ub)\n\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        return self.dfs(root)\n```\n\n#### 99. 恢复二叉搜索树\n给你二叉搜索树的根节点`root`，该树中的恰好两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。\n\n![](/yuque/0/2023/png/1561375/1686825392298-230656f6-bbc8-4893-954a-87c418795a16.png)![](/yuque/0/2023/png/1561375/1686825398600-c4a7bf02-4efd-4918-bd80-fbfc0552a461.png)\n\n> [https://leetcode.cn/problems/recover-binary-search-tree/](https://leetcode.cn/problems/recover-binary-search-tree/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.queue = []\n\n    def dfs(self, root):\n        \"\"\" 中序遍历二叉树 \"\"\"\n        if root is None: return\n        self.dfs(root.left)\n        self.queue.append(root)\n        self.dfs(root.right)\n\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.queue.clear()\n        self.dfs(root)\n        i, j = 0, len(self.queue) - 1\n        while True:\n            if self.queue[i].val < self.queue[i + 1].val:\n                i += 1\n            elif self.queue[j].val > self.queue[i].val:\n                j -= 1\n            else: break\n        self.queue[i].val, self.queue[j].val = self.queue[j].val, self.queue[i].val\n```\n\n#### 100. 相同的树\n给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n> [https://leetcode.cn/problems/same-tree/](https://leetcode.cn/problems/same-tree/)\n>\n\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q: return True\n        if not p or not q: return False\n        if p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n\n\n\n\n\n\n'),
       (22, 22, '#### 101. 对称二叉树\n给你一个二叉树的根节点`root`， 检查它是否轴对称。\n\n> [https://leetcode.cn/problems/symmetric-tree/submissions/](https://leetcode.cn/problems/symmetric-tree/submissions/)\n>\n\n```python\nclass Solution:\n    def check(self, left, right):\n        \"\"\" 检查两颗树是否互为镜像关系 \"\"\"\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        if not self.check(left.left, right.right):\n            return False\n        return self.check(left.right, right.left)\n\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        return self.check(root.left, root.right)\n```\n\n#### 102. 二叉树的层序遍历\n给你二叉树的根节点`root`，返回其节点值的层序遍历（即逐层地，从左到右访问所有节点）。\n\n> [https://leetcode.cn/problems/binary-tree-level-order-traversal/](https://leetcode.cn/problems/binary-tree-level-order-traversal/)\n>\n\n```python\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans, path = [], [root]\n        while path:\n            tmp = []\n            n = len(path)\n            for i in range(n):\n                ele = path[i]\n                if not ele: continue\n                tmp.append(ele.val)\n                path.append(ele.left)\n                path.append(ele.right)\n            path = path[n:]\n            if tmp: ans.append(tmp)\n        return ans\n```\n\n#### 103. 二叉树的锯齿形层序遍历\n给你二叉树的根节点`root`，返回其节点值的锯齿形层序遍历（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n> [https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)\n>\n\n```python\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        cnt = 0\n        ans, path = [], [root]\n        while path:\n            tmp = []\n            n = len(path)\n            for i in range(n):\n                ele = path[i]\n                if not ele: continue\n                tmp.append(ele.val)\n                path.append(ele.left)\n                path.append(ele.right)\n            if tmp:\n                if cnt % 2 == 1:\n                    tmp = tmp[::-1]\n                ans.append(tmp)\n            cnt += 1\n            path = path[n:]\n        return ans\n```\n\n#### 104. 二叉树的最大深度\n给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n> [https://leetcode.cn/problems/maximum-depth-of-binary-tree/](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n>\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None: return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return max(left, right) + 1\n```\n\n#### 105. 从前序与中序遍历序列构造二叉树\n给定两个整数数组`preorder`和`inorder`，其中`preorder`是二叉树的先序遍历，`inorder`是同一棵树的中序遍历，请构造二叉树并返回其根节点。\n\n> [https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal)\n>\n\n```python\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        root = TreeNode(preorder[0])\n        if len(preorder) == 1 and len(inorder) == 1:\n            return root\n        idx = inorder.index(preorder[0])\n        in_left = inorder[0: idx]\n        in_right = inorder[idx + 1:]\n        if in_left:\n            pre_left = preorder[1: len(in_left) + 1]\n            root.left = self.buildTree(pre_left, in_left)\n        if in_right:\n            pre_right = preorder[len(in_left) + 1:]\n            root.right = self.buildTree(pre_right, in_right)\n        return root\n```\n\n#### 106. 从中序与后序遍历序列构造二叉树\n给定两个整数数组`inorder`和`postorder`，其中`inorder`是二叉树的中序遍历，`postorder`是同一棵树的后序遍历，请你构造并返回这颗二叉树。\n\n> [https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal)\n>\n\n```python\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        root = TreeNode(postorder[-1])\n        if len(inorder) == 1 and len(postorder) == 1:\n            return root\n        idx = inorder.index(postorder[-1])\n        in_left = inorder[:idx]\n        in_right = inorder[idx + 1:]\n        if in_left:\n            post_left = postorder[0: len(in_left)]\n            root.left = self.buildTree(in_left, post_left)\n        if in_right:\n            post_right = postorder[len(in_left): -1]\n            root.right = self.buildTree(in_right, post_right)\n        return root\n```\n\n#### 107. 二叉树的层序遍历Ⅱ\n给你二叉树的根节点`root`，返回其节点值自底向上的层序遍历（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。\n\n> [https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n>\n\n```python\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans, path = [], [root]\n        while path:\n            tmp = []\n            n = len(path)\n            for i in range(n):\n                ele = path[i]\n                if not ele: continue\n                tmp.append(ele.val)\n                path.append(ele.left)\n                path.append(ele.right)\n            path = path[n:]\n            if tmp: ans.append(tmp)\n        return ans[::-1]\n```\n\n#### 108. 将有序数组转换为二叉搜索树\n给你一个整数数组`nums`，其中元素已经按升序排列，请你将其转换为一棵高度平衡二叉搜索树。\n\n高度平衡二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过`1`的二叉树。\n\n> [https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree)\n>\n\n```python\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        mid = (len(nums) - 1) // 2\n        root = TreeNode(nums[mid])\n        if len(nums) == 1: return root\n        left, right = nums[:mid], nums[mid + 1:]\n        if left: root.left = self.sortedArrayToBST(left)\n        if right: root.right = self.sortedArrayToBST(right)\n        return root\n```\n\n#### 109. 有序链表转换二叉搜索树\n给定一个单链表的头节点`head`，其中的元素按升序排序 ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差不超过 1。\n\n> [https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree)\n>\n\n```python\nclass Solution:\n    def buildTree(self, h, n):\n        \"\"\" 根据给定的长度为 n 的链表构造搜索树 \"\"\"\n        if n == 1:\n            return TreeNode(h.val)\n        head = ListNode(next=h)\n        tail, mid = head, (n - 1) // 2\n        for i in range(mid):\n            tail = tail.next\n        root = TreeNode(tail.next.val)\n        right = tail.next.next\n        if tail != head:\n            tail.next = None\n            root.left = self.buildTree(head.next, mid)\n        root.right = self.buildTree(right, n - mid - 1)\n        return root\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        cnt, p = 0, head\n        while p:\n            cnt +=1\n            p = p.next\n        if not cnt: return None\n        return self.buildTree(head, cnt)\n```\n\n#### 110. 平衡二叉树\n给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：\n\n一个二叉树每个节点的左右两个子树的高度差的绝对值不超过`1`。\n\n> [https://leetcode.cn/problems/balanced-binary-tree/](https://leetcode.cn/problems/balanced-binary-tree/)\n>\n\n```python\nclass Solution:\n    def check(self, root):\n        \"\"\" 返回 root 的最大高度，如果 root 不平衡返回 -1 \"\"\"\n        if root is None: return 0\n        left = self.check(root.left)\n        if left < 0: return -1\n        right = self.check(root.right)\n        if right < 0: return -1\n        if abs(left - right) > 1: return -1\n        return max(left, right) + 1\n\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        return self.check(root) >= 0\n```\n\n#### 111. 二叉树的最小深度\n给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n**说明：**叶子节点是指没有子节点的节点。\n\n> [https://leetcode.cn/problems/minimum-depth-of-binary-tree/](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n>\n\n```python\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        \"\"\" 返回 root 的最小深度 \"\"\"\n        if root is None: return 0\n        left = self.minDepth(root.left)\n        right = self.minDepth(root.right)\n        # 如果节点的某个子树是 None，那么最短长度只能看另一个节点\n        if 0 in [left, right]: return left + right + 1\n        return min(left, right) + 1\n```\n\n#### 112. 路径总和\n给你二叉树的根节点`root`和一个表示目标和的整数`targetSum`。判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和`targetSum`。如果存在，返回`true`；否则，返回 `false`。叶子节点是指没有子节点的节点。\n\n> [https://leetcode.cn/problems/path-sum](https://leetcode.cn/problems/path-sum)\n>\n\n```python\ndef isLeaf(root):\n    \"\"\" 判断节点是否是叶子节点 \"\"\"\n    if root is None: return False\n    return root.left is None and root.right is None\n    \nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        \"\"\" 返回以 root 为根的树能否找到一条和为 targetSum 的路径 \"\"\"\n        if root is None: return False\n        if isLeaf(root) and root.val == targetSum: return True\n        if self.hasPathSum(root.left, targetSum - root.val): return True\n        return self.hasPathSum(root.right, targetSum - root.val)\n```\n\n#### 113. 路径总和Ⅱ\n给你二叉树的根节点`root`和一个整数目标和`targetSum`，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。叶子节点是指没有子节点的节点。\n\n> [https://leetcode.cn/problems/path-sum-ii](https://leetcode.cn/problems/path-sum-ii)\n>\n\n```python\ndef isLeaf(root):\n    \"\"\" 判断节点是否是叶子节点 \"\"\"\n    if root is None: return False\n    return root.left is None and root.right is None\n\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n\n    def dfs(self, root, targetSum):\n        \"\"\" 从 root 寻找所有和为 targetSum 的路径 \"\"\"\n        if root is None: return\n        if isLeaf(root) and root.val == targetSum:\n            self.path.append(root.val)\n            self.ans.append(self.path[:])\n            self.path.pop()\n        self.path.append(root.val)\n        self.dfs(root.left, targetSum - root.val)\n        self.dfs(root.right, targetSum - root.val)\n        self.path.pop()\n\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        self.ans.clear()\n        self.path.clear()\n        self.dfs(root, targetSum)\n        return self.ans\n```\n\n#### 114. 二叉树展开为链表\n给你二叉树的根结点`root`，请你将它展开为一个单链表：\n\n+ 展开后的单链表应该同样使用`TreeNode`，其中`right`子指针指向链表中下一个结点，而左子指针始终为`null`。\n+ 展开后的单链表应该与二叉树先序遍历顺序相同。\n\n> [https://leetcode.cn/problems/flatten-binary-tree-to-linked-list](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list)\n>\n\n```python\nclass Solution:\n    def dfs(self, root):\n        \"\"\" 先序遍历二叉树 \"\"\"\n        if root is None: return None\n        left = self.dfs(root.left)\n        right = self.dfs(root.right)\n        head = root\n        root.left = None\n        root.right = left\n        if root.right is None: root.right = right\n        else:\n            while root.right is not None:\n                root = root.right\n            root.right = right\n        return head\n\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        return self.dfs(root)\n```\n\n#### 115. 不同的子序列\n给你两个字符串`s`和`t`，统计并返回在`s`的子序列中`t`出现的个数。题目数据保证答案符合`32`位带符号整数范围。\n\n> [https://leetcode.cn/problems/distinct-subsequences/](https://leetcode.cn/problems/distinct-subsequences/)\n>\n\n```python\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][n] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                dp[i][j] = dp[i + 1][j]\n                if s[i] == t[j]:\n                    dp[i][j] += dp[i + 1][j + 1]\n        return dp[0][0]\n```\n\n#### 116. 填充每一个节点的下一个右侧节点指针\n给定一个完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n```python\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个`next`指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将`next`指针设置为`NULL`。初始状态下，所有`next`指针都被设置为`NULL`。\n\n![](/yuque/0/2023/png/1561375/1687681325932-624f3e4d-17d0-41c9-8a6e-eb6824239f83.png)\n\n> [https://leetcode.cn/problems/populating-next-right-pointers-in-each-node](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node)\n>\n\n```python\nclass Solution:\n    def connect(self, root: \'Optional[Node]\') -> \'Optional[Node]\':\n        queue = [root]\n        while len(queue) > 0:\n            n = len(queue)\n            for i in range(n):\n                item = queue[i]\n                if item is None: return root\n                item.next = queue[i + 1] if i < n - 1 else None\n                queue.append(item.left)\n                queue.append(item.right)\n            queue = queue[n:]\n```\n\n#### 117. 填充每一个节点的下一个右侧节点指针Ⅱ\n给定一个二叉树，二叉树定义如下：\n\n```python\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个`next`指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将`next`指针设置为`NULL`。初始状态下，所有`next`指针都被设置为`NULL`。\n\n![](/yuque/0/2023/png/1561375/1687682040714-d8745184-ee86-49e2-8ae3-fc020d4c3d40.png)\n\n> [https://leetcode.cn/problems/populating-next-right-pointers-in-each-node](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node)\n>\n\n```python\nclass Solution:\n    def connect(self, root: \'Node\') -> \'Node\':\n        if root is None: \n            return None\n        queue = [root]\n        while len(queue) > 0:\n            n = len(queue)\n            for i in range(n):\n                item = queue[i]\n                item.next = queue[i + 1] if i < n - 1 else None\n                if item.left: queue.append(item.left)\n                if item.right: queue.append(item.right)\n            queue = queue[n:]\n        return root\n```\n\n#### 118. 杨辉三角\n给定一个非负整数`numRows`_，_生成「杨辉三角」的前`numRows`行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n> [https://leetcode.cn/problems/pascals-triangle/](https://leetcode.cn/problems/pascals-triangle/)\n>\n\n```python\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = []\n        for i in range(numRows):\n            tmp = [0] * (i + 1)\n            for j in range(i + 1):\n                if j == 0 or j == i:\n                    tmp[j] = 1\n                else:\n                    tmp[j] = ans[i - 1][j] + ans[i - 1][j - 1]\n            ans.append(tmp)\n        return ans\n```\n\n#### 119. 杨辉三角Ⅱ\n给定一个非负索引`rowIndex`，返回「杨辉三角」的第`rowIndex`行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n> [https://leetcode.cn/problems/pascals-triangle-ii/](https://leetcode.cn/problems/pascals-triangle-ii/)\n>\n\n```python\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        prev = [1]\n        for i in range(rowIndex):\n            nxt = [1] * (i + 2)\n            for j in range(1, i + 2):\n                nxt[j] = prev[j] + prev[j - 1] if j < i + 1 else 1\n            prev = nxt\n        return prev\n```\n\n#### 120. 三角形最小路径和\n给定一个三角形`triangle`，找出自顶向下的最小路径和。\n\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是下标与上一层结点下标相同或者等于 上一层结点下标`+1`的两个结点。也就是说，如果正位于当前行的下标`i`，那么下一步可以移动到下一行的下标`i`或`i + 1`。\n\n> [https://leetcode.cn/problems/triangle](https://leetcode.cn/problems/triangle)\n>\n\n```python\nclass Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        n = len(triangle)\n        for i in range(n - 2, -1, -1):\n            line = triangle[i + 1]\n            for j in range(i + 1):\n                triangle[i][j] += min(line[j], line[j + 1])\n        return triangle[0][0]\n```\n\n#### 121. 买卖股票的最佳时机\n给定一个数组`prices`，它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格。\n\n你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回`0`。\n\n> [https://leetcode.cn/problems/best-time-to-buy-and-sell-stock](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock)\n>\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        lowpoint, profit = -1, 0\n        for price in prices:\n            if lowpoint < 0 or price < lowpoint:\n                lowpoint = price\n            elif price - lowpoint > profit:\n                profit = price - lowpoint\n        return profit\n```\n\n#### 122. 买卖股票的最佳时机Ⅱ\n给你一个整数数组`prices`，其中`prices[i]`表示某支股票第`i`天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。返回你能获得的最大利润。\n\n> [https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii)\n>\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] <= prices[i - 1]: continue\n            profit += (prices[i] - prices[i - 1])\n        return profit\n```\n\n#### 124. 二叉树中的最大路径\n二叉树中的路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。路径和是路径中各节点值的总和。给你一个二叉树的根节点`root`，返回其最大路径和 。\n\n![](/yuque/0/2023/png/1561375/1692444245414-bb6e907d-8266-4de1-93a9-9c2623c8378f.png)\n\n> [https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.maxSum = None\n\n    def getValue(self, root):\n        \"\"\" 计算每一个节点的价值，价值就是从这个节点出发能构成的最大和 \"\"\"\n        if not root: return 0\n        if not root.left and not root.right: \n            if self.maxSum is None or self.maxSum < root.val:\n                self.maxSum = root.val\n            return root.val\n        left = self.getValue(root.left)\n        right = self.getValue(root.right)\n        tmp = max(0, left) + max(0, right) + root.val\n        self.maxSum = max(self.maxSum, tmp)\n        return max(left, right, 0) + root.val\n\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        self.maxSum = None\n        self.getValue(root)\n        return self.maxSum\n```\n\n#### 128. 最长连续序列\n给定一个未排序的整数数组`nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为`O(n)`的算法解决此问题。\n\n> [https://leetcode.cn/problems/longest-consecutive-sequence/description/](https://leetcode.cn/problems/longest-consecutive-sequence/description/)\n>\n\n思路：枚举每一个起点数`n`，看看以`n`开头的连续数字的长度，选出最大的就可以了。\n\n```python\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        ans = 0\n        num_set = set(nums)\n        for n in num_set:\n            if n - 1 in num_set: continue\n            tmp = 1\n            while n + 1 in num_set:\n                n += 1\n                tmp += 1\n            if tmp > ans: ans = tmp\n        return ans\n```\n\n#### 129. 求根节点到叶节点数字之和\n给你一个二叉树的根节点`root`，树中每个节点都存放有一个`0`到`9`之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n\n计算从根节点到叶节点生成的所有数字之和 。叶节点是指没有子节点的节点。\n\n> [https://leetcode.cn/problems/sum-root-to-leaf-numbers](https://leetcode.cn/problems/sum-root-to-leaf-numbers)\n>\n\n```python\ndef isLeaf(root):\n    \"\"\" 判断节点是否是叶子节点 \"\"\"\n    if root is None: return False\n    return root.left is None and root.right is None\n\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        \n    def dfs(self, root, value):\n        if isLeaf(root):\n            self.ans.append(value * 10 + root.val)\n            return\n        if root.left: self.dfs(root.left, value * 10 + root.val)\n        if root.right: self.dfs(root.right, value * 10 + root.val)\n\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        self.ans.clear()\n        self.dfs(root, 0)\n        return sum(self.ans)\n```\n\n#### 130. 被围绕的区域\n给你一个`m x n`的矩阵`board`，由若干字符`\'X\'`和`\'O\'`，找到所有被`\'X\'`围绕的区域，并将这些区域里所有的`\'O\'`用`\'X\'`填充。\n\n**思路分析：**每一个未被包围的`O`都直接或间接的与边缘的`O`相邻，因此我们直接从边缘的`O`开始深度搜索。\n\n> [https://leetcode.cn/problems/surrounded-regions/](https://leetcode.cn/problems/surrounded-regions/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.board = []\n        self.m, self.n = 0, 0\n\n    def dfs(self, i, j):\n        board = self.board\n        m, n = self.m, self.n\n        if i < 0 or i >= m: return\n        if j < 0 or j >= n: return\n        if board[i][j] != \'O\': return\n        board[i][j] = \'A\'\n        self.dfs(i - 1, j)\n        self.dfs(i + 1, j)\n        self.dfs(i, j - 1)\n        self.dfs(i, j + 1)\n\n    def recover(self):\n        board = self.board\n        for i in range(self.m):\n            for j in range(self.n):\n                if board[i][j] == \"X\": continue\n                board[i][j] = \'X\' if board[i][j] == \'O\' else \'O\'\n\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        self.board = board\n        self.m = len(board)\n        self.n = len(board[0])\n        for i in range(self.m):\n            self.dfs(i, 0)\n            self.dfs(i, self.n - 1)\n        for j in range(1, self.n - 1):\n            self.dfs(0, j)\n            self.dfs(self.m - 1, j)\n        self.recover()\n```\n\n#### 131. 分割回文串\n给你一个字符串`s`，请你将`s`分割成一些子串，使每个子串都是回文串。返回`s`所有可能的分割方案。\n\n回文串是正着读和反着读都一样的字符串。\n\n> [https://leetcode.cn/problems/palindrome-partitioning/](https://leetcode.cn/problems/palindrome-partitioning/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.map = {}\n        self.ans = []\n        self.path = []\n\n    def judge(self, s):\n        \"\"\" 判断字符串是否是回文串 \"\"\"\n        if s not in self.map:\n            self.map[s] = (s == s[::-1])\n        return self.map[s]\n\n    def dfs(self, s):\n        \"\"\" 递归遍历分解字符串 \"\"\"\n        if not s:\n            self.ans.append(self.path[:])\n            return\n        for i in range(len(s)):\n            before, after = s[:i + 1], s[i + 1:]\n            if not self.judge(before): continue\n            self.path.append(before)\n            self.dfs(after)\n            self.path.pop()\n\n    def partition(self, s: str) -> List[List[str]]: \n        self.map.clear()\n        self.ans.clear()\n        self.path.clear()\n        self.dfs(s)\n        return self.ans\n```\n\n#### 132. 分割回文串Ⅱ\n给你一个字符串`s`，请你将`s`分割成一些子串，使每个子串都是回文。返回符合要求的最少分割次数 。\n\n> 输入：s = \"aab\"\n>\n> 输出：1\n>\n> 解释：只需一次分割就可将 s 分割成 [\"aa\",\"b\"] 这样两个回文子串。\n>\n\n> [https://leetcode.cn/problems/palindrome-partitioning-ii/](https://leetcode.cn/problems/palindrome-partitioning-ii/)\n>\n\n**动态规划：**设`dp[i]`表示将字符串下标范围为`[0, i]`的子串分割开来的最少分割次数，那么对于任意一个字符串`s`最少分割次数就是`dp[n - 1]`，其中`n`是字符串的长度。考虑所有满足条件的分割点`j`使得`s = s[0, j] + s[j + 1, n - 1]`和`s[j + 1, n - 1]`是回文串成立。那么状态转移方程可以写成：![image](https://cdn.nlark.com/yuque/__latex/3ae44c56acf62198ed8d46203d71e262.svg)，注意方程里的`j`必然满足`s[j + 1, n - 1]`是回文串。\n\n至于判断一个字符串`s`里面的某一个子串是否是回文串可以简单做一个预处理，设`isLevel[i, j]`表示`s[i, j]`是否是回文串，可以很轻易得出状态转移方程：\n\n![image](https://cdn.nlark.com/yuque/__latex/123a21b2653c64a9ef5fca6b8a2a13b2.svg)\n\n```python\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * n\n        isLevel = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                isLevel[i][j] = (s[i] == s[j]) and isLevel[i + 1][j - 1]\n        for i in range(1, n):\n            tmp = n\n            if isLevel[0][i]: continue\n            for j in range(i):\n                if not isLevel[j + 1][i]: continue\n                tmp = min(dp[j] + 1, tmp)\n            dp[i] = tmp\n        return dp[n - 1]\n```\n\n#### 133. 克隆图\n给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。图中的每个节点都包含它的值`val（int）`和其邻居的列表`list[Node]`。\n\n```python\nclass Solution:\n    def __init__(self):\n        self.nodes = {}\n\n    def clone(self, node):\n        \"\"\" 拷贝 node 节点并返回拷贝出来的节点 \"\"\"\n        if not node: return None\n        if node in self.nodes:\n            return self.nodes[node]\n        newNode = Node(node.val)\n        self.nodes[node] = newNode\n        for nb in node.neighbors:\n            newNode.neighbors.append(self.clone(nb))\n        return newNode\n\n    def cloneGraph(self, node: \'Node\') -> \'Node\':\n        self.nodes.clear()\n        return self.clone(node)\n```\n\n#### 134. 加油站\n在一条环路上有`n`个加油站，其中第`i`个加油站有汽油`gas[i]`升。\n\n你有一辆油箱容量无限的的汽车，从第`i`个加油站开往第`i+1`个加油站需要消耗汽油`cost[i]`升。你从其中的一个加油站出发，开始时油箱为空。\n\n给定两个整数数组`gas`和`cost`，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回`-1`。如果存在解，则保证它是唯一的。\n\n> [https://leetcode.cn/problems/gas-station](https://leetcode.cn/problems/gas-station)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.gas = None\n        self.cost = None\n\n    def go_from_i(self, i):\n        \"\"\" 返回从下标为 i 的加油站出发能到达的目的地下标以及是否是解 \"\"\"\n        rest_gas = 0\n        gas, cost = self.gas[:], self.cost[:]\n        while gas[i] >= 0:\n            rest_gas += gas[i]\n            if rest_gas < cost[i]: break\n            gas[i] = -1\n            rest_gas -= cost[i]\n            i = (i + 1) % len(gas)\n        return i, gas[i] < 0\n\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        self.gas = gas\n        self.cost = cost\n        i, n = 0, len(gas)\n        while i < n:\n            dest, ok = self.go_from_i(i)\n            if ok: return i\n            if dest < i: return -1\n            i = dest + 1\n        return -1\n```\n\n#### 135. 分发糖果\n`n`个孩子站成一排。给你一个整数数组`ratings`表示每个孩子的评分。\n\n你需要按照以下要求，给这些孩子分发糖果：\n\n+ 每个孩子至少分配到 1 个糖果。\n+ 相邻两个孩子评分更高的孩子会获得更多的糖果。\n\n请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。\n\n> [https://leetcode.cn/problems/candy/description/](https://leetcode.cn/problems/candy/description/)\n>\n\n```python\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        left = [1]\n        ans, right = 0, 1\n        n = len(ratings)\n        for i in range(1, n):\n            left.append(left[i - 1] + 1 if ratings[i] > ratings[i - 1] else 1)\n        for i in range(n - 2, -1, -1):\n            right = right + 1 if ratings[i] > ratings[i + 1] else 1\n            ans += max(right, left[i])\n        return ans + left[-1]\n```\n\n#### 137. 只出现一次的数字Ⅱ\n给你一个整数数组`nums`，除某个元素仅出现一次外，其余每个元素都恰出现三次 。请你找出并返回那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。\n\n> [https://leetcode.cn/problems/single-number-ii/description/](https://leetcode.cn/problems/single-number-ii/description/)\n>\n\n思路：对于第`i`位二进制位，我们将所有数字这一位相加对3取余，那么结果就是唯一的那个数字的该位结果。\n\n```c\nint singleNumber(int* nums, int numsSize){\n    int ans = 0;\n    for (int i = 0; i < 32; i++) {\n        int sum = 0;\n        for (int j = 0; j < numsSize; j++) sum += (nums[j] >> i) & 1;\n        if (sum % 3 == 0) continue;\n        ans |= (1u << i);\n    }\n    return ans;\n}\n```\n\n#### 138. 随机链表的复制\n给你一个长度为`n`的链表，每个节点包含一个额外增加的随机指针`random`，该指针可以指向链表中的任何节点或空节点。构造这个链表的深拷贝。 深拷贝应该正好由`n`个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的`next`指针和`random`指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。\n\n> [https://leetcode.cn/problems/copy-list-with-random-pointer/](https://leetcode.cn/problems/copy-list-with-random-pointer/)\n>\n\n```python\nclass Solution:\n    def __init__(self):\n        self.node_map = {}\n\n    def getCloneNode(self, node):\n        if not node: return None\n        if node not in self.node_map:\n            clone = Node(node.val)\n            self.node_map[node] = clone\n        clone = self.node_map[node]\n        return clone\n\n    def dfs(self, node):\n        if not node: return None\n        newNode = self.getCloneNode(node)\n        newNode.next = self.getCloneNode(node.next)\n        newNode.random = self.getCloneNode(node.random)\n        self.dfs(node.next)\n        return newNode\n\n    def copyRandomList(self, head: \'Optional[Node]\') -> \'Optional[Node]\':\n        self.node_map.clear()\n        return self.dfs(head)\n```\n\n#### 139. 单词拆分\n给你一个字符串`s`和一个字符串列表`wordDict`作为字典。请你判断是否可以利用字典中出现的单词拼接出`s`。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n> [https://leetcode.cn/problems/word-break/description/](https://leetcode.cn/problems/word-break/description/)\n>\n\n**动态规划：**设`dp[i]`表示`s`的前`i`个字符（即`s[0, i)`）能否由给定的字典构成。我们考虑任意一个分割点![image](https://cdn.nlark.com/yuque/__latex/3ab9c1228e2d0e324a35d0a36a2b0c10.svg)，若`s[0, j)`与`s[j, i)`均可由字典构成，那么显然`s`也可以由字典构成。而`s[0, j) = dp[j]`，因此可以得出下面的状态转移方程：\n\n![image](https://cdn.nlark.com/yuque/__latex/bc4df3a37ee50f70f9b12b395e8bb806.svg)\n\n我们检查`s[j: i]`是否由字典构成的时候，仅需要看它是否存在于字典中即可，而不需要费劲判断它是否可以由多个单词组成。下面做一波解释：\n\n假设`s`可以被分解成能由字典构成的三部分`A`+`B`+`C`，当我判定整个`s`能否由字典构成的时候必有结果为`True`的一种情形：使用`j`将整个`s`划分为`AB`+`C`，其中`AB`在前面的计算中会得到结果`True`，而`C`本身就在字典中，所以根据状态转移方程最终结果为`True`。\n\n```python\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if not dp[j]: continue\n                if s[j: i] not in wordDict: continue\n                dp[i] = True\n                break\n        return dp[len(s)]\n```\n\n#### 140. 单词拆分Ⅱ\n给定一个字符串`s`和一个字符串字典`wordDict`，在字符串`s`中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。注意：词典中的同一个单词可能在分段中被重复使用多次。\n\n```python\nclass Solution:\n    def __init__(self):\n        self.ans = []\n        self.path = []\n        self.wordDict = None\n\n    def dfs(self, s):\n        \"\"\" 将 s 分割成一系列单词 \"\"\"\n        if not s:\n            self.ans.append(\' \'.join(self.path))\n            return\n        for i in range(1, len(s) + 1):\n            tmp = s[:i]\n            if tmp not in self.wordDict: continue\n            self.path.append(tmp)\n            self.dfs(s[i:])\n            self.path.pop()\n\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        self.ans.clear()\n        self.path.clear()\n        self.wordDict = wordDict\n        self.dfs(s)\n        return self.ans\n```\n\n#### 142. 环形链表Ⅱ\n给定一个链表的头节点`head`，返回链表开始入环的第一个节点。 如果链表无环，则返回`null`。如果链表中有某个节点，可以通过连续跟踪`next`指针再次到达，则链表中存在环。\n\n> [https://leetcode.cn/problems/linked-list-cycle-ii/description/](https://leetcode.cn/problems/linked-list-cycle-ii/description/)\n>\n\n**思路解析：**我们称入环的第一个节点为入口节点，有以下假设：\n\n+ 从头结点到入口节点需要`a`步。\n+ 环内行走一圈回到原点需要`b`步。\n+ 快慢指针走过的步数分别记为`f`和`s`。\n\n我们知道，每次行走快指针的步数都是慢指针的 2 倍，所以等式`f = 2s`恒成立。当快慢指针在环内相遇时，快指针一定比慢指针多走环距离的整数倍即等式`f = s + nb`恒成立。联立两个等式可以得出以下等式：![image](https://cdn.nlark.com/yuque/__latex/eb903f63b55a57e32072fc62542d63db.svg)。经过观察可以发现如果慢指针再走`a`步即慢指针共走`a + nb`步时慢指针必然指向环内的起始节点。\n\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while True:\n            if not fast or not fast.next: return None\n            slow = slow.next\n            fast = fast.next.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n```\n\n#### 144. 二叉树的前序遍历\n给你二叉树的根节点`root`，返回它节点值的前序遍历。\n\n> [https://leetcode.cn/problems/binary-tree-preorder-traversal/description/](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)\n>\n\n```python\nclass Solution:\n    def dfs(self, root, path):\n        \"\"\" 先序遍历二叉树 \"\"\"\n        if root is None: return\n        path.append(root.val)\n        self.dfs(root.left, path)\n        self.dfs(root.right, path)\n\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        path = []\n        self.dfs(root, path)\n        return path\n```\n\n#### 145. 二叉树的后序遍历\n给你二叉树的根节点`root`，返回它节点值的后序遍历。\n\n> [https://leetcode.cn/problems/binary-tree-postorder-traversal/](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n>\n\n```python\nclass Solution:\n    def dfs(self, root, path):\n        \"\"\" 后序遍历二叉树 \"\"\"\n        if root is None: return\n        self.dfs(root.left, path)\n        self.dfs(root.right, path)\n        path.append(root.val)\n\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        path = []\n        self.dfs(root, path)\n        return path\n```\n\n#### 146. LRU 缓存\n请你设计并实现一个满足`LRU`(最近最少使用) 缓存约束的数据结构。\n\n实现 LRUCache 类：\n\n+ `LRUCache(int capacity)`以正整数作为容量`capacity`初始化`LRU`缓存\n+ `int get(int key)`如果关键字`key`存在于缓存中，则返回关键字的值，否则返回`-1`。\n+ `void put(int key, int value)`如果关键字`key`已经存在，则变更其数据值`value`；如果不存在，则向缓存中插入该组`key-value`。如果插入操作导致关键字数量超过`capacity`，则应该逐出最久未使用的关键字。\n\n函数`get`和`put`必须以`O(1)`的平均时间复杂度运行。\n\n> [https://leetcode.cn/problems/lru-cache/description/](https://leetcode.cn/problems/lru-cache/description/)\n>\n\n```python\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.items = {}\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.items: return -1\n        v = self.items.pop(key)\n        self.items[key] = v\n        return v\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.items:\n            self.items.pop(key)\n        self.items[key] = value\n        if len(self.items) > self.capacity:\n            old_key = list(self.items.keys())[0]\n            self.items.pop(old_key)\n```\n\n#### 147. 对链表进行插入排序\n给定单个链表的头`head`，使用插入排序对链表进行排序，并返回排序后链表的头 。\n\n插入排序算法的步骤:\n\n1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n3. 重复直到所有输入数据插入完为止。\n\n> [https://leetcode.cn/problems/insertion-sort-list/](https://leetcode.cn/problems/insertion-sort-list/)\n>\n\n```python\ndef insert(head, node):\n    \"\"\" 把节点 node 插入到 head 开头的链表中 \"\"\"\n    if head is None:\n        node.next = None\n        return node\n    h = ListNode(next=head)\n    p = h\n    while p.next and p.next.val < node.val:\n        p = p.next\n    node.next = p.next\n    p.next = node\n    return h.next\n\n\nclass Solution:\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        h, p = None, head\n        while p is not None:\n            head = head.next\n            h = insert(h, p)\n            p = head\n        return h\n```\n\n#### 148. 排序链表\n给你链表的头结点`head`，请将其按升序排列并返回排序后的链表。你可以在`O(n log n)`时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n\n> [https://leetcode.cn/problems/sort-list/description/](https://leetcode.cn/problems/sort-list/description/)\n>\n\n**思路：**可以使用插入排序，但是时间复杂度就会变为`n<sup>2</sup>`，因此想到归并排序。每次拿到一个链表先将链表一分为二，然后分别对两边进行排序；排完之后再将两个链表合并起来。\n\n```python\ndef get_mid_node(head: ListNode, tail: ListNode):\n    \"\"\" 返回链表的中间节点 \"\"\"\n    fast, slow = head, head\n    while fast != tail:\n        slow = slow.next\n        fast = fast.next\n        if fast == tail: return slow\n        fast = fast.next\n    return slow\n\n\ndef merge(h1: ListNode, h2: ListNode):\n    \"\"\" 合并两个有序链表 \"\"\"\n    head = ListNode()\n    tail = head\n    while h1 and h2:\n        if h1.val < h2.val:\n            tail.next = h1\n            h1 = h1.next\n        else:\n            tail.next = h2\n            h2 = h2.next\n        tail = tail.next\n    h = h1 if h1 else h2\n    while h:\n        tail.next = h\n        h = h.next\n        tail = tail.next\n    tail.next = None\n    return head.next\n\n\ndef sort(head: ListNode, tail: ListNode = None):\n    \"\"\" 对以 head 为头、tail 为尾的链表排序 \"\"\"\n    if head is None: return None\n    if head.next == tail:\n        head.next = None\n        return head\n    mid = get_mid_node(head, tail)\n    left = sort(head, mid)\n    right = sort(mid, tail)\n    return merge(left, right)\n\n\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        return sort(head)\n```\n\n#### 149. 直线上最多的点\n给你一个数组`points`，其中`points[i] = [xi, yi]`表示平面上的一个点。求最多有多少个点在同一条直线上。\n\n> [https://leetcode.cn/problems/max-points-on-a-line/description/](https://leetcode.cn/problems/max-points-on-a-line/description/)\n>\n\n```python\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        maxn, mp = 0, {}\n        for i in range(n):\n            mp.clear()\n            for j in range(i + 1, n):\n                p1, p2 = points[i], points[j]\n                if p1[0] == p2[0]: key = (p1[0], 0)\n                elif p1[1] == p2[1]: key = (0, p1[1])\n                else:\n                    dx = p2[0] - p1[0]\n                    dy = p2[1] - p1[1]\n                    g = gcd(abs(dx), abs(dy))\n                    dx, dy = dx / g, dy / g\n                    if dx < 0: dx, dy = -dx, -dy\n                    key = (dx, dy)\n                mp[key] = mp.get(key, 0) + 1\n                maxn = max(maxn, mp[key])\n        return maxn + 1\n```\n\n#### 150. 逆波兰表达式求值\n给你一个字符串数组`tokens`，表示一个根据逆波兰表示法表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。\n\n注意：\n\n+ 有效的算符为`\'+\'`、`\'-\'`、`\'*\'`和`\'/\'`。\n+ 每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n+ 两个整数之间的除法总是向零截断 。\n+ 表达式中不含除零运算。\n+ 输入是一个根据逆波兰表示法表示的算术表达式。\n+ 答案及所有中间计算结果可以用 32 位 整数表示。\n\n> [https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)\n>\n\n坑：Python 的整除是向下取整，不是向零取整；所以对于负数做除法的时候要做特殊处理。\n\n```python\nclass Solution:\n    def __init__(self):\n        self.op_map = {\n            \'+\': lambda a, b: a + b,\n            \'-\': lambda a, b: a - b,\n            \'*\': lambda a, b: a * b,\n            \'/\': lambda a, b: (abs(a) // abs(b)) * (1 if a * b > 0 else -1)\n        }\n\n    def is_number(self, string):\n        return string not in self.op_map\n\n    def evalRPN(self, tokens: List[str]) -> int:\n        numbers = []\n        for t in tokens:\n            if self.is_number(t):\n                numbers.append(int(t))\n                continue\n            b = numbers.pop()\n            a = numbers.pop()\n            numbers.append(self.op_map[t](a, b))\n        return numbers[0]\n```\n\n\n\n\n\n\n\n\n\n\n\n'),
       (23, 23, 'Redis是一个完全开源免费的高性能（NOSQL）的key-value数据库。它遵守BSD协议，使用ANSI C语言编写，并支持网络和持久化。Redis拥有极高的性能，每秒可以进行11万次的读取操作和8.1万次的写入操作。\n\n### 环境搭建\n#### 安装\n详细安装教程见下方链接：\n\n[1. 软件安装](https://space-jiangsu.yuque.com/bcsfg9/qr2sxk/diylpm#mR4eh)\n\n#### 配置\nRedis 配置文件是`redis.conf`，根据安装方式的不同其存储路径也不同。一般来说使用 Homebrew 安装则路径位于`/opt/homebrew/etc`下；若手动安装，则`redis.conf`就位于安装包下。\n\n接下来我们将修改配置文件，建议修改前将原来的配置文件备份一下，直接复制在当前目录并命名为`redis.conf.bck`。`redis.conf`里面大致有以下几个值得我们注意的配置：\n\n```python\n# 监听的地址，默认值为 127.0.0.1，这表示只有本机才能访问 redis 服务；\n# 将其值设置为 0.0.0.0 表示所有机器都可以访问 redis 服务；\nbind 127.0.0.1\n\n# 守护进程，默认值 no，表示我在一个控制台窗口打开 redis，这个窗口就不能干别的事情了；\n# 我们将其设置为 yes 表示后台运行；\ndaemonize no\n\n# 访问密码，默认不需要密码，这边我们将其设置为 123456\nrequirepass 123456\n\n# 端口号默认值 6379\nport 6379\n\n# 工作目录，后面运行期间的日志、持久化文件保存的目录\n# 下面的值是 Homebrew 安装的 redis 的默认路径，手动安装默认为 . 表示执行命令时的当前目录\ndir /opt/homebrew/var/db/redis/\n\n# 数据库的数目，默认为 16，编号为 0-15\ndatabases 16\n\n# 设置 redis 能够使用的最大内存\nmaxmemory 512mb\n\n# 日志文件，默认为空，不记录日志，可以指定日志文件名\n# 这边只有文件名，没有路径，则路径使用上面设定的工作目录\nlogfile \"redis.log\"\n```\n\n#### 启动\n启动 Redis 分两种情况：\n\n+ Homebrew 安装，使用命令`brew services start redis`来启动 Redis；\n+ 手动安装，使用命令：`redis-server /usr/local/redis-6.2.6/redis.conf`来启动；\n\n#### 连接\n启动完毕之后，我们就可以连接 Redis 数据库。我们可以在控制台连接，也可以使用图形化界面连接。\n\n##### 控制台连接\n控制台连接使用命令`redis-cli -h 127.0.0.1 -p 6379 -a 123456`，这里面有几个参数：\n\n+ `-h`用来指定要连接的 redis 的 IP 地址，可以省略，默认为`127.0.0.1`；\n+ `-p`用来指定要连接的 redis 的端口号，可以省略，默认为 6379；\n+ `-a`用来指定要连接的 redis 的密码，可以省略；\n\n其中密码的指定除了在连接命令里面添加外，还可以交互式添加。即我们不使用密码连接，进入到交互式控制台后，使用`auth 123456`命令来设置密码。\n\n##### 图形化界面\n首先下载并安装图形化界面软件：\n\n+ [mac安装包](https://pan.baidu.com/s/1NFkc8ORkw3dR0p8ezAbLiQ?pwd=5f3x)\n+ [Windows安装包](https://pan.baidu.com/s/1qiiMSFSHaiYozsokZrtmRg?pwd=csbz)\n\n安装完成后我们新建连接，并填写好对应的主机、端口号、密码等连接信息。下面就可以操作 Redis 数据库了。\n\n### 使用\n#### 数据结构\nRedis 是一中存储键值对的数据库，键一般都是一个字符串，值可以多种多样。下面罗列出了平时能遇到的所有类型：\n\n![](/upload/covers/18c043474f1648c79498c31c2244dd57.png)\n\n#### 命令\n我们在控制台可以使用各种各样的命令来操作 Redis，详细信息可以查阅官方文档：\n\n[Commands](https://redis.io/docs/latest/commands/)\n\n这些命令被分为很多组，例如字符串类型的操作、哈希类型的操作、通用操作等。例如通用操作命令`KEYS`，我想知道这个命令的具体使用方法，除了可以到官方文档查阅，我们还可以直接在 Redis 交互控制台使用`help KEYS`进行查看。\n\n![](/upload/covers/9e97e6f233ba4c8f911fa6f756a1f23c.png)\n\n下面我们按照类别分别看看一些常用命令。\n\n#### 通用命令\n##### KEYS\n`KEYS pattern`命令用于寻找并返回所有满足某模板的键名。\n\n模板中使用`?`匹配任意一个字符，使用`*`匹配任意数量任意字符。\n\n##### DEL\n`DEL key [key...]`命令用于删除若干个键值对，返回成功删除的键值对数目。\n\n##### EXISTS\n`EXISTS key [key...]`命令返回给定的键中存在于库中的数目。\n\n注意：如果指定多个`key`，只能知道存在多少个，至于哪些存在则不知道。\n\n##### EXPIRE\n`EXPIRE key seconds`给一个键设定有效时长，单位是秒，到期后将自动删除该键值对。\n\n##### TTL\n`TTL key`返回某键剩余的有效时长，单位是秒，若返回的数字：\n\n1. `≥0`表示有效时长；\n2. 等于`-1`表示永久有效；\n3. 等于`-2`表示已到期删除；\n\n##### COPY\n`COPY source destination`将键`source`对应的值复制到键名`destination`中。`destination`对应的键不存在就创建，不然怎么叫复制呢？\n\n#### String 命令\n在 Redis 里面 String 不仅仅表示字符串，还能表示整数和浮点数。\n\n##### SET\n`SET key value [EX seconds] [NX]`往数据库里面新增或修改一个 String 类型的数据，默认情况下，键不存在会新增，键存在就是修改。\n\n1. 额外选项`EX seconds`可以为该键设置有效时长，单位是秒；\n2. 额外选项`NX`表示仅新增不修改，即存在该键值对不做修改；\n\n##### GET\n`GET key`返回某个键的值。\n\n##### MSET\n`MSET key value [key value ...]`批量设置键值对，例如`MSET name luyan age 18`。注意使用这样的方式就不能指定`EX | NX`了。\n\n##### MGET\n`MGET key [key...]`批量返回值。\n\n##### 自增\n关于自增有三条命令，如下：\n\n1. `INCR key`对某一整数自增 1，不能对浮点数做自增；\n2. `INCRBY key increment`对某一整数自增指定大小，不能对浮点数自增；\n3. `INCRBYFLOAT key increment`对浮点数自增指定大小，也可以作用到整数上，但作用完之后这个整数会变成浮点数。\n\n##### 自减\n和自增对应，不过命令变为`DECR`：\n\n1. `DECR key`对某一整数自减 1，不能对浮点数做自减；\n2. `DECRBY key increment`对某一整数自减指定大小，不能对浮点数自减；\n\n如果我想对浮点数自减应该怎么操作？答：自增负数即可，例如下面对分数减两分。\n\n```python\nINCRBYFLOAT score -2\n```\n\n注意：自增和自减都必须作用到数字类型上，字符串无法自增和自减。\n\n##### SETNX\n`SETNX key value`仅添加键值对，不修改。与`SET key value NX`等价。\n\n##### SETEX\n`SETEX key seconds value`设置或更新键值对的时候指定有效时长，单位是秒。与`SET key value EX seconds`等价。 \n\n##### GETDEL\n`GETDEL key`删除某个键值对并返回对应的值。\n\n#### Hash 命令\nRedis 的 Hash 与 Java 里面的 Map 结构类似，便于保存对象信息。我们保存对象信息的时候，固然可以将对象序列化成 Json 字符串然后保存。但这样做有个很大的问题，例如我想修改对象里面的某个字段值怎么做？对于这样的需求，如果我们保存的是 Json 串，那么就需要将对象重新序列化成 Json 格式，然后覆盖之前的串。显然，要改就改全部效率很低下，此时就是 Hash 结构大展身手的时候，结构图如下：\n\n![](/upload/covers/cb20cda86dee45418541229afca0fd39.png)\n\n##### HSET\n`HSET key field value [field value ...]`新增或修改一个 Hash。`field`与`value`代表一个键值对，若该键值对不存在就新增否则就修改，允许同时操作多个键值对。\n\n```bash\nHSET heima:user:1 name Jack age 21\n```\n\n##### HGET\n`HGET key field`返回某 key 里某字段的值。\n\n```bash\nHGET heima:user:1 name\n```\n\n##### HMSET\n`HMSET key field value [field value ...]`功能和`HSET`一样。\n\n```bash\nHMSET heima:user:2 name Rose age 18\n```\n\n##### HMGET\n`HMGET key field [field ...]`允许获取多个字段值。\n\n```bash\nHMGET heima:user:1 name age\n```\n\n##### HGETALL\n`HGETALL key`获取 key 指代 Hash 的所有键值对。\n\n```bash\nHGETALL heima:user:1\n```\n\n##### HKEYS\n`HKEYS key`获取 key 指代 Hash 的所有键。\n\n##### HVALS\n`HVALS key`获取 key 指代 Hash 的所有值。\n\n##### HINCRBY\n`HINCRBY key field increment`对 key 指代的哈希字段做自增。\n\n```bash\n# 年龄张三岁\nHINCRBY heima:user:1 age 3\n```\n\n##### HSETNX\n`HSETNX key field value`只新增不修改。\n\n##### HDEL\n`HDEL key field [field ...]`删除哈希字段，可删除多个。\n\n##### HEXISTS\n`HEXISTS key field`返回哈希字段是否存在。\n\n#### List\nList 在 Redis 里面是一个双向链表，支持我们左右两端操作。\n\n##### LPUSH\n`LPUSH key element [element ...]`往列表左端添加元素。\n\n```bash\n# 自左向右依次存储：3 2 1\n# 因为从左端插入，所以最后插入的 3 放在最左边\nLPUSH number 1 2 3\n```\n\n##### LPOP\n`LPOP key [count]`按顺序删除并返回最左端元素，`count`参数指定删除元素的数量。注意：\n\n+ 列表元素不够，就有多少删多少；\n+ 列表为空，返回 nil；\n\n```bash\n# 返回 3 2 \nLPOP number 2\n```\n\n##### RPUSH\n`RPUSH key element [element ...]`往列表右端添加元素。\n\n```bash\n# 自左向右依次存储：1 2 3\nRPUSH number 1 2 3\n```\n\n##### RPOP\n`RPOP key [count]`按顺序删除并返回最右端元素，`count`参数指定删除元素的数量。注意事项与`LPOP`一样。\n\n```bash\n# 返回 3 2 \nRPOP number 2\n```\n\n##### LRANGE\n`LRANGE key start stop`获取列表指定下标的元素，下标范围为`[start, stop]`。\n\n有以下注意点：\n\n+ 下标表示范围是左右包含且从 0 开始计数；\n+ 若下标右侧越界，则会取到最后一个元素；\n+ 与 Python 类似，负数下标表示从后往前取；\n\n```bash\n# 取列表最后两个元素\nLRANGE number -2 -1\n```\n\n##### BLPOP\n`BLPOP key [key ...] timeout`删除并返回指定列表最左侧的元素，若列表为空则阻塞等待指定时长，单位秒。注意：这边传的多个`key`不是同时删除多个列表的意思，而是删除的时候从前到后依次判断，若某列表有元素就删除该列表的元素并结束，若所有列表均为空则等待。\n\n##### BRPOP\n`BRPOP key [key ...] timeout`删除并返回指定列表最右侧的元素，注意事项与`BLPOP`一样。\n\n##### LLEN\n`LLEN key`返回指定列表长度。\n\n##### LPOS\n`LPOS key element`返回列表中`element`所在下标，不存在返回 nil。\n\n#### Set\nSet 是 Redis 里面的无序集合，Redis 支持我们操作单个集合或做集合间的运算。\n\n##### SADD\n`SADD key member [member ...]`往集合添加若干个元素。\n\n##### SREM\n`SREM key member [member ...]`删除集合里的若干个元素。\n\n##### SCARD\n`SCARD key`返回集合的长度。\n\n##### SISMEMBER\n`SISMEMBER key member`返回元素`member`是否是集合里的元素。\n\n##### SMEMBERS\n`SMEMBERS key`返回集合里的所有元素。\n\n##### SPOP\n`SPOP key [count]`随机删除并返回集合中的`count`个元素，默认删一个。\n\n##### SINTER\n`SINTER key [key ...]`返回若干个集合的交集。\n\n##### SINTERSTORE\n`SINTERSTORE destination key [key ...]`将若干个集合的交集存储到`destination`指定的集合中，该集合不存在就创建，存在就覆盖。\n\n```bash\n# 以 set1、set2、set3 三者的交集生成 newSet\nSINTERSTORE newSet set1 set2 set3\n```\n\n##### SDIFF\n`SDIFF key [key ...]`返回第一个集合与其它集合的差集。\n\n```bash\n# 返回 set1 - set2 - set3\nSDIFF set1 set2 set3\n```\n\n##### SDIFFSTORE\n`SDIFFSTORE destination key [key ...]`将第一个集合与其它集合的差集存储到`destination`指定的集合中，该集合不存在就创建，存在就覆盖。\n\n##### SUNION\n`SUNION key [key ...]`返回若干集合的交集，注意重复元素会被剔除。\n\n##### SUNIONSTORE\n`SUNIONSTORE destination key [key ...]`将若干集合的交集存储到destination指定的集合中，该集合不存在就创建，存在就覆盖。\n\n#### SortedSet\nSortedSet 是 Redis 里面的有序集合（元素唯一），一般用于存储排行榜等有顺序的数据。SortedSet 需要我们为存储的数据指定一个 score，这个 score 就是排序的依据。\n\n##### ZADD\n`ZADD key score member [score member ...]`添加或修改若干元素到集合中，元素不存在就添加元素，元素存在就修改其分数。\n\n##### ZREM\n`ZREM key member [member ...]`删除集合中若干元素。\n\n##### ZSCORE\n`ZSCORE key member`返回一个元素的分数，元素不存在返回 nil。\n\n##### ZRANK\n`ZRANK key member`返回元素的正序排名，从 0 开始。正序排名是指集合从小到大排列，元素在里面的排名。\n\n##### ZCARD\n`ZCARD key`返回集合的大小，集合不存在返回 0。\n\n##### ZCOUNT\n`ZCOUNT key min max`返回分数在`[min, max]`范围内元素的个数。\n\n##### ZINCRBY\n`ZINCRBY key increment member`对集合中某元素的分数`+increment`。\n\n##### ZRANGE\n`ZRANGE key start stop`返回正序排名在`[start, stop]`范围的所有元素。\n\n##### ZRANGEBYSCORE\n`ZRANGEBYSCORE key min max`返回分数在`[min, max]`范围的所有元素。\n\n##### ZINTER\n`ZINTER numkeys key [key ...]`返回若干个集合的交集，`numkeys`指定集合的数量。注意返回的仅仅是元素本身，不会返回元素对应的分数。\n\n##### ZINTERSTORE\n`ZINTERSTORE destination numkeys key [key ...]`将若干集合的交集存储到`destination`指定的集合中，分数是所有集合中该元素分数的总和。\n\n##### ZDIFF\n`ZDIFF numkeys key [key ...]`返回第一个集合与后面所有集合的差，返回的也是元素本身，不包含其分数。\n\n##### ZDIFFSTORE\n`ZDIFFSTORE destination numkeys key [key ...]`将第一个集合与后面所有集合的差存储到`destination`指定的集合中，元素对应的分数就是元素在第一个集合中的分数。\n\n##### ZUNION\n`ZUNION numkeys key [key ...]`返回所有集合的并集并保证结果集元素唯一，返回结果仍然不包含元素的分数。\n\n##### ZUNIONSTORE\n`ZUNIONSTORE destination numkeys key [key ...]`将所有集合的并集存储到destination指定的集合中，新集合中元素的分数是之前集合中同元素分数的和。\n\n##### 逆序操作\n上面基本都是正序操作，即元素按照分数从小到大排序然后取值。很多时候需要用到逆序操作，这些操作与正序操作不过多了`REV`。举个例子，我想获取元素在集合里的排名：\n\n```bash\n# 元素正序排列，取 member 排名\nZRANK key member\n\n# 元素逆序排列，取 member 排名\nZREVRANK key member\n```\n\n#### key 层级结构\n我们在存在数据的时候，应当如何设计 key 使得不同项目、不同类型数据的 key 不会重复呢？Redis 支持我们使用`:`定义 key 的层级结构，一般定义规则：\n\n```python\n项目名:业务名:类型名:id\n```\n\n假设项目名是`lylmx`，业务名省略，我们有两种类型的数据（`user`与`product`）。具体数据如下：\n\n```json\n用户信息：{id: 1, name: \"Lucy\", age: 18}\n商品信息：{id: 1, name: \"iWatch\", price: 2888}\n```\n\n我们可以使用下面的命令将数据存到 Redis 中：\n\n```bash\nSET lylmx:user:1 \'{\"id\": 1, \"name\": \"Lucy\", \"age\": 18}\'\nSET lylmx:product:1 \'{\"id\": 1, \"name\": \"iWatch\", \"price\": 2888}\'\n```\n\n我们打开图形化界面查看存储的这两条数据，可以看到如下图：\n\n![](/upload/covers/7a281de30c3945d1a21482c9b0a852ab.png)\n\n图形化界面会根据键的层级创建出对应的目录（可视化）。\n\n### Java 集成 Redis\n#### Jedis\nJedis 是 Java 操作 Redis 的库，这个库里面的方法及其用法与 Redis 的操作保持一致。因此学会了上面 Redis 的操作，这个库基本就掌握了。\n\n##### 导包\n```xml\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>5.1.2</version>\n</dependency>\n```\n\n##### 基本使用\n我们使用字符串操作与 Hash 操作简单看一下 Jedis 的使用：\n\n```java\n// 创建 Jedis 对象并指定域名端口号\nJedis jedis = new Jedis(\"127.0.0.1\", 6379);\njedis.auth(\"123456\");  // 指定连接密码\njedis.select(0);  // 选择第 0 个库\n\n// 往库里新增一个键值对\njedis.set(\"hello\", \"world\");\nString hello = jedis.get(\"hello\");\n// 获取哈希字段\nString name = jedis.hget(\"user:1\", \"name\");\nSystem.out.println(hello + name);\n```\n\n可以看到 Jedis 提供的方法名与参数结构和 Redis 提供的方法是一致的。\n\n##### 连接池\nJedis 很好用，几乎没有学习成本。但美中不足的是 Jedis 线程不安全，因此需要配合连接池使用。我们自定义连接池如下：\n\n```java\npublic class JedisConnectFactory {\n    private static JedisPool jedisPool;\n\n    static {\n        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n        // 最大连接数\n        jedisPoolConfig.setMaxTotal(8);\n        // 最大空闲连接数\n        jedisPoolConfig.setMaxIdle(8);\n        // 最小空闲连接数\n        jedisPoolConfig.setMinIdle(0);\n        // 等待连接的超时时间\n        jedisPoolConfig.setMaxWait(Duration.ofSeconds(10));\n\n        jedisPool = new JedisPool(jedisPoolConfig, \"127.0.0.1\",\n                                  6379, 1000, \"123456\");\n    }\n\n    public static Jedis getJedis() {\n        return jedisPool.getResource();\n    }\n}\n```\n\n定义完成之后，后面我们想要使用 Jedis 对象就不需要`new`了，直接：\n\n```java\nJedis jedis = JedisConnectFactory.getJedis();\njedis.select(0);\n// 其它操作\n```\n\n获取的 Jedis 对象不需要配置密码，因为我们在连接池里面已经配置过密码了。\n\n#### SpringDataRedis\n##### 介绍\n市面上除了上面的 Jedis 库可以操作 Redis，还有许多好用的操作 Redis 的库，例如 lettuce。不同的库使用方式不同，学习成本太高。此时 SpringDataRedis 出现了，它提供一套统一的接口给我们使用，底层实现随意，可以是 Jedis 也可以是 lettuce（默认使用 lettuce）。因此以后我们可以只学习 SpringDataRedis 的用法，剩下的交给 Spring。\n\nSpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作 API 封装到了不同的类型中：\n\n| **API** | **返回值类型** | **说明** |\n| :---: | :---: | :---: |\n| `redisTemplate.opsForValue()` | `ValueOperations` | 操作 String 类型数据 |\n| `redisTemplate.opsForHash()` | `HashOperations` | 操作 Hash 类型数据 |\n| `redisTemplate.opsForList()` | `ListOperations` | 操作 List 类型数据 |\n| `redisTemplate.opsForSet()` | `SetOperations` | 操作 Set 类型数据 |\n| `redisTemplate.opsForZSet()` | `ZSetOperations` | 操作 SortedSet 类型数据 |\n| `redisTemplate` |  | 操作通用数据，例如获取所有键 |\n\n\n##### 导包\n```xml\n<!-- Redis 相关依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n    <version>2.7.18</version>\n</dependency>\n\n<!-- 额外的连接池相关依赖 -->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n    <version>2.12.0</version>\n</dependency>\n```\n\n##### 简单使用\n```java\n@Resource\nprivate RedisTemplate redisTemplate;\n\npublic void test() {\n    redisTemplate.opsForValue().set(\"name\", \"卢研\");\n    String name = redisTemplate.opsForValue().get(\"name\");\n}\n```\n\n代码不难理解，我想往 Redis 里面存储一个简单的键值对，键为`name`，值为`卢研`。但实际上可以通过图形化界面看到存储的内容是：\n\n![](/upload/covers/cf64872b56aa4b6fb9b9a762a4eeec62.png)\n\n可以看到键和值里面都多了一些莫名其妙的东西，这显然不是我们想要的结果。出现这个现象的原因是默认情况下`redisTemplate`会对存储的内容做原生序列化，然后将序列化之后的结果存进去。\n\n##### 自定义模板\n为了解决上述问题，我们可以在配置类里定制`redisTemplate`，替换掉里面的序列化器。\n\n```java\n@Bean\npublic RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n    RedisTemplate<String, Object> template = new RedisTemplate<>();\n    template.setConnectionFactory(redisConnectionFactory);\n\n    // 键都使用字符串\n    template.setKeySerializer(new StringRedisSerializer());\n    template.setHashKeySerializer(new StringRedisSerializer());\n\n    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer();\n    // 值都转 json\n    template.setValueSerializer(serializer);\n    template.setHashValueSerializer(serializer);\n    return template;\n}\n```\n\n在我们的配置中，键名直接使用字符串形式，值会经过 json 序列化然后存储。后面自动注入的时候会使用我们自定义的`redisTemplate`。\n\n```java\nUser user = new User(1, \"卢研\", 18);\nredisTemplate.opsForValue().set(\"user\", user);\nUser u = (User) redisTemplate.opsForValue().get(\"user\");\n```\n\n自定义序列化器之后，传进去一个对象会转为 json 存储，读取的时候也会反序列化成对应类型的对象。\n\n##### StringRedisTemplate\n\0使用自定义模板非常方便，但也存在一个问题。首先我们看一下存储一个`User`类型数据的结果：\n\n```json\n{\n    \"@class\": \"com.luyan.pojo.User\",\n    \"id\": 1,\n    \"name\": \"卢研\",\n    \"age\": 18\n}\n```\n\n可以看到除了对象本身具有的字段，多了`@class`字段。这个字段保存该数据对应的实体类类型，这也是读取时能够反序列化的依据。当然有好处也有坏处，坏处就是这会造成额外的开销，而 Redis 又是基于内存，空间非常紧张。解决方案是手动进行序列化与反序列化，SpringDataRedis 给我们提供了`StringRedisTemplate`类，这个类进行存储的时候不论键还是值都直接作为字符串存储：\n\n```java\n@Resource\nprivate StringRedisTemplate stringRedisTemplate;\nprivate ObjectMapper objectMapper = new ObjectMapper();\n\npublic void test() throws JsonProcessingException {\n    User user = new User(1, \"卢研\", 18);\n    // 手动进行序列化\n    String json = objectMapper.writeValueAsString(user);\n    stringRedisTemplate.opsForValue().set(\"user\", json);\n    json = stringRedisTemplate.opsForValue().get(\"user\");\n    // 手动反序列化\n    user = objectMapper.readValue(json, User.class);\n    System.out.println(user);\n}\n```\n\n### Spring Cache\nSpring Cache 是 Spring 提供的缓存组件，仍然是提供接口，底层可以使用各种各样的缓存中间件。我们这边当然使用 Redis 作为底层中间件。\n\n#### 准备\n##### 导包\n需要 Redis 作为底层中间件，所以直接导 Redis 相关的包即可：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n    <version>2.7.18</version>\n</dependency>\n```\n\n##### 启用缓存\n在启动类上使用`@EnableCaching`注解来启用缓存：\n\n```java\n@EnableCaching\n@SpringBootApplication\npublic class Main {\n    public static void main(String[] args) {\n        SpringApplication.run(Main.class, args);\n    }\n}\n```\n\n#### 使用\n##### SpEL\nSpEL 是 Spring Expression Language 的简写，它主要用于在注解中获取被修饰方法的信息。SpEL 里面主要有两个对象，分别是：\n\n+ `#root`可以获取被修饰方法的详细信息，例如当前方法对象、所属实例对象等；\n+ `#result`表示方法的返回值，如果返回值是一个对象，可以通过`#result.xxx`的方式获取对象属性；\n\n我们比较常用的是获取以下信息：\n\n1. 方法名：`#root.methodName`\n2. 方法参数的获取有三种方式：\n    1. `#root.args[0]`获取第一个参数；\n    2. `#p1`也是获取第一个参数；\n    3. `#xxx`直接使用参数的名字获取；\n3. 返回值：`#result`\n\n```java\n// 1. @example 仅作为示例，并不存在\n// 2. 注解里面使用 SpEL 表达式的前提是这个注解支持\n// 3. 这边表达式比较容易理解，需要注意的是如果只想写字符串需要使用单引号括起来\n@example(\"\'user\' + #root.methodName + #p1.name\")\npublic user(User user) {\n    return user;\n}\n```\n\n之所以普通字符串需要使用单引号括起来，是因为不加引号又没有`#`前缀会默认认为前面有`#root.`。因此获取方法名可以直接写`methodName`。\n\n##### @Cacheable\n\0对方法使用`@Cacheable`注解，每次执行该方法的时候会尝试从缓存查找结果：\n\n+ 若能找到，则直接返回该结果，此时不会执行方法体；\n+ 若找不到结果，则执行方法体并将结果存到缓存中；\n\n```java\n@Cacheable(value = \"userGroup\", key = \"\'user\' + #p0\")\npublic User one(Integer id){\n    User user = new User(1, \"张三\", 18);\n    return user;\n}\n```\n\n按照直觉缓存是键值对存储，但这边两个参数是什么意思？实际上 SpringCache 分层级存储，上面第一个指定的`userGroup`是群组名，后面的`key`指定的是键。所谓群组就是为了让数据存储更条理，例如用户数据存到用户群组，商品数据存到商品群组等。最后到 Redis 里面的键是`userGroup:user1`。\n\n##### @CacheEvict\n\0`@CacheEvict`注解用来删除缓存，每次执行被修饰方法，都会删除对应的缓存。与上面类似需要传递`value`与`key`属性，除此之外还有一个`allEntries`属性用来指定删除时是否删除全部缓存，默认`false`。\n\n```java\n// 这边指定 key 就有点多余了，因为会删除所有 userGroup 组下的缓存\n@CacheEvict(value = \"userGroup\", key = \"\'user\' + #id\", allEntries = true)\npublic String delete(Integer id){\n    System.out.println(\"方法执行，id：\" + id);\n    return \"OK\";\n}\n```\n\n如果没有设置`allEntries`会根据`value`与`key`属性构造键删除指定缓存。\n\n##### @CachePut\n`@CachePut`注解会将被修饰方法的返回值存进缓存，与`@Cacheable`的区别是不论缓存是否存在，`@CachePut`都会执行方法并将结果存到缓存之中。\n\n```java\n@CachePut(value = \"userGroup\", key = \"\'user\' + #user.id\")\npublic User put(User user){\n    return user;\n}\n```\n\n使用方式与其它注解没什么不同，不过在注解里面指定键需要的参数罢了。\n\n##### @Caching\n如果我想在一个方法上面定义多个缓存逻辑，应该怎么做？在方法上添加多个缓存注解？\n\n例如，我想在一个方法执行的时候删除指定缓存，但是我想删除的逻辑有两条。此时可以使用`@Caching`注解实现多缓存逻辑：\n\n```java\n@Caching(evict = {\n    @CacheEvict(value = \"userGroup\", key = \"\'id\' + #user.id\"),\n    @CacheEvict(value = \"userGroup\", key = \"\'name\' + #user.name\")\n})\npublic String delete(User user){\n    return \"OK\";\n}\n```\n\n这就实现了执行方法时删除多条缓存的逻辑，除此之外`@Caching`注解还有`cacheable`和`put`属性，这两个属性里面分别写`@Cacheable`和`@CachePut`注解。\n\n##### @CacheConfig\n`@CacheConfig`注解作用于类上，可以使用这个注解统一定义群组。例如一个类里面所有缓存策略都在同一个群组下面，就可以使用`@CacheConfig`注解将群组抽取出来定义在类上。\n\n```java\n@CacheConfig(cacheNames = \"userGroup\")\npublic class UserController {\n\n}\n```\n\n定义了群组之后，里面的方法上的注解就可以不指定群组，如果指定还是以方法上的群组为准。\n\n#### 条件式缓存\n上面所有的缓存策略都是无条件的，有时我们会根据情况的不同决定是否使用缓存，这就叫做条件式缓存。`@Cacheable`、`@CachePut`注解都有以下属性：\n\n+ `condition`指定条件为**真**才会执行缓存逻辑；\n+ `unless`指定条件为**假**才会执行缓存逻辑；\n\n`@CacheEvict`注解只有`condition`属性，没有`unless`属性。\n\n```java\n// 传来的 id ≥ 0 才会走缓存逻辑，否则都走函数体\n@Cacheable(key = \"\'user\' + #id\", condition = \"#id >= 0\")\npublic User one(Integer id){\n    System.out.println(\"方法执行，id：\" + id);\n    System.out.println(cacheManager);\n    User user = new User(1, \"张三\", 18);\n    return user;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n');


-- 初始化文章标签表
INSERT INTO `article_tag` (`id`, `article_id`, `tag_id`)
VALUES (8, 2, 100),
       (11, 1, 100),
       (16, 3, 72),
       (17, 3, 73),
       (18, 4, 69),
       (21, 5, 69),
       (22, 5, 75),
       (23, 6, 4),
       (24, 7, 4),
       (25, 8, 4),
       (26, 9, 4),
       (27, 10, 1),
       (28, 11, 1),
       (29, 11, 9),
       (30, 12, 1),
       (31, 12, 8),
       (32, 13, 1),
       (33, 13, 9),
       (34, 14, 1),
       (35, 14, 9),
       (36, 15, 1),
       (37, 15, 5),
       (38, 15, 9),
       (39, 16, 1),
       (40, 16, 8),
       (41, 17, 16),
       (42, 17, 15),
       (43, 17, 23),
       (44, 18, 16),
       (45, 18, 15),
       (46, 18, 23),
       (47, 19, 16),
       (48, 19, 15),
       (49, 19, 23),
       (54, 22, 11),
       (55, 22, 3),
       (56, 21, 11),
       (57, 21, 3),
       (58, 20, 11),
       (59, 20, 3),
       (60, 23, 1),
       (61, 23, 12);


-- 初始化配置表
INSERT INTO `config` (`id`, `type`, `name`, `banner_url`, `jump_url`, `content`, `status`)
VALUES (1, 2, '算法竞赛入门经典', '/configImages/algorithm.jpg', '/article/2', '清晰的讲解、丰富的实例帮助您快速提高算法能力！', 1),
       (2, 2, 'Java编程的逻辑', '/configImages/JavaLogic.png', '/article/1', '一本深入浅出、系统全面的Java编程指南。', 1),
       (3, 1, 'Git - 代码管理的大师，版本控制的先锋！', '/configImages/advCover1.jpg', '/article/3', '', 1),
       (4, 1, 'Regex - 精准匹配的艺术，文本处理的瑞士军刀！', '/configImages/advCover2.jpg', '/article/4', '', 1),
       (5, 1, 'Docker - 构建、交付、运行，随时随地，随心所欲！', '/configImages/advCover3.jpg', '/article/5', '', 1),
       (6, 1, 'Openpyxl - Python 驾驭 Excel，释放数据的无限可能！', '/configImages/advCover4.jpg', '/article/6', '', 1);


-- 初始化用户表
INSERT INTO `user` (`id`, `username`, `password`, `salt_pos`)
VALUES (1, 'admin', '1adaa294aa82641a40636596cd7ece10', 3),
       (2, 'guest', 'b371152381d83b10031d6f52aa7d121b', 4);


-- 初始化用户信息表
INSERT INTO `user_info` (`id`, `user_id`, `nick_name`, `photo`, `position`, `company`, `profile`)
VALUES (1, 1, '管理员', '/upload/headers/add0da3c4d5d4653b9e28385aea1d872.jpg', '硕士研究生', '江苏大学计算机学院', '书山有路勤为径，学海无涯苦作舟。'),
       (2, 2, '帅气的游客', '/headers/0011.png', '', '', '');
